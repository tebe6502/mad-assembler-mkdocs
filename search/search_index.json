{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mad-Assembler Mad-Assembler (MADS) jest cross-assemblerem MOS 6502/MOS 65C02/WDC 65816 autorstwa Tomazs Biela (tebe) . Najnowsze wydania dla systemu Windows s\u0105 dost\u0119pne na Github . Wydania dla innych platform system\u00f3w operacyjnych s\u0105 publikowane cyklicznie w ramach WUDSN IDE Tools . Historia Zmian 2.1.5 poprawione dzia\u0142anie .UNDEF , .IFDEF poprawione wykonywanie zagnie\u017cd\u017conych p\u0119tli .REPT dodana mo\u017cliwo\u015b\u0107 \u0142\u0105czenia obszar\u00f3w lokalnych, .LOCAL +full_path_to_local dodanie kolorowania komunikat\u00f3w konsoli etykiety automodyfikacji kodu, np. lda label: #$40 2.1.3 nowa dyrektywa .RND zwracaj\u0105ca warto\u015b\u0107 losow\u0105 z zakresu 0..255 dodany komunikat ostrze\u017cenia 'Register A is changed' dla pseudo rozkaz\u00f3w DEW , DEL , DED nowy prze\u0142\u0105cznik -bc 'Branch condition test' , powoduje wygenerowanie komunikat\u00f3w ostrze\u017cenia w przypadku kiedy skok jest poza zakres lub przekracza stron\u0119 pami\u0119ci 2.1.0 dodany komunikat ostrze\u017cenia 'Buggy indirect jump' w przypadku u\u017cycia rozkazu JMP(ABS) dodana dyrektywa .FILEEXISTS('filename') zwracajaca 1 gdy plik w podanej \u015bcie\u017cce istnije, 0 gdy nie istnieje rozszerzony komunikat Value out of range (VALUE must be between X and Y) 2.0.9 .CBM 'text' konwersja na znaki ekranowe Commodore C64 usuni\u0119ty b\u0142\u0105d kiedy procedura .PROC znajduj\u0105ca si\u0119 w bloku .LOCAL nie zosta\u0142a oznaczona jako 'do asemblacji' mimo tego \u017ce by\u0142o do niej odwo\u0142anie z poziomu makra .MACRO w bloku .LOCAL usuni\u0119ty b\u0142\u0105d, etykiety tymczasowe ?label by\u0142y oznaczane 'do relokacji' 2.0.8 kr\u00f3tszy kod dla #CYCLE poprawki dla .BY .WO .HE .SB .CB .FL dodano komunikat b\u0142\u0119du 'Improper syntax' w przypadku u\u017cycia .BY .WO .HE .SB .CB .FL w bloku .STRUCT dodane dyrektywy dla WDC 65816 .LONGA ON|OFF .LONGI ON|OFF poprawione dzia\u0142anie \u015bledzenia rozmiaru rejestr\u00f3w WDC 65816 gdy OPT T+ added command line option -fv:value to set the memory fill value when OPT F+ . dodany prze\u0142\u0105cznik -fv:value pozwalaj\u0105cy ustali\u0107 warto\u015b\u0107 wype\u0142nienia pami\u0119ci gdy OPT F+ dodana mo\u017cliwo\u015b\u0107 podania argumentu jako ci\u0105gu dw\u00f3ch znak\u00f3w (poprzednio tylko 1 znak) np. lda #'AB' , mwa #'XY' $80 2.0.7 poprawione generowanie kodu wynikowego dla nielegali DOP i SHA dodane dyrektywy WDC 65816 .A8 .A16 .I8 .I16 .AI8 .IA8 .AI16 .IA16 pozwalaj\u0105ce ustawi\u0107 rozmiar rejestr\u00f3w AXY dodane dyrektywy WDC 65816 .ASIZE .ISIZE zwracaj\u0105ce aktualnie ustawiony rozmiar rejestr\u00f3w AXY rozkaz JMP zmieniany jest na JML WDC 65816 tylko gdy skok dotyczy innego 64KB banku ni\u017c obecny dodany prze\u0142\u0105cznik -ml:value (margin-left property), kt\u00f3ry umo\u017cliwia zmian\u0119 lewego marginesu generowanego listingu w zakresie od 32 do 128 znak\u00f3w 2.0.6 poprawione parsowanie parametr\u00f3w makra zapisanych przy pomocy etykiet .macro test currentRow, previousRow .print Tmp%%currentRowAllowed .print Tmp%%previousRowAllowed .endm poprawione alokowanie danych .ARRAY gdy nie ma okre\u015blonego rozmiaru, lub jest to tablica inna ni\u017c jednowymiarowa zwi\u0119kszona liczba przebieg\u00f3w dla .PROC , w pewnych warunkach dla parametru xa .reg parametr by\u0142 \u017ale interpretowany dodana dyrektywa .DEFINE pozwalaj\u0105ca definiowa\u0107 jedno liniowe makra (mo\u017cna definiowa\u0107 wielokrotnie w tym samym przebiegu) .DEFINE macro_name expression .DEFINE write .print %%1+%%2 write (5,12) .DEFINE text .sb text 'atari' dodana dyrektywa .UNDEF macro_name , usuwa definicj\u0119 jedno liniowego makra macro_name 2.0.5 tablice .ARRAY w bloku .PROC s\u0105 pomijane je\u015bli u\u017cyto prze\u0142\u0105cznik -x Exclude unreferenced procedures u\u017cycie .ARRAY w bloku .STRUCT nie b\u0119dzie generowa\u0107 ju\u017c zer w pliku wynikowym nowa dyrektywa .XGET , pozwalaj\u0105ca wczyta\u0107 do bufora pami\u0119ci MADS plik i dodatkowo zmodyfikowa\u0107 jego bajty pod warunkiem \u017ce s\u0105 r\u00f3\u017cne od zera (przydatne dla VBXE ) 2.0.4 usuni\u0119ty b\u0142\u0105d powoduj\u0105cy b\u0142\u0119dny zapis bloku aktualizacji dla starszego bajtu adresu w bloku .RELOC .DB .DW usuni\u0119te .DBYTE (MSB/LSB) odk\u0142ada s\u0142owo w odwrotnej kolejno\u015bci (starszy/m\u0142odszy) dodane dyrektywy .WGET WORD , .LGET LONG , .DGET DWORD poprawione dzia\u0142anie makro rozkazk\u00f3w ADW i SBW , np.: adw (tmp),y #1 posx adw (tmp),y ptr2 ptr4 2.0.2 poprawione alokowanie danych dla .SB [+<byte>],<bytes|string|char> 2.0.1 poprawione alokowanie danych dla .ARRAY gdy typ wi\u0119kszy od .BYTE .SIZEOF zwraca rozmiar dla wbudowanych typ\u00f3w .BYTE .WORD .LONG .DWORD dodana relokowalna wersja playera MPT examples\\players\\mpt_player_reloc.asm poprawione dzia\u0142anie dyrektywy .DS w blokach SDX blk sparta $xxx kt\u00f3re nie s\u0105 relokowalne 1.9.8 naprawione dzia\u0142anie rozkaz\u00f3w WDC 65816 PEA PEI PER dodana mo\u017cliwo\u015b\u0107 podania kodu dla .RELOC [.BYTE|WORD] [TYPE] 1.9.7 dyrektywa .DEF definiuje etykiety o zasiegu lokalnym, je\u015bli poprzedzi\u0107 j\u0105 znakiem : to globalne poprawki dla liczb zmiennoprzecinkowych .FL, poprawione kodowane zera, dokonywane zaokr\u0105glenie do 10 miejsc po przecinku dla blok\u00f3w Sparta DOS X blk reloc i blk empty dodana mo\u017cliwo\u015b\u0107 okre\u015blenia innego typu pami\u0119ci ni\u017c $00 (main), $02 (extended), np.: blk reloc $40 poprawka umo\u017cliwiaj\u0105ca u\u017cycie dyrektywy .PRINT po blk empty dodana mo\u017cliwo\u015b\u0107 definiowania wielowymiarowych tablic .ARRAY , np.: .array scr [24][40] [11][16] = \"atari\" .enda mva #\"!\" scr[11][22] dodana mo\u017cliwo\u015b\u0107 definiowania tablicy .ARRAY poprzez dyrektyw\u0119 .DS , np.: tmp .ds .array [5][12][4] .word dodana mo\u017cliwo\u015b\u0107 definiowania tablicy .ARRAY poprzez pseudorozkaz EQU (=), np.: fnt = $e000 .array [128] [8] .byte naprawione dzia\u0142anie makrorozkazu ADW w po\u0142\u0105czeniu z makrorozkazem SCC itp. poprawki dla .REPT , m.in. komentarz wieloliniowy /* */ jest teraz w\u0142a\u015bciwie rozpoznawany 1.9.6 poprawione dzia\u0142anie etykiet anonimowych dla mnemonik\u00f3w \u0142\u0105czonych znakiem : , np.: ldx #8 @ lda:cmp:req 20 dex bne @- dodany pseudo rozkaz COS (centre,amp,size[,first,last]) generuj\u0105cy warto\u015bci dla funkcji cosinus dodany komunikat b\u0142\u0119du Improper syntax w przypadku u\u017cycia dyrektywy .DS w bloku .STRUCT naprawione dzia\u0142anie pseudo rozkazu ORG , np.: opt h- ORG [a($ffff),d'atari',c'ble',20,30,40],$8000,$a000 addytywne bloki .LOCAL otrzymuj\u0105 kolejne adresy, poprzednio adres ustalany by\u0142 na podstawie pierwszego wyst\u0105pienia takiego bloku dodany komunikat ostrze\u017cenia w przypadku stworzenia kolejnego addytywnego bloku .LOCAL o tej samej nazwie Ambiguous label LOCAL_NAME dodane mnemoniki PER (PEA rell), PEI (PEA (zp)) dla WDC 65816 dodane nowy typ danych M (najstarszy bajt LONG ) i G (najstarszy bajt DWORD ) dla pseudorozkazu DTA , np.: dta m($44556677) ; -> $55 dta g($44556677) ; -> $44 dyrektywa .LEN .SIZEOF rozszerzona o obs\u0142ug\u0119 danych alokowanych poprzez DTA STRUCT_NAME , np.: .STRUCT free_ptr_struct prev .WORD next .word .ENDS free_ptr_t dta free_ptr_struct [3] .print .sizeof(free_ptr_t) ; free_ptr_struct [0..3] = 16 bytes zmiany dla operacji odczytu plik\u00f3w poprzez ICL , INS itp. plik do odczytu/zapisu b\u0119dzie poszukiwany najpierw w \u015bcie\u017cce, kt\u00f3ra prowadzi do obecnie otwartego pliku, nast\u0119pnie ze \u015bcie\u017cki z kt\u00f3rej zosta\u0142 uruchomiony g\u0142\u00f3wny asemblowany plik i na ko\u0144cu ze \u015bcie\u017cek podanych parametrem -i (additional include directories) poprawione rozpoznawanie wielko\u015bci znak\u00f3w gdy aktywowany jest prze\u0142\u0105cznik -c (char sensitive) dla struktur, np.: .struct fcb sEcbuf .byte .ends data dta fcb [1] (0) lda data[0].sEcbuf rozszerzone dzia\u0142anie dyrektywy .REPT o mo\u017cliwo\u015b\u0107 jej zagnie\u017cd\u017cania np.: .rept 2,#*2 ; 1 - $0000 ; 2 - $0000 .print '1 - ',# ; 1 - $0001 ; 2 - $0000 .rept :1 ; 2 - $0001 .print '2 - ',.r ; 2 - $0002 .endr ; ; .endr kr\u00f3tsza wersja p\u0119tli #WHILE bez wyra\u017cenia, p\u0119tla trwa dop\u00f3ki LABEL <> 0 #while .word label #end 1.9.5 dodany pseudorozkaz SET pozwalaj\u0105cy redefiniowa\u0107 etykiet\u0119, podobne dzia\u0142anie jak etykiety tymczasowe zaczynaj\u0105ce si\u0119 znakiem ? , np.: temp set 12 lda #temp temp set 23 lda #temp dodana mo\u017cliwo\u015b\u0107 wymuszenia trybu adresowania w stylu XASM a: i z: , np.: XASM MADS lda a:0 lda.a 0 ldx z:0 lda.z 0 dodana mo\u017cliwo\u015b\u0107 okre\u015blenia nowego adresu relokacji kodu w stylu XASM r: , np.: XASM MADS org r:$40 org $40,* poprawione dzia\u0142anie parametru -x Exclude unreferenced procedures , zmienne .VAR nie s\u0105 alokowane gdy procedura jest nieu\u017cywana rozszerzona sk\u0142adnia dla jednoliniowych p\u0119tli :rept , mo\u017cliwe wykorzystanie licznika p\u0119tli jako parametru :1 lub %%1 , np.: line0 line1 line2 line3 ladr1 :4 dta l(line:1) hadr1 :4 dta h(line:1) ladr2 :4 dta l(line%%1) hadr2 :4 dta h(line%%1) dodany komunikat ostrze\u017cenia w przypadku u\u017cycia nielegalnych niestabilnych rozkaz\u00f3w 6502 , np. CIM dodany komunikat ostrze\u017cenia w przypadku u\u017cycia nielegalnych niestabilnych rozkaz\u00f3w 6502 , np. CIM dodana nowa funkcjonalno\u015b\u0107 dla pseudorozkaz\u00f3w RUN i INI , kt\u00f3re teraz zachowuj\u0105 adres asemblacji, poprzednio przestawia\u0142y adres asemblacji na $2E0 (RUN), $2E2 (INI) dodana obs\u0142uga etykiet anonimowych anonymous labels @ @+[1..9] (forward) @-[1..9] (backward), w celu zapewnienia przejrzysto\u015bci kodu ograniczone jest u\u017cywania takich etykiet tylko dla skok\u00f3w warunkowych oraz do 10 wyst\u0105pie\u0144 w prz\u00f3d/ty\u0142, np.: @ dex <------+---+ bne @+ --+ | | stx $80 | | | @ lda #0 <-+ | | bne @- ------+ | bne @-1 --------+ rozszerzone dzia\u0142anie dyrektyw #IF i #WHILE o zmienne deklarowane przez .VAR , dotychczas wymagane by\u0142o podanie typu zmiennej, np.: .var temp .word #if temp>#2100 ;Now #end #if .word temp>#2100 ;Before #end 1.9.4 dodana normalizacja \u015bcie\u017cek dla plik\u00f3w, tak aby dzia\u0142a\u0142y pod Unixami , znaki \\ zamieniane s\u0105 na / poprawione przekazywanie dyrektyw jako parametr\u00f3w do procedur i makr, dyrektywy nie by\u0142y rozpoznawane przy w\u0142\u0105czonym prze\u0142\u0105czniku -c (case sensitive) poprawione dzia\u0142anie .USE .USING dodana informacja w postaci ostrze\u017cenia WARNING o etykiecie powoduj\u0105cej niesko\u0144czon\u0105 ilo\u015b\u0107 przebieg\u00f3w asemblacji INFINITE LOOP dodany zapis dw\u00f3ch bajt\u00f3w nag\u0142\u00f3wka FF FF dla pliku zawieraj\u0105cego blok o adresie \u0142adowania $FFFF komentarze po mnemonikach nie wymagaj\u0105cych argumentu zostan\u0105 potraktowane jako b\u0142\u0105d, wyj\u0105tkiem jest \u0142\u0105czenie rozkaz\u00f3w w stylu xasm poprzez znak : , np.: pla $00 -> ERROR: Extra characters on line pha:pla $00 -> OK rozszerzona sk\u0142adnia makr o mo\u017cliwo\u015b\u0107 u\u017cywania parametr\u00f3w w postaci nazw a nie tylko warto\u015bci numerycznych-decymalnych, np.: .macro SetColor val,reg lda :val sta :reg .endm .macro SetColor2 (arg1, arg2) lda #:arg1 sta :arg2 .endm naprawione definiowanie etykiet dla n/w sytuacji, pierwsza etykieta nie zostanie zignorowana temp label = 100 1.9.3 poprawione przetwarzanie blok\u00f3w .PROC , kt\u00f3re w pewnych okoliczno\u015bciach mog\u0142y zosta\u0107 pomini\u0119te podczas asemblacji poprawiony zapis BLK EMPTY dla plik\u00f3w SDX je\u015bli zastosowali\u015bmy deklaracj\u0119 takiego bloku przez .DS poprawki dotycz\u0105ce testowania ko\u0144ca linii dodane dyrektywy .FILESIZE , .SIZEOF jako odpowiednik dotychczasowej dyrektywy .LEN rozszerzona sk\u0142adnia dla p\u00f3l struktury .STRUCT , np.: .struct name .byte label0 .byte :5 label1 label2 .byte label3 :2 .word .ends 1.9.2 mo\u017cliwo\u015b\u0107 okre\u015blenia adresu dla .ZPVAR = $XX usprawnione odwo\u0142ania do etykiet wyliczeniowych .ENUM , np. enum_label(field0, field1) dodana mo\u017cliwo\u015b\u0107 generowania bloku dla symboli zewn\u0119trznych BLK UPDATE EXTRN dla plik\u00f3w DOS-a , poprzednio tylko dla plik\u00f3w .RELOC , np.: .extrn vbase .word org $2000 lda #$80 sta vbase+$5d blk update extrn dodany komunikat b\u0142\u0119du Could not use NAME in this context w przypadku rozkaz\u00f3w odwo\u0142a\u0144 do blok\u00f3w .MACRO .ENUM .STRUCT poprawiony b\u0142\u0105d kt\u00f3ry uniemo\u017cliwia\u0142 u\u017cycie EQU w nazwie etykiety dodana dyrektywa .CB +byte,..... , ostatni bajt ci\u0105gu znakowego zapisywany jest w inwersie dodana obs\u0142uga segment\u00f3w poprzez dyrektywy .SEGDEF .SEGMENT .ENDSEG dodana nowa dyrektywa #CYCLE #N generuj\u0105ca kod 6502 o zadanej liczbie cykli N dodana obs\u0142uga nielegalnych rozkaz\u00f3w 6502 , przyk\u0142ad w pliku .\\examples\\test6502_illegal.asm uaktualnione pliki konfiguracyjne dla Notepad++ ..\\syntax\\Notepad++ poprawiony zapis pliku LST naprawiona alokacja pami\u0119ci dla zmiennych strukturalnych, rozszerzona sk\u0142adnia dla .STRUCT .struct LABEL x,y,z .word // wiele zmiennych tego samego typu w jednej linii .byte a,b .ends .enum type a=1,b=2 .ende .struct label2 x type type y .ends 1.9.0 naprawiony zapis linii z komentarzem /* */ do pliku listingu *.LST , poprzednio takie linie nie by\u0142y zapisywane poprawka dla etykiet deklarowanych z linii komend -d:label , poprzednio takie etykiety widziane by\u0142y tylko w pierwszym przebiegu w przypadku addytywno\u015bci blok\u00f3w .LOCAL tylko pierwszy adres z takich blok\u00f3w jest zapisywany poprawki dotycz\u0105ce parsowania makr, poprzednio etykiety zaczynaj\u0105ce si\u0119 od END mog\u0142y zosta\u0107 zinterpretowane jako pseudo rozkaz END poprawka odczytu dla pustego pliku relokowalnego, poprzednio wyst\u0119powa\u0142 b\u0142\u0105d Value out of range poprawki dla .USING .USE 1.8.8 - 1.8.9 uaktualniony silnik duch\u00f3w programowych ..\\EXAMPLES\\SPRITES\\CHARS o duchy 8x24 w przypadku braku podania rozszerzenia pliku i braku istnienia takiego pliku dla ICL 'filename' zostanie domy\u015blnie przyj\u0119te rozszerzenie *.ASM ICL 'filename.asm' poprawione dzia\u0142anie komentarzy /* */ w blokach .MACRO .REPT usuni\u0119ty b\u0142\u0105d uniemo\u017cliwiaj\u0105cy poprawn\u0105 asemblacj\u0119 bloku #IF #WHILE dla wyra\u017ce\u0144 \u0142\u0105czonych przez .OR .AND prze\u0142\u0105czniki w linii komend mog\u0105 by\u0107 poprzedzone tylko znakiem - , poprzednio tak\u017ce / jednak by\u0142y problemy z dzia\u0142aniem tego znaku na MacOSX poprawiony zakres dzia\u0142ania dyrektywy .USING , dla aktualnej przestrzeni nazw i kolejnych zawieraj\u0105cych si\u0119 w tej przestrzeni nazw 1.8.6 - 1.8.7 usprawnione rozpoznawanie komentarzy /* */ w wyra\u017ceniach domy\u015blny adres dla .ZPVAR ustawiony na $0080 , poprzednio $0000 dodana nowa dyrektywa .ELIF jako kr\u00f3tszy odpowiednik dyrektywy .ELSEIF rozszerzone dzia\u0142anie dyrektywy .LEN o mo\u017cliwo\u015b\u0107 podania jako parametru nazwy pliku, zwracana jest w\u00f3wczas d\u0142ugo\u015b\u0107 takiego pliku usprawnione dzia\u0142anie dyrektywy .DEF w wyra\u017ceniach warunku .IF .IFDEF IFNDEF 1.8.5 dodane makro relokuj\u0105ce modu\u0142y RMT ...\\EXAMPLES\\MSX\\RMT_PLAYER_RELOCATOR\\ dodany test sk\u0142adni dla nie asemblowanych procedur .PROC gdy aktywny jest prze\u0142\u0105cznik -x Exclude unreferenced procedures poprawione dzia\u0142anie prze\u0142\u0105cznika -d:label[=value] , podanie warto\u015bci dla etykiety jest teraz opcjonalne, domy\u015blnie mads przypisze warto\u015b\u0107 1 dyrektywy .DS .ALIGN nie spowoduj\u0105 alokacji zmiennych zdefiniowanych przez .VAR alokacja zmiennych .VAR przed nowym blokiem ORG nie nast\u0105pi je\u015bli blok ORG znajduje si\u0119 w bloku .LOCAL lub .PROC poprawione \u0142amanie wierszy znakiem \\ w ci\u0105gach ograniczonych nawiasami () usuni\u0119ty b\u0142\u0105d powoduj\u0105cy relokowanie adresu dla wyra\u017cenia dyrektywy .ERROR ERT usuni\u0119te zauwa\u017cone b\u0142\u0119dy przy parsowaniu parametr\u00f3w linii komend usuni\u0119te zauwa\u017cone b\u0142\u0119dy dotycz\u0105ce optymalizacji d\u0142ugo\u015bci kodu makro rozkaz\u00f3w MVA MWA itp. poprawiony kod realizuj\u0105cy zagnie\u017cd\u017canie blok\u00f3w .PROC poprawiony kod realizuj\u0105cy dzia\u0142anie pseudo rozkaz\u00f3w warunku IFT ELI ELS EIF dodany komunikat '#' is allowed only in repeated lines dla przypadk\u00f3w u\u017cycia licznika p\u0119tli # (.R) poza p\u0119tl\u0105 usuni\u0119ty b\u0142\u0105d powoduj\u0105cy b\u0142\u0119dne alokowanie zmiennych zadeklarowanych przez dyrektyw\u0119 .VAR podczas wykonywania makra w celu ujednolicenia sk\u0142adni odwo\u0142ania do etykiet typ\u00f3w wyliczeniowych mo\u017cliwe s\u0105 tylko poprzez znak kropki . , poprzednio tak\u017ce przez :: mo\u017cliwe kr\u00f3tsze odwo\u0142ania do typ\u00f3w wyliczeniowych enum_label(fields) , np. : .enum typ val0 = 1 val1 = 5 val2 = 9 .ende lda #typ(val0|val2) ; == \"lda #typ.val0|typ.val2\" rozszerzona sk\u0142adnia dyrektywy .SAV , np.: .sav 'filename',offset,length .sav 'filenema',length .sav [offset] 'filename',offset2,length .sav length .sav offset,length rozszerzona sk\u0142adnia dyrektywy .ARRAY , w przypadku braku podania maksymalnego indeksu tablicy zostanie on obliczony na podstawie ilo\u015bci wprowadzonych element\u00f3w, elementy mo\u017cna wprowadza\u0107 bez konieczno\u015bci poprzedzenia ich indeksem [expression], np.: .array temp .byte 1,4,6 ; [0..2] = 1,4,6 [12] = 9,3 ; [12..13] = 9,3 [5]:[8] = 10,16 ; [5..6] = 10,16 ; [8..9] = 10,16 0,0,\\ ; [14..17] = 0,0,1,1 1,1 .enda ; 18 element\u00f3w, TEMP [0..17] dodana mo\u017cliwo\u015b\u0107 alokacji zmiennej typu strukturalnego przy pomocy dyrektyw .VAR .ZPVAR , np.: .struct Point x .byte y .byte .ends .var a,b,c Point .zpvar Point f,g,i dodana mo\u017cliwo\u015b\u0107 alokacji zmiennej typu wyliczeniowego przy pomocy dyrektyw .VAR .ZPVAR , np.: .enum Boolean false = 0 true = 1 .ende .var test Boolean .zpvar Boolean test dodana mo\u017cliwo\u015b\u0107 deklaracji p\u00f3l struktury przy pomocy typ\u00f3w wyliczeniowych, np.: .enum EState DONE, DIRECTORY_SEARCH, INIT_LOADING, LOADING .ende .struct SLoader m_file_start .word m_file_length .word m_state EState .ends 1.8.3 - 1.8.4 nowy silnik duch\u00f3w programowych z minimalnymi wymaganiami pami\u0119ci, bez dodatkowych bufor\u00f3w pami\u0119ci obrazu ...EXAMPLES\\SPRITES\\CHARS_NG nowa wersja pakera Huffmana (kompatybilna z Free Pascal Compiler-em , fpc -MDelphi sqz15.pas ) i dekompresora Huffmana SQZ15 ...EXAMPLES\\COMPRESSION\\SQUASH poprawiony kod generowany dla rozkaz\u00f3w MVP MVN PEA BRA for WDC 65816 dodane nowe rozkazy BRL JSL JML WDC 65816 , jako odpowiedniki rozkaz\u00f3w d\u0142ugich skok\u00f3w BRA JSR JMP blok aktualizacji etykiet zewn\u0119trznych (external) zosta\u0142 rozszerzony o zapis m\u0142odszego i starszego bajtu adresu takiej etykiety poprawione dzia\u0142anie dyrektywy .USE .USING , dzia\u0142a niezale\u017cnie od przestrzeni nazw w kt\u00f3rej zostanie u\u017cyta usuni\u0119ty b\u0142\u0105d, kt\u00f3ry powodowa\u0142 w pewnych sytuacjach pomijanie asemblacji bloku #IF #WHILE dodana mo\u017cliwo\u015b\u0107 definiowania zmiennych poprzez dyrektyw\u0119 .DS lub pseudo rozkaz ORG przed blokiem .RELOC dodana dodatkowa forma sk\u0142adni dla dyrektywy .VAR , z tym \u017ce dla takiego przypadku nie ma mo\u017cliwo\u015bci okre\u015blenia adresu umiejscowienia zmiennych w pami\u0119ci .VAR .TYPE lab1 lab2 lab3 .TYPE lab4 .TYPE lab5 lab6 ... .var .byte a,b,c .dword i j dodana mo\u017cliwo\u015b\u0107 definicji pojedy\u0144czych zmiennych typu strukturalnego w kr\u00f3tszy spos\u00f3b ani\u017celi dot\u0105d przez DTA .struct @point x .byte y .byte .ends pointA @point ; pointA dta @point [0] <=> pointA dta @point pointB @point ; pointB dta @point [0] <=> pointB dta @point points dta @point [100] dodana nowa dyrektywa .ZPVAR umo\u017cliwiaj\u0105ca automatyczne przydzielenie miejsca zmiennym na stronie zerowej .ZPVAR TYPE label1, label2 label3 = $80 ; LABEL1=$80, LABEL2=LABEL1+TYPE, LABEL3=LABEL2+TYPE .ZPVAR label4, label5 TYPE ; LABEL4=LABEL3+TYPE, LABEL5=LABEL4+TYPE .print .zpvar poprawione dzia\u0142anie dyrektywy .ERROR i pseudo rozkazu ERT , mo\u017cliwe jest umieszczenie dodatkowych informacji w wierszu podobnie jak dla .PRINT .ECHO np.: ERT *>$6000 , BUUU przekroczyli\u015bmy zakres pami\u0119ci o ' , *-$6000 , ' bajt\u00f3w' dodana mo\u017cliwo\u015b\u0107 zagnie\u017cd\u017cania blok\u00f3w procedur .PROC, ten sam kod mo\u017ce by\u0107 wywo\u0142ywany z r\u00f3\u017cnymi parametrami np.: .proc copySrc (.word src+1) .var .proc ToDst (.word src+1, dst+1) .var .endp ldy #0 src lda $ffff,y dst sta $ffff,y iny bne src rts .endp copySrc.ToDst #$a080 #$b000 copySrc #$a360 dodane nowe dyrektywy .ENUM .ENDE .EEND .enum dni_tygodnia poniedzialek = 1 wtorek, sroda = 5, czwartek = 7 piatek sobota niedziela .ende ift dzien==dni_tygodnia::wtorek .print 'wtorek' eif rozszerzona funkcjonalno\u015b\u0107 komentarzy wieloliniowych /* */ o mo\u017cliwo\u015b\u0107 umieszczania ich gdziekolwiek lda #12+ /* komentarz */ 23 umo\u017cliwiona relokacja adres\u00f3w definiowanych dyrektyw\u0105 .DEF .reloc .def label=* lda label dodana mo\u017cliwo\u015b\u0107 u\u017cycia znak\u00f3w { } do oznaczenia bloku (z wyj\u0105tkiem blok\u00f3w .MACRO ), znak { } zostaje rozpoznany na pocz\u0105tku nowego wiersza, np.: #while .word ad+1<=#$bc40+39 { ad sta $bc40 inw ad+1 } .proc lab { .local temp2 { } .array tab [255] .long {} } 1.8.2 zniesione ograniczenie d\u0142ugo\u015bci pliku dla pseudo rozkazu INS (poprzednio d\u0142ugo\u015b\u0107 wczytywanego pliku ograniczona by\u0142a do 65536 bajt\u00f3w) dodany komunikat b\u0142\u0119du The referenced label ... has not previously been defined properly w przypadku etykiet, kt\u00f3re nie zosta\u0142y zdefiniowane do ko\u0144ca, np. tylko w pierwszym przebiegu warto\u015bci\u0105 nieokre\u015blon\u0105 dodana nowa dyrektywa .ECHO jako odpowiednik dyrektywy .PRINT, dodatkowo informacje generowane przez .PRINT .ECHO zapisywane s\u0105 teraz tak\u017ce w listingu *.LST dodana nowa dyrektywa .ALIGN pozwalaj\u0105ca na wyr\u00f3wnanie do zadanego zakresu pami\u0119ci, dodatkowo mo\u017cna okre\u015bli\u0107 warto\u015b\u0107 jak\u0105 wype\u0142ni\u0107 pami\u0119\u0107 [label] .ALIGN N[,fill] dodany nowy prze\u0142\u0105cznik -U (Warn of unused labels) 1.8.1 rozszerzone dzia\u0142anie znaku backslash \\ , umieszczenie go na ko\u0144cu wiersza oznacza kontynuacj\u0119 aktualnego wiersza od nowego wiersza, np.: macro_temp \\ _____________________________________parametr1_________________________________________________\\ _____________________________________parametr2_________________________________________________\\ _____________________________________parametr3_________________________________________________ lda\\ #____________________________________label________________________________________\\ +__________________________________expression___________________________________ zmienione testowanie nieko\u0144cz\u0105cego wywo\u0142ywania si\u0119 makr po kt\u00f3rym wyst\u0105pi b\u0142\u0105d Infinite loop naprawiony zapis etykiet do pliku *.LAB , b\u0142\u0105d powsta\u0142 po dodaniu addytywno\u015bci obszar\u00f3w LOCAL poprawione dzia\u0142anie pseudo rozkazu SIN (kod zapo\u017cyczony z XASM ) poprawione rozpoznawanie dyrektyw przy w\u0142\u0105czonym prze\u0142\u0105czniku -C (Case sensitive) usprawniony odczyt blok\u00f3w .REPT (wskazanie prawid\u0142owej linii z b\u0142\u0119dem) i .MACRO zablokowane u\u017cycie .VAR w bloku .REPT umo\u017cliwione zagnie\u017cd\u017canie oraz wielokrotne uruchamianie (poprzez makra) p\u0119tli .REPT :repeat (poprzednio wyst\u0119powa\u0142 komunikat Use .REPT directive ) umo\u017cliwione przekazywanie parametr\u00f3w do bloku .REPT, np. .REPT 10, # label:1 ; LABEL0, LABEL1, LABEL2 ... LABEL9 .ENDR .REPT 5, $12,$33,$44,$55,$66 dta :1,:2,:3,:4,:5 ; $12,$33,$44,$55,$66 dta :5,:4,:3,:2,:1 ; $66,$55,$44,$33,$12 .ENDR 1.7.9 - 1.8.0 poprawiony b\u0142\u0105d w opisie prze\u0142\u0105cznika -f , poprzednio Label at first column , prawid\u0142owy opis to CPU command at first column przepisana od nowa obs\u0142uga dyrektywy .DS i opcji OPT F+ (dodana mo\u017cliwo\u015b\u0107 u\u017cycia blok\u00f3w RUN i INI) przepisana od nowa obs\u0142uga opcji OPT ?+ (etykiety lokalne w standardzie MAE ) dodana mo\u017cliwo\u015b\u0107 upublicznienia w blokach PUBLIC tablic zadeklarowanych przez .ARRAY oraz deklaracji struktur .STRUCT dyrektywa generuj\u0105ca kod 6502 dla decyzji .TEST zast\u0105piona zosta\u0142a przez dyrektyw\u0119 #IF , dyrektywa .ENDT przez #END , dodatkowo mo\u017cliwe jest u\u017cycie dyrektywy #ELSE np.: # if .byte i>#8 .and .byte i<#200 # else #if .word j = #12 #end # end dyrektywa generuj\u0105ca kod 6502 dla iteracji .WHILE zast\u0105piona zosta\u0142a przez dyrektyw\u0119 #WHILE , dyrektywa .ENDW przez #END , np.: lda 20 -> lda 20 # while .byte @=20 -> wait cmp 20 # end -> sne -> jmp wait dyrektywy #IF #WHILE akceptuj\u0105 dwa dodatkowe operatory == != dodana dyrektywa .EXITM jako odpowiednik .EXIT dodana dyrektywa .FI jako odpowiednik .ENDIF dodana dyrektywa .IFDEF jako kr\u00f3tszy odpowiednik dyrektyw .IF .DEF dodana dyrektywa .IFNDEF jako kr\u00f3tszy odpowiednik dyrektyw .IF .NOT .DEF umo\u017cliwione zosta\u0142o definiowanie makr w obszarze procedury .PROC , podsumowuj\u0105c aktualnie dopuszczalne jest zdefiniowanie makra w obszarze .LOCAL .PROC wyst\u0105pienie jakiegokolwiek ostrze\u017cenia podczas asemblacji nie zmieni kodu wyj\u015bcia (exit_code=0), zmiana podyktowana potrzeb\u0105 kompatybilno\u015bci z linuxowym makefile ujednolicony spos\u00f3b deklaracji etykiet lokalnych i globalnych, \"bia\u0142e znaki\" przed nazw\u0105 etykiety nie wymusz\u0105 zdefiniowania takiej etykiety jako globalnej, umo\u017cliwi to tylko dyrektywa .DEF :LABEL poprawione makra @CALL.MAC @CALL_2.MAC , zmienna tymczasowa globalna ?@stack_offset modyfikowana jest teraz przez dyrektyw\u0119 .DEF rezygnacja z opcji -E (Eat White spaces), aktualnie jest ta opcja zawsze w\u0142\u0105czona poprawione wy\u015bwietlanie numeru linii z b\u0142\u0119dem w aktualnie wykonywanym makrze skr\u00f3cone nazwy etykiet tworzonych podczas wykonywania makr (\u0142atwiejsza ich identyfikacja w pliku *.LAB ) poprawione dzia\u0142anie opcji OPT H- dodane nowe makro rozkazy INL (increse LONG), IND (increse DWORD), DEL (decrese LONG), DED (decrese DWORD) dodane nowe makro rozkazy CPB (compare BYTE), CPW (compare WORD), CPL (compare LONG), CPD (compare DWORD) usprawnione i rozszerzone dzia\u0142anie dyrektyw #TEST #WHILE w oparciu o kod generowany przez makro rozkazy CPB CPW CPL CPD , dyrektywy #TEST #WHILE dla wyra\u017ce\u0144 =#0 <>#0 generuj\u0105 najkr\u00f3tszy kod wynikowy dodana optymalizacja d\u0142ugo\u015bci generowanego kodu dla makro rozkaz\u00f3w MWA MWX MWY dodana nowa opcja OPT R optymalizuj\u0105ca kod makro rozkaz\u00f3w MWA MWX MWY MVA MVX MVY ze wzgl\u0119du na zawarto\u015b\u0107 rejestr\u00f3w, np.: opt r- opt r+ mva #0 $80 -> lda #$00 -> lda #0 mva #0 $81 -> sta $80 -> sta $80 lda #$00 -> sta $81 sta $81 -> rozszerzona funkcjonalno\u015b\u0107 dyrektywy .DEF o mo\u017cliwo\u015b\u0107 przypisania warto\u015bci nowo deklarowanej etykiecie, np.: .def label = 1 rozszerzona funkcjonalno\u015b\u0107 dyrektywy .DEF o mo\u017cliwo\u015b\u0107 zdefiniowania etykiety globalnej niezale\u017cnie od aktulnego obszaru lokalnego, np.: .def :label umo\u017cliwiona zosta\u0142a addytywno\u015b\u0107 obszar\u00f3w .LOCAL , tzn. mo\u017ce istnie\u0107 wiele obszar\u00f3w lokalnych o tej samej nazwie, symbole zawarte w takich obszarach nale\u017ce\u0107 b\u0119d\u0105 do wsp\u00f3lnej przestrzeni nazw, np.: .local namespace .proc proc1 .endp .endl .local namespace .proc proc2 .endp .endl 1.7.8 dodane dyrektywy .MEND .PGEND .REND jako odpowiedniki .ENDM .ENDPG .ENDR obecnie deklaracja makra musi ko\u0144czy\u0107 si\u0119 dyrektyw\u0105 .ENDM lub .MEND (poprzednio dopuszczalne by\u0142o u\u017cycie dyrektywy .END ) poprawiony spos\u00f3b wykonywania makr dzi\u0119ki czemu umo\u017cliwione zosta\u0142o wykonanie dyrektywy .ENDL z poziomu wykonywanego makra poprawione zauwa\u017cone b\u0142\u0119dy dotycz\u0105ce starszych bajt\u00f3w relokowanego adresu oraz bloku aktualizacji symboli publicznych dodana nowa dyrektywa .USING .USE pozwalaj\u0105ca okre\u015bli\u0107 \u015bcie\u017ck\u0119 poszukiwa\u0144 dla nazw etykiet poprawione dzia\u0142anie dyrektyw .LOCAL .DEF , kt\u00f3rych b\u0142\u0119dne dzia\u0142anie objawia\u0142o si\u0119 w szczeg\u00f3lnych przypadkach poprawione dzia\u0142anie makro rozkaz\u00f3w skok\u00f3w ( SNE RNE itp.), kt\u00f3rych b\u0142\u0119dne dzia\u0142anie objawia\u0142o si\u0119 w szczeg\u00f3lnych przypadkach rozszerzona sk\u0142adnia dyrektywy .TEST (kod 6502 dla warunku) o dowoln\u0105 ilo\u015b\u0107 wyra\u017ce\u0144 po\u0142\u0105czonych przez .OR lub .AND (brak mo\u017cliwo\u015bci zmiany piorytetu warto\u015bciowania przy pomocy nawias\u00f3w), np.: .test .byte k>#10+1 .or .word j>#100 .and .word j<#105 .or .byte k<=#5 ... ... .endt rozszerzona sk\u0142adnia dyrektywy .WHILE (kod 6502 dla p\u0119tli) o dowoln\u0105 ilo\u015b\u0107 wyra\u017ce\u0144 po\u0142\u0105czonych przez .OR lub .AND (brak mo\u017cliwo\u015bci zmiany piorytetu warto\u015bciowania przy pomocy nawias\u00f3w), np.: .while .byte k>#4 .and .byte k<#39 ... ... .endw 1.7.6 - 1.7.7 dodany nowy prze\u0142\u0105cznik -B:ADDRESS umo\u017cliwiaj\u0105cy asemblacje od zadanego adresu dodany nowa opcja OPT F+- pozwalaj\u0105ca tworzy\u0107 bloki ci\u0105g\u0142ej pami\u0119ci (przydatne dla cart\u00f3w) dodana obs\u0142uga parametr\u00f3w typu .LONG .DWORD przekazywanych do procedur .PROC typu .VAR (poprzednio akceptowanymi typami parametr\u00f3w by\u0142 tylko .BYTE .WORD ) dodana nowa dyrektywa .FL realizuj\u0105ca zapis liczb rzeczywistych REAL w formacie FP Atari , np.: pi .fl 3.1415926535897932384626433832795 ; 40 03 14 15 92 65 tb .fl 0.5 12.34 -2.30 0.00002 tb .fl 0.5, 12.34, -2.30, 0.00002 umo\u017cliwiony zosta\u0142 zapis warto\u015bci innych typ\u00f3w ni\u017c tylko .BYTE w bloku .ARRAY dodana obs\u0142uga typ\u00f3w wielokrotnych dla .STRUCT , poprzednio takie typy by\u0142y akceptowane jednak pami\u0119\u0107 nie by\u0142a w\u0142a\u015bciwie dla nich rezerwowana, np.: .struct test x :200 .byte y :999 .long .ends buf dta test [0] poprawione b\u0142\u0119dy dotycz\u0105ce generowania kodu relokowalnego zauwa\u017cone przez Laoo , np.: .reloc lda temp temp .long $aabbcc b\u0142\u0105d Addres relocation overload wyst\u0105pi teraz tylko gdy wyra\u017cenie b\u0119dzie dotyczy\u0107 wi\u0119cej ni\u017c jednej etykiety relokowalnej, poprzednio ka\u017cde wyra\u017cenie z udzia\u0142em etykiety relokowalnej powodowa\u0142o wy\u015bwietlenie tego komunikatu b\u0142\u0119du blok aktualizacji symboli plublicznych rozszerzony zosta\u0142 o mo\u017cliwo\u015b\u0107 przekazywania sta\u0142ych r\u00f3\u017cnych typ\u00f3w B-YTE, W-ORD, L-ONG, D-WORD, poprzednio przekazywanym typem by\u0142 tylko W-ORD zmienione dzia\u0142anie dyrektywy .VAR w blokach .LOCAL znajduj\u0105cych si\u0119 w bloku .PROC , zmienne takie zawsze odk\u0142adane s\u0105 na ko\u0144cu bloku przed dyrektyw\u0105 .ENDP , w pozosta\u0142ych przypadkach na ko\u0144cu bloku .LOCAL przed dyrektyw\u0105 .ENDL umo\u017cliwiona zosta\u0142a relokowalno\u015b\u0107 kodu generowanego przez dyrektywy .WHILE .TEST poprawione dzia\u0142anie testowania warto\u015bci typu .WORD w kodzie generowanym przez dyrektywy .WHILE .TEST dodana nowa dyrektywa .ADR zwracaj\u0105ca adres etykiety przed zmian\u0105 adresu asemblacji dodana nowa dyrektywa .LEN zwracaj\u0105ca d\u0142ugo\u015b\u0107 blok\u00f3w zdefiniowanych przez .PROC .ARRAY poprawione dzia\u0142anie operacji dzielenia, mno\u017cenia i modulo, poprzednio b\u0142\u0119dnie by\u0142 interpretowany piorytet dla tych operacji komentarze z ko\u0144ca linii nie poprzedzone znakiem komentarza b\u0119d\u0105 powodowa\u0107 wyst\u0105pienie b\u0142\u0119du Unexpected end of line dodana mo\u017cliwo\u015b\u0107 przypisania zmiennej p\u00f3l zdefiniowanych przez strukture, np.: @point .struct x .byte y .byte .ends a @point b @point c @point rozszerzona sk\u0142adnia .STRUCT o mo\u017cliwo\u015b\u0107 dodania nowych p\u00f3l bez definiowania nazwy pola, np.: .struct @id id .word .ends .struct @mem @id adr .word .ends rozszerzona sk\u0142adnia makro rozkazu MWA o mo\u017cliwo\u015b\u0107 u\u017cycia adresowania po\u015bredniego strony zerowej postindeksowanego Y , np.: mwa ($80),y $a000,x mwa $bc40,y ($f0),y mwa ($80),y ($82),y rozszerzona sk\u0142adnia dyrektywy .EXTRN , obecnie mo\u017cliwe jest zapowiedzenie wi\u0119kszej ilo\u015bci etykiet r\u00f3\u017cnych typ\u00f3w w jednym wierszu, zapowiedzenie procedury .PROC w takim wierszu musi znajdowa\u0107 si\u0119 na jego ko\u0144cu, np.: .extrn a,b,c,d .byte x y z .word line .proc(.byte x,y) .reg rozszerzona sk\u0142adnia dyrektywy .VAR , obecnie mo\u017cliwe jest zadeklarowanie wi\u0119kszej ilo\u015bci etykiet r\u00f3\u017cnych typ\u00f3w w jednym wierszu oraz przypisanie im adresu od kt\u00f3rego zostan\u0105 od\u0142o\u017cone w pami\u0119ci, np.: .var x y z .byte bit :2 .dword = $80 rozszerzona sk\u0142adnia dla parametr\u00f3w procedur przekazywanych przez zmienne .VAR , mo\u017cliwe jest podanie przesuni\u0119cia np.: move .proc (.word src+1,dst+1) .var src lda $ffff dst sta $ffff .endp dodana nowa dyrektywa .NOWARN wy\u0142\u0105czaj\u0105ca wy\u015bwietlenie ostrze\u017cenia dla aktualnie asemblowanego wiersza, np.: .nowarn PROCNAME dodane nowe makro rozkazy PHR PLR realizuj\u0105ce odk\u0142adanie i zdejmowanie warto\u015bci rejestr\u00f3w z udzia\u0142em stosu sprz\u0119towego, np.: PHR -> PHA PLR -> PLA TXA TAY PHA PLA TYA TAX PHA PLA dodane nowe makro rozkazy ADB , SBB realizuj\u0105ce dodawanie i odejmowanie warto\u015bci typu .BYTE , np.: ADB $80 #12 $b000 -> lda $80 clc adc #12 sta $b000 SBB #200 $a000 -> lda #200 sec sbc $a000 sta $a000 dodana mo\u017cliwo\u015b\u0107 u\u017cycia sk\u0142adni C dla liczb szestnastkowych, np.: lda 0x2000 ldx #0x12 temp = 0x8000 1.7.5 dyrektywa .DS w blokach relokowalnych SDX RELOC i MADS RELOC deklaruje od teraz pusty blok dodany nowy prze\u0142\u0105cznik -F, kt\u00f3ry umo\u017cliwia umieszczanie rozkaz\u00f3w CPU i pseudo rozkaz\u00f3w od pierwszej kolumny w wierszu przepisane od nowa procedury odczytu blok\u00f3w .MACRO .REPT oraz procedura realizuj\u0105ca dzielenie wiersza przy pomocy znaku \\ dodane nowe pseudo rozkazy ADW , SBW realizuj\u0105ce dodawanie i odejmowanie warto\u015bci typu WORD dla 6502 , np.: adw hlp #40 ; hlp=hlp+40 adw hlp #20 pom ; pom=hlp+20 rozszerzone dzia\u0142anie dyrektywy .DEF o mo\u017cliwo\u015b\u0107 zdefiniowania etykiety, np.: .DEF label zwi\u0119kszona liczba przebieg\u00f3w dla deklaracji etykiet przez EQU dla pewnych szczeg\u00f3lnych przypadk\u00f3w 1.7.4 naprawione dzia\u0142anie dyrektywy .PRINT , dot\u0105d mog\u0142a nie wy\u015bwietli\u0107 warto\u015bci etykiet zaczynaj\u0105cej si\u0119 na liter\u0119 A B C D E F G H L T V zablokowane dzia\u0142anie dyrektywy .DS w blokach .RELOC SDX oraz naprawione jej dzia\u0142anie z instrukcj\u0105 warunkow\u0105 .IF IFT usprawnione przeszukiwanie \u015bcie\u017cek dost\u0119pu -i:path (mo\u017cna odwo\u0142ywa\u0107 si\u0119 do podkatalog\u00f3w tam zawartych) w przypadku wyst\u0105pienia b\u0142\u0119d\u00f3w podczas asemblacji wy\u015bwietlane s\u0105 one wszystkie a nie tylko pierwszy z b\u0142\u0119d\u00f3w poprawione zauwa\u017cone b\u0142\u0119dy, m.in. u\u017cycie makra w pliku .RELO C mog\u0142o spowodowa\u0107 w pewnych sytuacjach zapis b\u0142\u0119dnej informacji o relokownych adresach uproszczony zosta\u0142 spos\u00f3b ko\u0144czenia procedur wykorzystuj\u0105cych stos programowy MADS , nie ma potrzeby u\u017cywania dyrektywy .EXIT , a dyrektywa .ENDP nie powoduje ju\u017c dodatkowych dzia\u0142a\u0144 na stosie programowym dodana nowa dyrektywa .SYMBOL jako odpowiednik bloku aktualizacji BLK UPDATE NEW SYMBOL 'SYMBOL' , dyrektyw\u0119 .SYMBOL mo\u017cna u\u017cy\u0107 w dowolnym miejscu programu dodane automatyczne wywo\u0142ywanie blok\u00f3w aktualizacji ADDRESS EXTERNAL PUBLIC SYMBOL dla .RELOC i SDX dodane nowe dyrektywy .BY .WO .HE .EN .SB (zapo\u017cyczone z MAE ) dodany nowy prze\u0142\u0105cznik OPT ?- (domy\u015blnie) etykiety ze znakiem zapytania (?labels) traktowane s\u0105 jako etykiety tymczasowe, OPT ?+ etykiety ze znakiem zapytania ?labels traktowane s\u0105 jako lokalne i tymczasowe, nazw\u0105 obszaru lokalnego jest ostatnio u\u017cyta etykieta bez znaku zapytania dodane dyrektywy .LEND .PEND .AEND .WEND .TEND .SEND jako odpowiedniki dyrektyw .ENDL .ENDP .ENDW ENDW .ENDT .ENDS dodane nowe dyrektywy .GLOBAL .GLOBL jako odpowiednik (zamiennik) dyrektywy .PUBLIC dodana optymalizacja skok\u00f3w warunkowych JEQ JNE JPL JMI JCC JCS JVC JVS je\u015bli jest taka mo\u017cliwo\u015b\u0107 wybierany jest skok kr\u00f3tki typu BEQ BNE BPL BMI BCC BCS BVC BVS dodany nowy domy\u015blny separator znak spacji dla przekazywanych parametr\u00f3w do .PROC .MACRO dot\u0105d by\u0142 to tylko znak przecinka usprawnienia dotycz\u0105ce przekazywania parametr\u00f3w do makr i procedur, np. paramatrem makra mo\u017ce by\u0107 dyrektywa zwracaj\u0105ca warto\u015b\u0107 wyra\u017cenia lub symbol licznika p\u0119tli # :12 makro # dodana mo\u017cliwo\u015b\u0107 u\u017cycia znaku spacji jako separatora dla .VAR .EXTRN np. .EXTRN a b c d .word .VAR i = 1 j = 2 .byte .VAR a b c d .byte rozszerzona sk\u0142adnia dla .VAR umo\u017cliwiaj\u0105ca zaincjowanie zmiennych sta\u0142\u0105, np.: .var i = 10 j = 12 .byte .var a , b = 2 .byte dodane nowe dyrektywy .WHILE .ENDW pozwalaj\u0105ce na automatyczne wygenerowanie kodu dla p\u0119tli WHILE , np.: ldx #$ff .while .word adr < #$bc40+40*24 stx $bc40 adr: equ *-2 inw adr .endw dodane nowe dyrektywy .TEST .ENDT pozwalaj\u0105ce na automatyczne wygenerowanie kodu dla warunku, np.: .test .byte (@>=#'a') .test .byte (@<=#'z') .endt .endt 1.7.3 dodana mo\u017cliwo\u015b\u0107 zmiany adresu asemblacji .PROC lub .LOCAL bez zmiany adresu \u0142adowania usuni\u0119to optymalizacj\u0119 kodu dla makro rozkaz\u00f3w MWA itp., kt\u00f3ra mog\u0142a powodowa\u0107 w szczeg\u00f3lnych przypadkach zap\u0119tlenie si\u0119 MADS dodane dyrektywy .REG .VAR pozwalaj\u0105ce okre\u015bli\u0107 spos\u00f3b przekazywania parametr\u00f3w do procedur ( .REG przez rejestry CPU , .VAR przez zmienne) dodana dyrektywa .VAR pozwalaj\u0105ca na deklaracj\u0119 zmiennych w blokach .PROC .LOCAL , zadeklarowane zmiennne s\u0105 fizycznie odk\u0142adane na ko\u0144cu takiego bloku rozszerzona sk\u0142adnia dla dyrektywy .EXTRN , np. EXTRN label1,label2,label3... TYPE jesli brak deklaracji etykiet dla stosu programowego MADS , przyjmowane s\u0105 domy\u015blne warto\u015bci @PROC_VARS_ADR=$0500 @STACK_ADDRESS=$0600 @STACK_POINTER=$FE dodany repeat_counter # , kt\u00f3ry mo\u017cna u\u017cywa\u0107 zamiennie z dyrektyw\u0105 .R wystapi b\u0142\u0105d ^ not relocatable przy pr\u00f3bie relokacji rozkazu lda ^label dodana obs\u0142uga symboli publicznych dla sta\u0142ych CONSTANT w blokach PUBLIC poprawiona relokowalnosc dla tablic .ARRAY , danych stworzonych przez .STRUCT , parametr\u00f3w przekazywanych do procedur przez sta\u0142a # 1.7.2 przepisana na nowo obs\u0142uga pseudo rozkaz\u00f3w REQ RNE RPL RMI RCC RCS RVC RVS SEQ SNE SPL SMI SCC SCS SVC SVS poprawione dzia\u0142anie dyrektywy .LINK dla blok\u00f3w o sta\u0142ych adresach poprawione testowanie s\u0142\u00f3w zarezerwowanych (mo\u017cna u\u017cywa\u0107 nazw zarezerwowanych dla WDC 65816 gdy u\u017cywamy tylko 6502 ) zmiany w listingu, wy\u015bwietla informacje o numerze banku tylko gdy bank > 0 dodana obs\u0142uga makro rozkaz\u00f3w MWA MWX MWY MVA MVX MVY ADD SUB INW DEW (do ich obs\u0142ugi nie s\u0105 ju\u017c potrzebne makra) 1.7.1 dodana mo\u017cliwo\u015b\u0107 u\u017cywania nazw mnemonik\u00f3w WDC 65816 w trybie pracy 6502 , w trybie WDC 65816 wyst\u0105pi ju\u017c b\u0142\u0105d Reserved word poprawione dzia\u0142anie pseudo rozkaz\u00f3w skok\u00f3w SCC RNE itp. w makrach usprawnione wykonywanie wielu makr rozdzielonych znakiem dwukropka : 1.7.0 usuni\u0119ty b\u0142\u0105d, kt\u00f3ry powodowa\u0142 zbyt ma\u0142a liczb\u0119 przebieg\u00f3w asemblacji dodana obs\u0142uga pseudo rozkaz\u00f3w JEQ JNE JPL JMI JCC JCS JVC JVS (makra nie s\u0105 ju\u017c potrzebne do ich obs\u0142ugi) 1.6.9 rozszerzona sk\u0142adnia dla .ARRAY .PUT dodany pseudo rozkaz EXT pozwalaj\u0105cy na deklaracje etykiety external dodane makra JEQ JNE JPL JMI JCC JCS dodane dyrektywy .PAGES .ENDPG dodana dyrektywa .END zastepujaca inne dyrektywy .END? prze\u0142\u0105cznik -H zast\u0105piony zosta\u0142 przez -HC (generuje plik nag\u0142\u00f3wkowy dla CC65 ) dodany nowy prze\u0142\u0105cznik -HM generuj\u0105cy plik nag\u0142\u00f3wkowy dla MADS z sortowaniem na etykiety typu CONSTANTS VARIABLES PROCEDURES dodana nowa dyrektywa .RELOC generuj\u0105ca kod relokowalny w formacie MADS 1.6.8 dodana nowa dyrektywa .PUT oraz rozszerzona sk\u0142adnia dla dyrektywy .GET (../EXAMPLES/MSX/MPT_PLAYER/MPT_RELOCATOR.MAC , ../EXAMPLES/MSX/TMC_PLAYER/TMC_RELOCATOR.MAC) dodana obs\u0142uga pseudo rozkaz\u00f3w XASM REQ RNE RPL RMI RCC RCS RVC RVS SEQ SNE SPL SMI SCC SCS SVC SVS dodana mo\u017cliwo\u015b\u0107 \u0142\u0105czenia dowolnej liczby znanych MADS mnemonik\u00f3w przy pomocy znaku : (styl XASM ), np.: lda:cmp:req 20 ldx:ldy:lda:iny label 1.6.6 - 1.6.7 \u017ar\u00f3d\u0142o MADS kompatybilne z Free Pascal Compiler , po kompilacji mo\u017cliwe jest jego u\u017cywanie na innych platformach systemowych, jak np. Linux , Mac OS , OS/2 itp. od teraz MADS sam dobiera odpowiedni\u0105 liczb\u0119 przebieg\u00f3w asemblacji, prze\u0142\u0105cznik /3 nie jest ju\u017c potrzebny poprawiony i rozbudowany zosta\u0142 mechanizm przekazywania parametr\u00f3w do MADS (rozdzia\u0142 Prze\u0142\u0105czniki assemblera ) poprawione zosta\u0142o wywo\u0142anie makra w linii rozdzielanej znakiem \\ oraz usprawnione rozpoznawanie i wykonywanie linii rozdzielanych znakami \\ poprawiony b\u0142\u0105d, w kt\u00f3rym MADS myli\u0142 dyrektyw\u0119 .ENDM z pseudorozkazem IFT poprawione dzia\u0142anie instrukcji warunkowych .ELSEIF .ELSE poprawione testowanie poprawno\u015bci instrukcji warunkowych w makrach obs\u0142uga procedur .PROC zosta\u0142a rozbudowana o nowe makra i mechanizmy, dzi\u0119ki kt\u00f3rym podobna jest w dzia\u0142aniu jak i \u0142atwo\u015bci u\u017cycia do procedur z j\u0119zyk\u00f3w wy\u017cszego poziomu dla procedur .PROC z zadeklarowanymi parametrami potrzebna jest teraz dodatkowa deklaracja @PROC_VARS_ADR brak ogranicze\u0144 w liczbie parametr\u00f3w przekazywanych do procedur, jedynym ograniczeniem jest dost\u0119pna pami\u0119\u0107 dodany nowy prze\u0142\u0105cznik /d:label=value pozwalaj\u0105cy zdefiniowa\u0107 now\u0105 etykiet\u0119 MADS z poziomu linii polece\u0144 dodany nowy prze\u0142\u0105cznik /x Exclude unreferenced procedures pozwalaj\u0105cy pomin\u0105\u0107 podczas asemblacji nie u\u017cywane w programie procedury zadeklarowane dyrektyw\u0105 .PROC nowa opcja OPT T+ (track sep, rep) \u015bledz\u0105ca zmiany rozmiaru rejestr\u00f3w A X Y dokonywane przez rozkazy SEP , REP WDC 65816 nowe biblioteki w katalogu ..\\EXAMPLES\\LIBRARIES w deklaracji obszaru lokalnego .LOCAL nie jest wymagane podanie nazwy obszaru nowe operatory -= += ++ -- pozwalaj\u0105ce zmniejszy\u0107/zwi\u0119kszy\u0107 warto\u015b\u0107 etykiety tymczasowej, np.: ?label -- -> ?label=?label-1 ?lab ++ -> ?lab=?lab+1 ?temp += 3 -> ?temp=?temp+3 ?ofset -= 5 -> ?ofset=?ofset-5 rozszerzona o znak przecinka sk\u0142adnia deklaracji parametr\u00f3w procedur, np.: .proc nazwa (.byte a,b,c .word d,e) .endp","title":"Mad-Assembler"},{"location":"#mad-assembler","text":"Mad-Assembler (MADS) jest cross-assemblerem MOS 6502/MOS 65C02/WDC 65816 autorstwa Tomazs Biela (tebe) . Najnowsze wydania dla systemu Windows s\u0105 dost\u0119pne na Github . Wydania dla innych platform system\u00f3w operacyjnych s\u0105 publikowane cyklicznie w ramach WUDSN IDE Tools .","title":"Mad-Assembler"},{"location":"#historia-zmian","text":"","title":"Historia Zmian"},{"location":"#215","text":"poprawione dzia\u0142anie .UNDEF , .IFDEF poprawione wykonywanie zagnie\u017cd\u017conych p\u0119tli .REPT dodana mo\u017cliwo\u015b\u0107 \u0142\u0105czenia obszar\u00f3w lokalnych, .LOCAL +full_path_to_local dodanie kolorowania komunikat\u00f3w konsoli etykiety automodyfikacji kodu, np. lda label: #$40","title":"2.1.5"},{"location":"#213","text":"nowa dyrektywa .RND zwracaj\u0105ca warto\u015b\u0107 losow\u0105 z zakresu 0..255 dodany komunikat ostrze\u017cenia 'Register A is changed' dla pseudo rozkaz\u00f3w DEW , DEL , DED nowy prze\u0142\u0105cznik -bc 'Branch condition test' , powoduje wygenerowanie komunikat\u00f3w ostrze\u017cenia w przypadku kiedy skok jest poza zakres lub przekracza stron\u0119 pami\u0119ci","title":"2.1.3"},{"location":"#210","text":"dodany komunikat ostrze\u017cenia 'Buggy indirect jump' w przypadku u\u017cycia rozkazu JMP(ABS) dodana dyrektywa .FILEEXISTS('filename') zwracajaca 1 gdy plik w podanej \u015bcie\u017cce istnije, 0 gdy nie istnieje rozszerzony komunikat Value out of range (VALUE must be between X and Y)","title":"2.1.0"},{"location":"#209","text":".CBM 'text' konwersja na znaki ekranowe Commodore C64 usuni\u0119ty b\u0142\u0105d kiedy procedura .PROC znajduj\u0105ca si\u0119 w bloku .LOCAL nie zosta\u0142a oznaczona jako 'do asemblacji' mimo tego \u017ce by\u0142o do niej odwo\u0142anie z poziomu makra .MACRO w bloku .LOCAL usuni\u0119ty b\u0142\u0105d, etykiety tymczasowe ?label by\u0142y oznaczane 'do relokacji'","title":"2.0.9"},{"location":"#208","text":"kr\u00f3tszy kod dla #CYCLE poprawki dla .BY .WO .HE .SB .CB .FL dodano komunikat b\u0142\u0119du 'Improper syntax' w przypadku u\u017cycia .BY .WO .HE .SB .CB .FL w bloku .STRUCT dodane dyrektywy dla WDC 65816 .LONGA ON|OFF .LONGI ON|OFF poprawione dzia\u0142anie \u015bledzenia rozmiaru rejestr\u00f3w WDC 65816 gdy OPT T+ added command line option -fv:value to set the memory fill value when OPT F+ . dodany prze\u0142\u0105cznik -fv:value pozwalaj\u0105cy ustali\u0107 warto\u015b\u0107 wype\u0142nienia pami\u0119ci gdy OPT F+ dodana mo\u017cliwo\u015b\u0107 podania argumentu jako ci\u0105gu dw\u00f3ch znak\u00f3w (poprzednio tylko 1 znak) np. lda #'AB' , mwa #'XY' $80","title":"2.0.8"},{"location":"#207","text":"poprawione generowanie kodu wynikowego dla nielegali DOP i SHA dodane dyrektywy WDC 65816 .A8 .A16 .I8 .I16 .AI8 .IA8 .AI16 .IA16 pozwalaj\u0105ce ustawi\u0107 rozmiar rejestr\u00f3w AXY dodane dyrektywy WDC 65816 .ASIZE .ISIZE zwracaj\u0105ce aktualnie ustawiony rozmiar rejestr\u00f3w AXY rozkaz JMP zmieniany jest na JML WDC 65816 tylko gdy skok dotyczy innego 64KB banku ni\u017c obecny dodany prze\u0142\u0105cznik -ml:value (margin-left property), kt\u00f3ry umo\u017cliwia zmian\u0119 lewego marginesu generowanego listingu w zakresie od 32 do 128 znak\u00f3w","title":"2.0.7"},{"location":"#206","text":"poprawione parsowanie parametr\u00f3w makra zapisanych przy pomocy etykiet .macro test currentRow, previousRow .print Tmp%%currentRowAllowed .print Tmp%%previousRowAllowed .endm poprawione alokowanie danych .ARRAY gdy nie ma okre\u015blonego rozmiaru, lub jest to tablica inna ni\u017c jednowymiarowa zwi\u0119kszona liczba przebieg\u00f3w dla .PROC , w pewnych warunkach dla parametru xa .reg parametr by\u0142 \u017ale interpretowany dodana dyrektywa .DEFINE pozwalaj\u0105ca definiowa\u0107 jedno liniowe makra (mo\u017cna definiowa\u0107 wielokrotnie w tym samym przebiegu) .DEFINE macro_name expression .DEFINE write .print %%1+%%2 write (5,12) .DEFINE text .sb text 'atari' dodana dyrektywa .UNDEF macro_name , usuwa definicj\u0119 jedno liniowego makra macro_name","title":"2.0.6"},{"location":"#205","text":"tablice .ARRAY w bloku .PROC s\u0105 pomijane je\u015bli u\u017cyto prze\u0142\u0105cznik -x Exclude unreferenced procedures u\u017cycie .ARRAY w bloku .STRUCT nie b\u0119dzie generowa\u0107 ju\u017c zer w pliku wynikowym nowa dyrektywa .XGET , pozwalaj\u0105ca wczyta\u0107 do bufora pami\u0119ci MADS plik i dodatkowo zmodyfikowa\u0107 jego bajty pod warunkiem \u017ce s\u0105 r\u00f3\u017cne od zera (przydatne dla VBXE )","title":"2.0.5"},{"location":"#204","text":"usuni\u0119ty b\u0142\u0105d powoduj\u0105cy b\u0142\u0119dny zapis bloku aktualizacji dla starszego bajtu adresu w bloku .RELOC .DB .DW usuni\u0119te .DBYTE (MSB/LSB) odk\u0142ada s\u0142owo w odwrotnej kolejno\u015bci (starszy/m\u0142odszy) dodane dyrektywy .WGET WORD , .LGET LONG , .DGET DWORD poprawione dzia\u0142anie makro rozkazk\u00f3w ADW i SBW , np.: adw (tmp),y #1 posx adw (tmp),y ptr2 ptr4","title":"2.0.4"},{"location":"#202","text":"poprawione alokowanie danych dla .SB [+<byte>],<bytes|string|char>","title":"2.0.2"},{"location":"#201","text":"poprawione alokowanie danych dla .ARRAY gdy typ wi\u0119kszy od .BYTE .SIZEOF zwraca rozmiar dla wbudowanych typ\u00f3w .BYTE .WORD .LONG .DWORD dodana relokowalna wersja playera MPT examples\\players\\mpt_player_reloc.asm poprawione dzia\u0142anie dyrektywy .DS w blokach SDX blk sparta $xxx kt\u00f3re nie s\u0105 relokowalne","title":"2.0.1"},{"location":"#198","text":"naprawione dzia\u0142anie rozkaz\u00f3w WDC 65816 PEA PEI PER dodana mo\u017cliwo\u015b\u0107 podania kodu dla .RELOC [.BYTE|WORD] [TYPE]","title":"1.9.8"},{"location":"#197","text":"dyrektywa .DEF definiuje etykiety o zasiegu lokalnym, je\u015bli poprzedzi\u0107 j\u0105 znakiem : to globalne poprawki dla liczb zmiennoprzecinkowych .FL, poprawione kodowane zera, dokonywane zaokr\u0105glenie do 10 miejsc po przecinku dla blok\u00f3w Sparta DOS X blk reloc i blk empty dodana mo\u017cliwo\u015b\u0107 okre\u015blenia innego typu pami\u0119ci ni\u017c $00 (main), $02 (extended), np.: blk reloc $40 poprawka umo\u017cliwiaj\u0105ca u\u017cycie dyrektywy .PRINT po blk empty dodana mo\u017cliwo\u015b\u0107 definiowania wielowymiarowych tablic .ARRAY , np.: .array scr [24][40] [11][16] = \"atari\" .enda mva #\"!\" scr[11][22] dodana mo\u017cliwo\u015b\u0107 definiowania tablicy .ARRAY poprzez dyrektyw\u0119 .DS , np.: tmp .ds .array [5][12][4] .word dodana mo\u017cliwo\u015b\u0107 definiowania tablicy .ARRAY poprzez pseudorozkaz EQU (=), np.: fnt = $e000 .array [128] [8] .byte naprawione dzia\u0142anie makrorozkazu ADW w po\u0142\u0105czeniu z makrorozkazem SCC itp. poprawki dla .REPT , m.in. komentarz wieloliniowy /* */ jest teraz w\u0142a\u015bciwie rozpoznawany","title":"1.9.7"},{"location":"#196","text":"poprawione dzia\u0142anie etykiet anonimowych dla mnemonik\u00f3w \u0142\u0105czonych znakiem : , np.: ldx #8 @ lda:cmp:req 20 dex bne @- dodany pseudo rozkaz COS (centre,amp,size[,first,last]) generuj\u0105cy warto\u015bci dla funkcji cosinus dodany komunikat b\u0142\u0119du Improper syntax w przypadku u\u017cycia dyrektywy .DS w bloku .STRUCT naprawione dzia\u0142anie pseudo rozkazu ORG , np.: opt h- ORG [a($ffff),d'atari',c'ble',20,30,40],$8000,$a000 addytywne bloki .LOCAL otrzymuj\u0105 kolejne adresy, poprzednio adres ustalany by\u0142 na podstawie pierwszego wyst\u0105pienia takiego bloku dodany komunikat ostrze\u017cenia w przypadku stworzenia kolejnego addytywnego bloku .LOCAL o tej samej nazwie Ambiguous label LOCAL_NAME dodane mnemoniki PER (PEA rell), PEI (PEA (zp)) dla WDC 65816 dodane nowy typ danych M (najstarszy bajt LONG ) i G (najstarszy bajt DWORD ) dla pseudorozkazu DTA , np.: dta m($44556677) ; -> $55 dta g($44556677) ; -> $44 dyrektywa .LEN .SIZEOF rozszerzona o obs\u0142ug\u0119 danych alokowanych poprzez DTA STRUCT_NAME , np.: .STRUCT free_ptr_struct prev .WORD next .word .ENDS free_ptr_t dta free_ptr_struct [3] .print .sizeof(free_ptr_t) ; free_ptr_struct [0..3] = 16 bytes zmiany dla operacji odczytu plik\u00f3w poprzez ICL , INS itp. plik do odczytu/zapisu b\u0119dzie poszukiwany najpierw w \u015bcie\u017cce, kt\u00f3ra prowadzi do obecnie otwartego pliku, nast\u0119pnie ze \u015bcie\u017cki z kt\u00f3rej zosta\u0142 uruchomiony g\u0142\u00f3wny asemblowany plik i na ko\u0144cu ze \u015bcie\u017cek podanych parametrem -i (additional include directories) poprawione rozpoznawanie wielko\u015bci znak\u00f3w gdy aktywowany jest prze\u0142\u0105cznik -c (char sensitive) dla struktur, np.: .struct fcb sEcbuf .byte .ends data dta fcb [1] (0) lda data[0].sEcbuf rozszerzone dzia\u0142anie dyrektywy .REPT o mo\u017cliwo\u015b\u0107 jej zagnie\u017cd\u017cania np.: .rept 2,#*2 ; 1 - $0000 ; 2 - $0000 .print '1 - ',# ; 1 - $0001 ; 2 - $0000 .rept :1 ; 2 - $0001 .print '2 - ',.r ; 2 - $0002 .endr ; ; .endr kr\u00f3tsza wersja p\u0119tli #WHILE bez wyra\u017cenia, p\u0119tla trwa dop\u00f3ki LABEL <> 0 #while .word label #end","title":"1.9.6"},{"location":"#195","text":"dodany pseudorozkaz SET pozwalaj\u0105cy redefiniowa\u0107 etykiet\u0119, podobne dzia\u0142anie jak etykiety tymczasowe zaczynaj\u0105ce si\u0119 znakiem ? , np.: temp set 12 lda #temp temp set 23 lda #temp dodana mo\u017cliwo\u015b\u0107 wymuszenia trybu adresowania w stylu XASM a: i z: , np.: XASM MADS lda a:0 lda.a 0 ldx z:0 lda.z 0 dodana mo\u017cliwo\u015b\u0107 okre\u015blenia nowego adresu relokacji kodu w stylu XASM r: , np.: XASM MADS org r:$40 org $40,* poprawione dzia\u0142anie parametru -x Exclude unreferenced procedures , zmienne .VAR nie s\u0105 alokowane gdy procedura jest nieu\u017cywana rozszerzona sk\u0142adnia dla jednoliniowych p\u0119tli :rept , mo\u017cliwe wykorzystanie licznika p\u0119tli jako parametru :1 lub %%1 , np.: line0 line1 line2 line3 ladr1 :4 dta l(line:1) hadr1 :4 dta h(line:1) ladr2 :4 dta l(line%%1) hadr2 :4 dta h(line%%1) dodany komunikat ostrze\u017cenia w przypadku u\u017cycia nielegalnych niestabilnych rozkaz\u00f3w 6502 , np. CIM dodany komunikat ostrze\u017cenia w przypadku u\u017cycia nielegalnych niestabilnych rozkaz\u00f3w 6502 , np. CIM dodana nowa funkcjonalno\u015b\u0107 dla pseudorozkaz\u00f3w RUN i INI , kt\u00f3re teraz zachowuj\u0105 adres asemblacji, poprzednio przestawia\u0142y adres asemblacji na $2E0 (RUN), $2E2 (INI) dodana obs\u0142uga etykiet anonimowych anonymous labels @ @+[1..9] (forward) @-[1..9] (backward), w celu zapewnienia przejrzysto\u015bci kodu ograniczone jest u\u017cywania takich etykiet tylko dla skok\u00f3w warunkowych oraz do 10 wyst\u0105pie\u0144 w prz\u00f3d/ty\u0142, np.: @ dex <------+---+ bne @+ --+ | | stx $80 | | | @ lda #0 <-+ | | bne @- ------+ | bne @-1 --------+ rozszerzone dzia\u0142anie dyrektyw #IF i #WHILE o zmienne deklarowane przez .VAR , dotychczas wymagane by\u0142o podanie typu zmiennej, np.: .var temp .word #if temp>#2100 ;Now #end #if .word temp>#2100 ;Before #end","title":"1.9.5"},{"location":"#194","text":"dodana normalizacja \u015bcie\u017cek dla plik\u00f3w, tak aby dzia\u0142a\u0142y pod Unixami , znaki \\ zamieniane s\u0105 na / poprawione przekazywanie dyrektyw jako parametr\u00f3w do procedur i makr, dyrektywy nie by\u0142y rozpoznawane przy w\u0142\u0105czonym prze\u0142\u0105czniku -c (case sensitive) poprawione dzia\u0142anie .USE .USING dodana informacja w postaci ostrze\u017cenia WARNING o etykiecie powoduj\u0105cej niesko\u0144czon\u0105 ilo\u015b\u0107 przebieg\u00f3w asemblacji INFINITE LOOP dodany zapis dw\u00f3ch bajt\u00f3w nag\u0142\u00f3wka FF FF dla pliku zawieraj\u0105cego blok o adresie \u0142adowania $FFFF komentarze po mnemonikach nie wymagaj\u0105cych argumentu zostan\u0105 potraktowane jako b\u0142\u0105d, wyj\u0105tkiem jest \u0142\u0105czenie rozkaz\u00f3w w stylu xasm poprzez znak : , np.: pla $00 -> ERROR: Extra characters on line pha:pla $00 -> OK rozszerzona sk\u0142adnia makr o mo\u017cliwo\u015b\u0107 u\u017cywania parametr\u00f3w w postaci nazw a nie tylko warto\u015bci numerycznych-decymalnych, np.: .macro SetColor val,reg lda :val sta :reg .endm .macro SetColor2 (arg1, arg2) lda #:arg1 sta :arg2 .endm naprawione definiowanie etykiet dla n/w sytuacji, pierwsza etykieta nie zostanie zignorowana temp label = 100","title":"1.9.4"},{"location":"#193","text":"poprawione przetwarzanie blok\u00f3w .PROC , kt\u00f3re w pewnych okoliczno\u015bciach mog\u0142y zosta\u0107 pomini\u0119te podczas asemblacji poprawiony zapis BLK EMPTY dla plik\u00f3w SDX je\u015bli zastosowali\u015bmy deklaracj\u0119 takiego bloku przez .DS poprawki dotycz\u0105ce testowania ko\u0144ca linii dodane dyrektywy .FILESIZE , .SIZEOF jako odpowiednik dotychczasowej dyrektywy .LEN rozszerzona sk\u0142adnia dla p\u00f3l struktury .STRUCT , np.: .struct name .byte label0 .byte :5 label1 label2 .byte label3 :2 .word .ends","title":"1.9.3"},{"location":"#192","text":"mo\u017cliwo\u015b\u0107 okre\u015blenia adresu dla .ZPVAR = $XX usprawnione odwo\u0142ania do etykiet wyliczeniowych .ENUM , np. enum_label(field0, field1) dodana mo\u017cliwo\u015b\u0107 generowania bloku dla symboli zewn\u0119trznych BLK UPDATE EXTRN dla plik\u00f3w DOS-a , poprzednio tylko dla plik\u00f3w .RELOC , np.: .extrn vbase .word org $2000 lda #$80 sta vbase+$5d blk update extrn dodany komunikat b\u0142\u0119du Could not use NAME in this context w przypadku rozkaz\u00f3w odwo\u0142a\u0144 do blok\u00f3w .MACRO .ENUM .STRUCT poprawiony b\u0142\u0105d kt\u00f3ry uniemo\u017cliwia\u0142 u\u017cycie EQU w nazwie etykiety dodana dyrektywa .CB +byte,..... , ostatni bajt ci\u0105gu znakowego zapisywany jest w inwersie dodana obs\u0142uga segment\u00f3w poprzez dyrektywy .SEGDEF .SEGMENT .ENDSEG dodana nowa dyrektywa #CYCLE #N generuj\u0105ca kod 6502 o zadanej liczbie cykli N dodana obs\u0142uga nielegalnych rozkaz\u00f3w 6502 , przyk\u0142ad w pliku .\\examples\\test6502_illegal.asm uaktualnione pliki konfiguracyjne dla Notepad++ ..\\syntax\\Notepad++ poprawiony zapis pliku LST naprawiona alokacja pami\u0119ci dla zmiennych strukturalnych, rozszerzona sk\u0142adnia dla .STRUCT .struct LABEL x,y,z .word // wiele zmiennych tego samego typu w jednej linii .byte a,b .ends .enum type a=1,b=2 .ende .struct label2 x type type y .ends","title":"1.9.2"},{"location":"#190","text":"naprawiony zapis linii z komentarzem /* */ do pliku listingu *.LST , poprzednio takie linie nie by\u0142y zapisywane poprawka dla etykiet deklarowanych z linii komend -d:label , poprzednio takie etykiety widziane by\u0142y tylko w pierwszym przebiegu w przypadku addytywno\u015bci blok\u00f3w .LOCAL tylko pierwszy adres z takich blok\u00f3w jest zapisywany poprawki dotycz\u0105ce parsowania makr, poprzednio etykiety zaczynaj\u0105ce si\u0119 od END mog\u0142y zosta\u0107 zinterpretowane jako pseudo rozkaz END poprawka odczytu dla pustego pliku relokowalnego, poprzednio wyst\u0119powa\u0142 b\u0142\u0105d Value out of range poprawki dla .USING .USE","title":"1.9.0"},{"location":"#188-189","text":"uaktualniony silnik duch\u00f3w programowych ..\\EXAMPLES\\SPRITES\\CHARS o duchy 8x24 w przypadku braku podania rozszerzenia pliku i braku istnienia takiego pliku dla ICL 'filename' zostanie domy\u015blnie przyj\u0119te rozszerzenie *.ASM ICL 'filename.asm' poprawione dzia\u0142anie komentarzy /* */ w blokach .MACRO .REPT usuni\u0119ty b\u0142\u0105d uniemo\u017cliwiaj\u0105cy poprawn\u0105 asemblacj\u0119 bloku #IF #WHILE dla wyra\u017ce\u0144 \u0142\u0105czonych przez .OR .AND prze\u0142\u0105czniki w linii komend mog\u0105 by\u0107 poprzedzone tylko znakiem - , poprzednio tak\u017ce / jednak by\u0142y problemy z dzia\u0142aniem tego znaku na MacOSX poprawiony zakres dzia\u0142ania dyrektywy .USING , dla aktualnej przestrzeni nazw i kolejnych zawieraj\u0105cych si\u0119 w tej przestrzeni nazw","title":"1.8.8 - 1.8.9"},{"location":"#186-187","text":"usprawnione rozpoznawanie komentarzy /* */ w wyra\u017ceniach domy\u015blny adres dla .ZPVAR ustawiony na $0080 , poprzednio $0000 dodana nowa dyrektywa .ELIF jako kr\u00f3tszy odpowiednik dyrektywy .ELSEIF rozszerzone dzia\u0142anie dyrektywy .LEN o mo\u017cliwo\u015b\u0107 podania jako parametru nazwy pliku, zwracana jest w\u00f3wczas d\u0142ugo\u015b\u0107 takiego pliku usprawnione dzia\u0142anie dyrektywy .DEF w wyra\u017ceniach warunku .IF .IFDEF IFNDEF","title":"1.8.6 - 1.8.7"},{"location":"#185","text":"dodane makro relokuj\u0105ce modu\u0142y RMT ...\\EXAMPLES\\MSX\\RMT_PLAYER_RELOCATOR\\ dodany test sk\u0142adni dla nie asemblowanych procedur .PROC gdy aktywny jest prze\u0142\u0105cznik -x Exclude unreferenced procedures poprawione dzia\u0142anie prze\u0142\u0105cznika -d:label[=value] , podanie warto\u015bci dla etykiety jest teraz opcjonalne, domy\u015blnie mads przypisze warto\u015b\u0107 1 dyrektywy .DS .ALIGN nie spowoduj\u0105 alokacji zmiennych zdefiniowanych przez .VAR alokacja zmiennych .VAR przed nowym blokiem ORG nie nast\u0105pi je\u015bli blok ORG znajduje si\u0119 w bloku .LOCAL lub .PROC poprawione \u0142amanie wierszy znakiem \\ w ci\u0105gach ograniczonych nawiasami () usuni\u0119ty b\u0142\u0105d powoduj\u0105cy relokowanie adresu dla wyra\u017cenia dyrektywy .ERROR ERT usuni\u0119te zauwa\u017cone b\u0142\u0119dy przy parsowaniu parametr\u00f3w linii komend usuni\u0119te zauwa\u017cone b\u0142\u0119dy dotycz\u0105ce optymalizacji d\u0142ugo\u015bci kodu makro rozkaz\u00f3w MVA MWA itp. poprawiony kod realizuj\u0105cy zagnie\u017cd\u017canie blok\u00f3w .PROC poprawiony kod realizuj\u0105cy dzia\u0142anie pseudo rozkaz\u00f3w warunku IFT ELI ELS EIF dodany komunikat '#' is allowed only in repeated lines dla przypadk\u00f3w u\u017cycia licznika p\u0119tli # (.R) poza p\u0119tl\u0105 usuni\u0119ty b\u0142\u0105d powoduj\u0105cy b\u0142\u0119dne alokowanie zmiennych zadeklarowanych przez dyrektyw\u0119 .VAR podczas wykonywania makra w celu ujednolicenia sk\u0142adni odwo\u0142ania do etykiet typ\u00f3w wyliczeniowych mo\u017cliwe s\u0105 tylko poprzez znak kropki . , poprzednio tak\u017ce przez :: mo\u017cliwe kr\u00f3tsze odwo\u0142ania do typ\u00f3w wyliczeniowych enum_label(fields) , np. : .enum typ val0 = 1 val1 = 5 val2 = 9 .ende lda #typ(val0|val2) ; == \"lda #typ.val0|typ.val2\" rozszerzona sk\u0142adnia dyrektywy .SAV , np.: .sav 'filename',offset,length .sav 'filenema',length .sav [offset] 'filename',offset2,length .sav length .sav offset,length rozszerzona sk\u0142adnia dyrektywy .ARRAY , w przypadku braku podania maksymalnego indeksu tablicy zostanie on obliczony na podstawie ilo\u015bci wprowadzonych element\u00f3w, elementy mo\u017cna wprowadza\u0107 bez konieczno\u015bci poprzedzenia ich indeksem [expression], np.: .array temp .byte 1,4,6 ; [0..2] = 1,4,6 [12] = 9,3 ; [12..13] = 9,3 [5]:[8] = 10,16 ; [5..6] = 10,16 ; [8..9] = 10,16 0,0,\\ ; [14..17] = 0,0,1,1 1,1 .enda ; 18 element\u00f3w, TEMP [0..17] dodana mo\u017cliwo\u015b\u0107 alokacji zmiennej typu strukturalnego przy pomocy dyrektyw .VAR .ZPVAR , np.: .struct Point x .byte y .byte .ends .var a,b,c Point .zpvar Point f,g,i dodana mo\u017cliwo\u015b\u0107 alokacji zmiennej typu wyliczeniowego przy pomocy dyrektyw .VAR .ZPVAR , np.: .enum Boolean false = 0 true = 1 .ende .var test Boolean .zpvar Boolean test dodana mo\u017cliwo\u015b\u0107 deklaracji p\u00f3l struktury przy pomocy typ\u00f3w wyliczeniowych, np.: .enum EState DONE, DIRECTORY_SEARCH, INIT_LOADING, LOADING .ende .struct SLoader m_file_start .word m_file_length .word m_state EState .ends","title":"1.8.5"},{"location":"#183-184","text":"nowy silnik duch\u00f3w programowych z minimalnymi wymaganiami pami\u0119ci, bez dodatkowych bufor\u00f3w pami\u0119ci obrazu ...EXAMPLES\\SPRITES\\CHARS_NG nowa wersja pakera Huffmana (kompatybilna z Free Pascal Compiler-em , fpc -MDelphi sqz15.pas ) i dekompresora Huffmana SQZ15 ...EXAMPLES\\COMPRESSION\\SQUASH poprawiony kod generowany dla rozkaz\u00f3w MVP MVN PEA BRA for WDC 65816 dodane nowe rozkazy BRL JSL JML WDC 65816 , jako odpowiedniki rozkaz\u00f3w d\u0142ugich skok\u00f3w BRA JSR JMP blok aktualizacji etykiet zewn\u0119trznych (external) zosta\u0142 rozszerzony o zapis m\u0142odszego i starszego bajtu adresu takiej etykiety poprawione dzia\u0142anie dyrektywy .USE .USING , dzia\u0142a niezale\u017cnie od przestrzeni nazw w kt\u00f3rej zostanie u\u017cyta usuni\u0119ty b\u0142\u0105d, kt\u00f3ry powodowa\u0142 w pewnych sytuacjach pomijanie asemblacji bloku #IF #WHILE dodana mo\u017cliwo\u015b\u0107 definiowania zmiennych poprzez dyrektyw\u0119 .DS lub pseudo rozkaz ORG przed blokiem .RELOC dodana dodatkowa forma sk\u0142adni dla dyrektywy .VAR , z tym \u017ce dla takiego przypadku nie ma mo\u017cliwo\u015bci okre\u015blenia adresu umiejscowienia zmiennych w pami\u0119ci .VAR .TYPE lab1 lab2 lab3 .TYPE lab4 .TYPE lab5 lab6 ... .var .byte a,b,c .dword i j dodana mo\u017cliwo\u015b\u0107 definicji pojedy\u0144czych zmiennych typu strukturalnego w kr\u00f3tszy spos\u00f3b ani\u017celi dot\u0105d przez DTA .struct @point x .byte y .byte .ends pointA @point ; pointA dta @point [0] <=> pointA dta @point pointB @point ; pointB dta @point [0] <=> pointB dta @point points dta @point [100] dodana nowa dyrektywa .ZPVAR umo\u017cliwiaj\u0105ca automatyczne przydzielenie miejsca zmiennym na stronie zerowej .ZPVAR TYPE label1, label2 label3 = $80 ; LABEL1=$80, LABEL2=LABEL1+TYPE, LABEL3=LABEL2+TYPE .ZPVAR label4, label5 TYPE ; LABEL4=LABEL3+TYPE, LABEL5=LABEL4+TYPE .print .zpvar poprawione dzia\u0142anie dyrektywy .ERROR i pseudo rozkazu ERT , mo\u017cliwe jest umieszczenie dodatkowych informacji w wierszu podobnie jak dla .PRINT .ECHO np.: ERT *>$6000 , BUUU przekroczyli\u015bmy zakres pami\u0119ci o ' , *-$6000 , ' bajt\u00f3w' dodana mo\u017cliwo\u015b\u0107 zagnie\u017cd\u017cania blok\u00f3w procedur .PROC, ten sam kod mo\u017ce by\u0107 wywo\u0142ywany z r\u00f3\u017cnymi parametrami np.: .proc copySrc (.word src+1) .var .proc ToDst (.word src+1, dst+1) .var .endp ldy #0 src lda $ffff,y dst sta $ffff,y iny bne src rts .endp copySrc.ToDst #$a080 #$b000 copySrc #$a360 dodane nowe dyrektywy .ENUM .ENDE .EEND .enum dni_tygodnia poniedzialek = 1 wtorek, sroda = 5, czwartek = 7 piatek sobota niedziela .ende ift dzien==dni_tygodnia::wtorek .print 'wtorek' eif rozszerzona funkcjonalno\u015b\u0107 komentarzy wieloliniowych /* */ o mo\u017cliwo\u015b\u0107 umieszczania ich gdziekolwiek lda #12+ /* komentarz */ 23 umo\u017cliwiona relokacja adres\u00f3w definiowanych dyrektyw\u0105 .DEF .reloc .def label=* lda label dodana mo\u017cliwo\u015b\u0107 u\u017cycia znak\u00f3w { } do oznaczenia bloku (z wyj\u0105tkiem blok\u00f3w .MACRO ), znak { } zostaje rozpoznany na pocz\u0105tku nowego wiersza, np.: #while .word ad+1<=#$bc40+39 { ad sta $bc40 inw ad+1 } .proc lab { .local temp2 { } .array tab [255] .long {} }","title":"1.8.3 - 1.8.4"},{"location":"#182","text":"zniesione ograniczenie d\u0142ugo\u015bci pliku dla pseudo rozkazu INS (poprzednio d\u0142ugo\u015b\u0107 wczytywanego pliku ograniczona by\u0142a do 65536 bajt\u00f3w) dodany komunikat b\u0142\u0119du The referenced label ... has not previously been defined properly w przypadku etykiet, kt\u00f3re nie zosta\u0142y zdefiniowane do ko\u0144ca, np. tylko w pierwszym przebiegu warto\u015bci\u0105 nieokre\u015blon\u0105 dodana nowa dyrektywa .ECHO jako odpowiednik dyrektywy .PRINT, dodatkowo informacje generowane przez .PRINT .ECHO zapisywane s\u0105 teraz tak\u017ce w listingu *.LST dodana nowa dyrektywa .ALIGN pozwalaj\u0105ca na wyr\u00f3wnanie do zadanego zakresu pami\u0119ci, dodatkowo mo\u017cna okre\u015bli\u0107 warto\u015b\u0107 jak\u0105 wype\u0142ni\u0107 pami\u0119\u0107 [label] .ALIGN N[,fill] dodany nowy prze\u0142\u0105cznik -U (Warn of unused labels)","title":"1.8.2"},{"location":"#181","text":"rozszerzone dzia\u0142anie znaku backslash \\ , umieszczenie go na ko\u0144cu wiersza oznacza kontynuacj\u0119 aktualnego wiersza od nowego wiersza, np.: macro_temp \\ _____________________________________parametr1_________________________________________________\\ _____________________________________parametr2_________________________________________________\\ _____________________________________parametr3_________________________________________________ lda\\ #____________________________________label________________________________________\\ +__________________________________expression___________________________________ zmienione testowanie nieko\u0144cz\u0105cego wywo\u0142ywania si\u0119 makr po kt\u00f3rym wyst\u0105pi b\u0142\u0105d Infinite loop naprawiony zapis etykiet do pliku *.LAB , b\u0142\u0105d powsta\u0142 po dodaniu addytywno\u015bci obszar\u00f3w LOCAL poprawione dzia\u0142anie pseudo rozkazu SIN (kod zapo\u017cyczony z XASM ) poprawione rozpoznawanie dyrektyw przy w\u0142\u0105czonym prze\u0142\u0105czniku -C (Case sensitive) usprawniony odczyt blok\u00f3w .REPT (wskazanie prawid\u0142owej linii z b\u0142\u0119dem) i .MACRO zablokowane u\u017cycie .VAR w bloku .REPT umo\u017cliwione zagnie\u017cd\u017canie oraz wielokrotne uruchamianie (poprzez makra) p\u0119tli .REPT :repeat (poprzednio wyst\u0119powa\u0142 komunikat Use .REPT directive ) umo\u017cliwione przekazywanie parametr\u00f3w do bloku .REPT, np. .REPT 10, # label:1 ; LABEL0, LABEL1, LABEL2 ... LABEL9 .ENDR .REPT 5, $12,$33,$44,$55,$66 dta :1,:2,:3,:4,:5 ; $12,$33,$44,$55,$66 dta :5,:4,:3,:2,:1 ; $66,$55,$44,$33,$12 .ENDR","title":"1.8.1"},{"location":"#179-180","text":"poprawiony b\u0142\u0105d w opisie prze\u0142\u0105cznika -f , poprzednio Label at first column , prawid\u0142owy opis to CPU command at first column przepisana od nowa obs\u0142uga dyrektywy .DS i opcji OPT F+ (dodana mo\u017cliwo\u015b\u0107 u\u017cycia blok\u00f3w RUN i INI) przepisana od nowa obs\u0142uga opcji OPT ?+ (etykiety lokalne w standardzie MAE ) dodana mo\u017cliwo\u015b\u0107 upublicznienia w blokach PUBLIC tablic zadeklarowanych przez .ARRAY oraz deklaracji struktur .STRUCT dyrektywa generuj\u0105ca kod 6502 dla decyzji .TEST zast\u0105piona zosta\u0142a przez dyrektyw\u0119 #IF , dyrektywa .ENDT przez #END , dodatkowo mo\u017cliwe jest u\u017cycie dyrektywy #ELSE np.: # if .byte i>#8 .and .byte i<#200 # else #if .word j = #12 #end # end dyrektywa generuj\u0105ca kod 6502 dla iteracji .WHILE zast\u0105piona zosta\u0142a przez dyrektyw\u0119 #WHILE , dyrektywa .ENDW przez #END , np.: lda 20 -> lda 20 # while .byte @=20 -> wait cmp 20 # end -> sne -> jmp wait dyrektywy #IF #WHILE akceptuj\u0105 dwa dodatkowe operatory == != dodana dyrektywa .EXITM jako odpowiednik .EXIT dodana dyrektywa .FI jako odpowiednik .ENDIF dodana dyrektywa .IFDEF jako kr\u00f3tszy odpowiednik dyrektyw .IF .DEF dodana dyrektywa .IFNDEF jako kr\u00f3tszy odpowiednik dyrektyw .IF .NOT .DEF umo\u017cliwione zosta\u0142o definiowanie makr w obszarze procedury .PROC , podsumowuj\u0105c aktualnie dopuszczalne jest zdefiniowanie makra w obszarze .LOCAL .PROC wyst\u0105pienie jakiegokolwiek ostrze\u017cenia podczas asemblacji nie zmieni kodu wyj\u015bcia (exit_code=0), zmiana podyktowana potrzeb\u0105 kompatybilno\u015bci z linuxowym makefile ujednolicony spos\u00f3b deklaracji etykiet lokalnych i globalnych, \"bia\u0142e znaki\" przed nazw\u0105 etykiety nie wymusz\u0105 zdefiniowania takiej etykiety jako globalnej, umo\u017cliwi to tylko dyrektywa .DEF :LABEL poprawione makra @CALL.MAC @CALL_2.MAC , zmienna tymczasowa globalna ?@stack_offset modyfikowana jest teraz przez dyrektyw\u0119 .DEF rezygnacja z opcji -E (Eat White spaces), aktualnie jest ta opcja zawsze w\u0142\u0105czona poprawione wy\u015bwietlanie numeru linii z b\u0142\u0119dem w aktualnie wykonywanym makrze skr\u00f3cone nazwy etykiet tworzonych podczas wykonywania makr (\u0142atwiejsza ich identyfikacja w pliku *.LAB ) poprawione dzia\u0142anie opcji OPT H- dodane nowe makro rozkazy INL (increse LONG), IND (increse DWORD), DEL (decrese LONG), DED (decrese DWORD) dodane nowe makro rozkazy CPB (compare BYTE), CPW (compare WORD), CPL (compare LONG), CPD (compare DWORD) usprawnione i rozszerzone dzia\u0142anie dyrektyw #TEST #WHILE w oparciu o kod generowany przez makro rozkazy CPB CPW CPL CPD , dyrektywy #TEST #WHILE dla wyra\u017ce\u0144 =#0 <>#0 generuj\u0105 najkr\u00f3tszy kod wynikowy dodana optymalizacja d\u0142ugo\u015bci generowanego kodu dla makro rozkaz\u00f3w MWA MWX MWY dodana nowa opcja OPT R optymalizuj\u0105ca kod makro rozkaz\u00f3w MWA MWX MWY MVA MVX MVY ze wzgl\u0119du na zawarto\u015b\u0107 rejestr\u00f3w, np.: opt r- opt r+ mva #0 $80 -> lda #$00 -> lda #0 mva #0 $81 -> sta $80 -> sta $80 lda #$00 -> sta $81 sta $81 -> rozszerzona funkcjonalno\u015b\u0107 dyrektywy .DEF o mo\u017cliwo\u015b\u0107 przypisania warto\u015bci nowo deklarowanej etykiecie, np.: .def label = 1 rozszerzona funkcjonalno\u015b\u0107 dyrektywy .DEF o mo\u017cliwo\u015b\u0107 zdefiniowania etykiety globalnej niezale\u017cnie od aktulnego obszaru lokalnego, np.: .def :label umo\u017cliwiona zosta\u0142a addytywno\u015b\u0107 obszar\u00f3w .LOCAL , tzn. mo\u017ce istnie\u0107 wiele obszar\u00f3w lokalnych o tej samej nazwie, symbole zawarte w takich obszarach nale\u017ce\u0107 b\u0119d\u0105 do wsp\u00f3lnej przestrzeni nazw, np.: .local namespace .proc proc1 .endp .endl .local namespace .proc proc2 .endp .endl","title":"1.7.9 - 1.8.0"},{"location":"#178","text":"dodane dyrektywy .MEND .PGEND .REND jako odpowiedniki .ENDM .ENDPG .ENDR obecnie deklaracja makra musi ko\u0144czy\u0107 si\u0119 dyrektyw\u0105 .ENDM lub .MEND (poprzednio dopuszczalne by\u0142o u\u017cycie dyrektywy .END ) poprawiony spos\u00f3b wykonywania makr dzi\u0119ki czemu umo\u017cliwione zosta\u0142o wykonanie dyrektywy .ENDL z poziomu wykonywanego makra poprawione zauwa\u017cone b\u0142\u0119dy dotycz\u0105ce starszych bajt\u00f3w relokowanego adresu oraz bloku aktualizacji symboli publicznych dodana nowa dyrektywa .USING .USE pozwalaj\u0105ca okre\u015bli\u0107 \u015bcie\u017ck\u0119 poszukiwa\u0144 dla nazw etykiet poprawione dzia\u0142anie dyrektyw .LOCAL .DEF , kt\u00f3rych b\u0142\u0119dne dzia\u0142anie objawia\u0142o si\u0119 w szczeg\u00f3lnych przypadkach poprawione dzia\u0142anie makro rozkaz\u00f3w skok\u00f3w ( SNE RNE itp.), kt\u00f3rych b\u0142\u0119dne dzia\u0142anie objawia\u0142o si\u0119 w szczeg\u00f3lnych przypadkach rozszerzona sk\u0142adnia dyrektywy .TEST (kod 6502 dla warunku) o dowoln\u0105 ilo\u015b\u0107 wyra\u017ce\u0144 po\u0142\u0105czonych przez .OR lub .AND (brak mo\u017cliwo\u015bci zmiany piorytetu warto\u015bciowania przy pomocy nawias\u00f3w), np.: .test .byte k>#10+1 .or .word j>#100 .and .word j<#105 .or .byte k<=#5 ... ... .endt rozszerzona sk\u0142adnia dyrektywy .WHILE (kod 6502 dla p\u0119tli) o dowoln\u0105 ilo\u015b\u0107 wyra\u017ce\u0144 po\u0142\u0105czonych przez .OR lub .AND (brak mo\u017cliwo\u015bci zmiany piorytetu warto\u015bciowania przy pomocy nawias\u00f3w), np.: .while .byte k>#4 .and .byte k<#39 ... ... .endw","title":"1.7.8"},{"location":"#176-177","text":"dodany nowy prze\u0142\u0105cznik -B:ADDRESS umo\u017cliwiaj\u0105cy asemblacje od zadanego adresu dodany nowa opcja OPT F+- pozwalaj\u0105ca tworzy\u0107 bloki ci\u0105g\u0142ej pami\u0119ci (przydatne dla cart\u00f3w) dodana obs\u0142uga parametr\u00f3w typu .LONG .DWORD przekazywanych do procedur .PROC typu .VAR (poprzednio akceptowanymi typami parametr\u00f3w by\u0142 tylko .BYTE .WORD ) dodana nowa dyrektywa .FL realizuj\u0105ca zapis liczb rzeczywistych REAL w formacie FP Atari , np.: pi .fl 3.1415926535897932384626433832795 ; 40 03 14 15 92 65 tb .fl 0.5 12.34 -2.30 0.00002 tb .fl 0.5, 12.34, -2.30, 0.00002 umo\u017cliwiony zosta\u0142 zapis warto\u015bci innych typ\u00f3w ni\u017c tylko .BYTE w bloku .ARRAY dodana obs\u0142uga typ\u00f3w wielokrotnych dla .STRUCT , poprzednio takie typy by\u0142y akceptowane jednak pami\u0119\u0107 nie by\u0142a w\u0142a\u015bciwie dla nich rezerwowana, np.: .struct test x :200 .byte y :999 .long .ends buf dta test [0] poprawione b\u0142\u0119dy dotycz\u0105ce generowania kodu relokowalnego zauwa\u017cone przez Laoo , np.: .reloc lda temp temp .long $aabbcc b\u0142\u0105d Addres relocation overload wyst\u0105pi teraz tylko gdy wyra\u017cenie b\u0119dzie dotyczy\u0107 wi\u0119cej ni\u017c jednej etykiety relokowalnej, poprzednio ka\u017cde wyra\u017cenie z udzia\u0142em etykiety relokowalnej powodowa\u0142o wy\u015bwietlenie tego komunikatu b\u0142\u0119du blok aktualizacji symboli plublicznych rozszerzony zosta\u0142 o mo\u017cliwo\u015b\u0107 przekazywania sta\u0142ych r\u00f3\u017cnych typ\u00f3w B-YTE, W-ORD, L-ONG, D-WORD, poprzednio przekazywanym typem by\u0142 tylko W-ORD zmienione dzia\u0142anie dyrektywy .VAR w blokach .LOCAL znajduj\u0105cych si\u0119 w bloku .PROC , zmienne takie zawsze odk\u0142adane s\u0105 na ko\u0144cu bloku przed dyrektyw\u0105 .ENDP , w pozosta\u0142ych przypadkach na ko\u0144cu bloku .LOCAL przed dyrektyw\u0105 .ENDL umo\u017cliwiona zosta\u0142a relokowalno\u015b\u0107 kodu generowanego przez dyrektywy .WHILE .TEST poprawione dzia\u0142anie testowania warto\u015bci typu .WORD w kodzie generowanym przez dyrektywy .WHILE .TEST dodana nowa dyrektywa .ADR zwracaj\u0105ca adres etykiety przed zmian\u0105 adresu asemblacji dodana nowa dyrektywa .LEN zwracaj\u0105ca d\u0142ugo\u015b\u0107 blok\u00f3w zdefiniowanych przez .PROC .ARRAY poprawione dzia\u0142anie operacji dzielenia, mno\u017cenia i modulo, poprzednio b\u0142\u0119dnie by\u0142 interpretowany piorytet dla tych operacji komentarze z ko\u0144ca linii nie poprzedzone znakiem komentarza b\u0119d\u0105 powodowa\u0107 wyst\u0105pienie b\u0142\u0119du Unexpected end of line dodana mo\u017cliwo\u015b\u0107 przypisania zmiennej p\u00f3l zdefiniowanych przez strukture, np.: @point .struct x .byte y .byte .ends a @point b @point c @point rozszerzona sk\u0142adnia .STRUCT o mo\u017cliwo\u015b\u0107 dodania nowych p\u00f3l bez definiowania nazwy pola, np.: .struct @id id .word .ends .struct @mem @id adr .word .ends rozszerzona sk\u0142adnia makro rozkazu MWA o mo\u017cliwo\u015b\u0107 u\u017cycia adresowania po\u015bredniego strony zerowej postindeksowanego Y , np.: mwa ($80),y $a000,x mwa $bc40,y ($f0),y mwa ($80),y ($82),y rozszerzona sk\u0142adnia dyrektywy .EXTRN , obecnie mo\u017cliwe jest zapowiedzenie wi\u0119kszej ilo\u015bci etykiet r\u00f3\u017cnych typ\u00f3w w jednym wierszu, zapowiedzenie procedury .PROC w takim wierszu musi znajdowa\u0107 si\u0119 na jego ko\u0144cu, np.: .extrn a,b,c,d .byte x y z .word line .proc(.byte x,y) .reg rozszerzona sk\u0142adnia dyrektywy .VAR , obecnie mo\u017cliwe jest zadeklarowanie wi\u0119kszej ilo\u015bci etykiet r\u00f3\u017cnych typ\u00f3w w jednym wierszu oraz przypisanie im adresu od kt\u00f3rego zostan\u0105 od\u0142o\u017cone w pami\u0119ci, np.: .var x y z .byte bit :2 .dword = $80 rozszerzona sk\u0142adnia dla parametr\u00f3w procedur przekazywanych przez zmienne .VAR , mo\u017cliwe jest podanie przesuni\u0119cia np.: move .proc (.word src+1,dst+1) .var src lda $ffff dst sta $ffff .endp dodana nowa dyrektywa .NOWARN wy\u0142\u0105czaj\u0105ca wy\u015bwietlenie ostrze\u017cenia dla aktualnie asemblowanego wiersza, np.: .nowarn PROCNAME dodane nowe makro rozkazy PHR PLR realizuj\u0105ce odk\u0142adanie i zdejmowanie warto\u015bci rejestr\u00f3w z udzia\u0142em stosu sprz\u0119towego, np.: PHR -> PHA PLR -> PLA TXA TAY PHA PLA TYA TAX PHA PLA dodane nowe makro rozkazy ADB , SBB realizuj\u0105ce dodawanie i odejmowanie warto\u015bci typu .BYTE , np.: ADB $80 #12 $b000 -> lda $80 clc adc #12 sta $b000 SBB #200 $a000 -> lda #200 sec sbc $a000 sta $a000 dodana mo\u017cliwo\u015b\u0107 u\u017cycia sk\u0142adni C dla liczb szestnastkowych, np.: lda 0x2000 ldx #0x12 temp = 0x8000","title":"1.7.6 - 1.7.7"},{"location":"#175","text":"dyrektywa .DS w blokach relokowalnych SDX RELOC i MADS RELOC deklaruje od teraz pusty blok dodany nowy prze\u0142\u0105cznik -F, kt\u00f3ry umo\u017cliwia umieszczanie rozkaz\u00f3w CPU i pseudo rozkaz\u00f3w od pierwszej kolumny w wierszu przepisane od nowa procedury odczytu blok\u00f3w .MACRO .REPT oraz procedura realizuj\u0105ca dzielenie wiersza przy pomocy znaku \\ dodane nowe pseudo rozkazy ADW , SBW realizuj\u0105ce dodawanie i odejmowanie warto\u015bci typu WORD dla 6502 , np.: adw hlp #40 ; hlp=hlp+40 adw hlp #20 pom ; pom=hlp+20 rozszerzone dzia\u0142anie dyrektywy .DEF o mo\u017cliwo\u015b\u0107 zdefiniowania etykiety, np.: .DEF label zwi\u0119kszona liczba przebieg\u00f3w dla deklaracji etykiet przez EQU dla pewnych szczeg\u00f3lnych przypadk\u00f3w","title":"1.7.5"},{"location":"#174","text":"naprawione dzia\u0142anie dyrektywy .PRINT , dot\u0105d mog\u0142a nie wy\u015bwietli\u0107 warto\u015bci etykiet zaczynaj\u0105cej si\u0119 na liter\u0119 A B C D E F G H L T V zablokowane dzia\u0142anie dyrektywy .DS w blokach .RELOC SDX oraz naprawione jej dzia\u0142anie z instrukcj\u0105 warunkow\u0105 .IF IFT usprawnione przeszukiwanie \u015bcie\u017cek dost\u0119pu -i:path (mo\u017cna odwo\u0142ywa\u0107 si\u0119 do podkatalog\u00f3w tam zawartych) w przypadku wyst\u0105pienia b\u0142\u0119d\u00f3w podczas asemblacji wy\u015bwietlane s\u0105 one wszystkie a nie tylko pierwszy z b\u0142\u0119d\u00f3w poprawione zauwa\u017cone b\u0142\u0119dy, m.in. u\u017cycie makra w pliku .RELO C mog\u0142o spowodowa\u0107 w pewnych sytuacjach zapis b\u0142\u0119dnej informacji o relokownych adresach uproszczony zosta\u0142 spos\u00f3b ko\u0144czenia procedur wykorzystuj\u0105cych stos programowy MADS , nie ma potrzeby u\u017cywania dyrektywy .EXIT , a dyrektywa .ENDP nie powoduje ju\u017c dodatkowych dzia\u0142a\u0144 na stosie programowym dodana nowa dyrektywa .SYMBOL jako odpowiednik bloku aktualizacji BLK UPDATE NEW SYMBOL 'SYMBOL' , dyrektyw\u0119 .SYMBOL mo\u017cna u\u017cy\u0107 w dowolnym miejscu programu dodane automatyczne wywo\u0142ywanie blok\u00f3w aktualizacji ADDRESS EXTERNAL PUBLIC SYMBOL dla .RELOC i SDX dodane nowe dyrektywy .BY .WO .HE .EN .SB (zapo\u017cyczone z MAE ) dodany nowy prze\u0142\u0105cznik OPT ?- (domy\u015blnie) etykiety ze znakiem zapytania (?labels) traktowane s\u0105 jako etykiety tymczasowe, OPT ?+ etykiety ze znakiem zapytania ?labels traktowane s\u0105 jako lokalne i tymczasowe, nazw\u0105 obszaru lokalnego jest ostatnio u\u017cyta etykieta bez znaku zapytania dodane dyrektywy .LEND .PEND .AEND .WEND .TEND .SEND jako odpowiedniki dyrektyw .ENDL .ENDP .ENDW ENDW .ENDT .ENDS dodane nowe dyrektywy .GLOBAL .GLOBL jako odpowiednik (zamiennik) dyrektywy .PUBLIC dodana optymalizacja skok\u00f3w warunkowych JEQ JNE JPL JMI JCC JCS JVC JVS je\u015bli jest taka mo\u017cliwo\u015b\u0107 wybierany jest skok kr\u00f3tki typu BEQ BNE BPL BMI BCC BCS BVC BVS dodany nowy domy\u015blny separator znak spacji dla przekazywanych parametr\u00f3w do .PROC .MACRO dot\u0105d by\u0142 to tylko znak przecinka usprawnienia dotycz\u0105ce przekazywania parametr\u00f3w do makr i procedur, np. paramatrem makra mo\u017ce by\u0107 dyrektywa zwracaj\u0105ca warto\u015b\u0107 wyra\u017cenia lub symbol licznika p\u0119tli # :12 makro # dodana mo\u017cliwo\u015b\u0107 u\u017cycia znaku spacji jako separatora dla .VAR .EXTRN np. .EXTRN a b c d .word .VAR i = 1 j = 2 .byte .VAR a b c d .byte rozszerzona sk\u0142adnia dla .VAR umo\u017cliwiaj\u0105ca zaincjowanie zmiennych sta\u0142\u0105, np.: .var i = 10 j = 12 .byte .var a , b = 2 .byte dodane nowe dyrektywy .WHILE .ENDW pozwalaj\u0105ce na automatyczne wygenerowanie kodu dla p\u0119tli WHILE , np.: ldx #$ff .while .word adr < #$bc40+40*24 stx $bc40 adr: equ *-2 inw adr .endw dodane nowe dyrektywy .TEST .ENDT pozwalaj\u0105ce na automatyczne wygenerowanie kodu dla warunku, np.: .test .byte (@>=#'a') .test .byte (@<=#'z') .endt .endt","title":"1.7.4"},{"location":"#173","text":"dodana mo\u017cliwo\u015b\u0107 zmiany adresu asemblacji .PROC lub .LOCAL bez zmiany adresu \u0142adowania usuni\u0119to optymalizacj\u0119 kodu dla makro rozkaz\u00f3w MWA itp., kt\u00f3ra mog\u0142a powodowa\u0107 w szczeg\u00f3lnych przypadkach zap\u0119tlenie si\u0119 MADS dodane dyrektywy .REG .VAR pozwalaj\u0105ce okre\u015bli\u0107 spos\u00f3b przekazywania parametr\u00f3w do procedur ( .REG przez rejestry CPU , .VAR przez zmienne) dodana dyrektywa .VAR pozwalaj\u0105ca na deklaracj\u0119 zmiennych w blokach .PROC .LOCAL , zadeklarowane zmiennne s\u0105 fizycznie odk\u0142adane na ko\u0144cu takiego bloku rozszerzona sk\u0142adnia dla dyrektywy .EXTRN , np. EXTRN label1,label2,label3... TYPE jesli brak deklaracji etykiet dla stosu programowego MADS , przyjmowane s\u0105 domy\u015blne warto\u015bci @PROC_VARS_ADR=$0500 @STACK_ADDRESS=$0600 @STACK_POINTER=$FE dodany repeat_counter # , kt\u00f3ry mo\u017cna u\u017cywa\u0107 zamiennie z dyrektyw\u0105 .R wystapi b\u0142\u0105d ^ not relocatable przy pr\u00f3bie relokacji rozkazu lda ^label dodana obs\u0142uga symboli publicznych dla sta\u0142ych CONSTANT w blokach PUBLIC poprawiona relokowalnosc dla tablic .ARRAY , danych stworzonych przez .STRUCT , parametr\u00f3w przekazywanych do procedur przez sta\u0142a #","title":"1.7.3"},{"location":"#172","text":"przepisana na nowo obs\u0142uga pseudo rozkaz\u00f3w REQ RNE RPL RMI RCC RCS RVC RVS SEQ SNE SPL SMI SCC SCS SVC SVS poprawione dzia\u0142anie dyrektywy .LINK dla blok\u00f3w o sta\u0142ych adresach poprawione testowanie s\u0142\u00f3w zarezerwowanych (mo\u017cna u\u017cywa\u0107 nazw zarezerwowanych dla WDC 65816 gdy u\u017cywamy tylko 6502 ) zmiany w listingu, wy\u015bwietla informacje o numerze banku tylko gdy bank > 0 dodana obs\u0142uga makro rozkaz\u00f3w MWA MWX MWY MVA MVX MVY ADD SUB INW DEW (do ich obs\u0142ugi nie s\u0105 ju\u017c potrzebne makra)","title":"1.7.2"},{"location":"#171","text":"dodana mo\u017cliwo\u015b\u0107 u\u017cywania nazw mnemonik\u00f3w WDC 65816 w trybie pracy 6502 , w trybie WDC 65816 wyst\u0105pi ju\u017c b\u0142\u0105d Reserved word poprawione dzia\u0142anie pseudo rozkaz\u00f3w skok\u00f3w SCC RNE itp. w makrach usprawnione wykonywanie wielu makr rozdzielonych znakiem dwukropka :","title":"1.7.1"},{"location":"#170","text":"usuni\u0119ty b\u0142\u0105d, kt\u00f3ry powodowa\u0142 zbyt ma\u0142a liczb\u0119 przebieg\u00f3w asemblacji dodana obs\u0142uga pseudo rozkaz\u00f3w JEQ JNE JPL JMI JCC JCS JVC JVS (makra nie s\u0105 ju\u017c potrzebne do ich obs\u0142ugi)","title":"1.7.0"},{"location":"#169","text":"rozszerzona sk\u0142adnia dla .ARRAY .PUT dodany pseudo rozkaz EXT pozwalaj\u0105cy na deklaracje etykiety external dodane makra JEQ JNE JPL JMI JCC JCS dodane dyrektywy .PAGES .ENDPG dodana dyrektywa .END zastepujaca inne dyrektywy .END? prze\u0142\u0105cznik -H zast\u0105piony zosta\u0142 przez -HC (generuje plik nag\u0142\u00f3wkowy dla CC65 ) dodany nowy prze\u0142\u0105cznik -HM generuj\u0105cy plik nag\u0142\u00f3wkowy dla MADS z sortowaniem na etykiety typu CONSTANTS VARIABLES PROCEDURES dodana nowa dyrektywa .RELOC generuj\u0105ca kod relokowalny w formacie MADS","title":"1.6.9"},{"location":"#168","text":"dodana nowa dyrektywa .PUT oraz rozszerzona sk\u0142adnia dla dyrektywy .GET (../EXAMPLES/MSX/MPT_PLAYER/MPT_RELOCATOR.MAC , ../EXAMPLES/MSX/TMC_PLAYER/TMC_RELOCATOR.MAC) dodana obs\u0142uga pseudo rozkaz\u00f3w XASM REQ RNE RPL RMI RCC RCS RVC RVS SEQ SNE SPL SMI SCC SCS SVC SVS dodana mo\u017cliwo\u015b\u0107 \u0142\u0105czenia dowolnej liczby znanych MADS mnemonik\u00f3w przy pomocy znaku : (styl XASM ), np.: lda:cmp:req 20 ldx:ldy:lda:iny label","title":"1.6.8"},{"location":"#166-167","text":"\u017ar\u00f3d\u0142o MADS kompatybilne z Free Pascal Compiler , po kompilacji mo\u017cliwe jest jego u\u017cywanie na innych platformach systemowych, jak np. Linux , Mac OS , OS/2 itp. od teraz MADS sam dobiera odpowiedni\u0105 liczb\u0119 przebieg\u00f3w asemblacji, prze\u0142\u0105cznik /3 nie jest ju\u017c potrzebny poprawiony i rozbudowany zosta\u0142 mechanizm przekazywania parametr\u00f3w do MADS (rozdzia\u0142 Prze\u0142\u0105czniki assemblera ) poprawione zosta\u0142o wywo\u0142anie makra w linii rozdzielanej znakiem \\ oraz usprawnione rozpoznawanie i wykonywanie linii rozdzielanych znakami \\ poprawiony b\u0142\u0105d, w kt\u00f3rym MADS myli\u0142 dyrektyw\u0119 .ENDM z pseudorozkazem IFT poprawione dzia\u0142anie instrukcji warunkowych .ELSEIF .ELSE poprawione testowanie poprawno\u015bci instrukcji warunkowych w makrach obs\u0142uga procedur .PROC zosta\u0142a rozbudowana o nowe makra i mechanizmy, dzi\u0119ki kt\u00f3rym podobna jest w dzia\u0142aniu jak i \u0142atwo\u015bci u\u017cycia do procedur z j\u0119zyk\u00f3w wy\u017cszego poziomu dla procedur .PROC z zadeklarowanymi parametrami potrzebna jest teraz dodatkowa deklaracja @PROC_VARS_ADR brak ogranicze\u0144 w liczbie parametr\u00f3w przekazywanych do procedur, jedynym ograniczeniem jest dost\u0119pna pami\u0119\u0107 dodany nowy prze\u0142\u0105cznik /d:label=value pozwalaj\u0105cy zdefiniowa\u0107 now\u0105 etykiet\u0119 MADS z poziomu linii polece\u0144 dodany nowy prze\u0142\u0105cznik /x Exclude unreferenced procedures pozwalaj\u0105cy pomin\u0105\u0107 podczas asemblacji nie u\u017cywane w programie procedury zadeklarowane dyrektyw\u0105 .PROC nowa opcja OPT T+ (track sep, rep) \u015bledz\u0105ca zmiany rozmiaru rejestr\u00f3w A X Y dokonywane przez rozkazy SEP , REP WDC 65816 nowe biblioteki w katalogu ..\\EXAMPLES\\LIBRARIES w deklaracji obszaru lokalnego .LOCAL nie jest wymagane podanie nazwy obszaru nowe operatory -= += ++ -- pozwalaj\u0105ce zmniejszy\u0107/zwi\u0119kszy\u0107 warto\u015b\u0107 etykiety tymczasowej, np.: ?label -- -> ?label=?label-1 ?lab ++ -> ?lab=?lab+1 ?temp += 3 -> ?temp=?temp+3 ?ofset -= 5 -> ?ofset=?ofset-5 rozszerzona o znak przecinka sk\u0142adnia deklaracji parametr\u00f3w procedur, np.: .proc nazwa (.byte a,b,c .word d,e) .endp","title":"1.6.6 - 1.6.7"},{"location":"banki-pamieci/","text":"Wst\u0119p Pewnie ka\u017cdemu, kto mia\u0142 do czynienia z architektur\u0105 ma\u0142ego Atari , poj\u0119cie bank pami\u0119ci kojarzy si\u0119 z pami\u0119ci\u0105 rozszerzon\u0105, podzielon\u0105 na banki wielko\u015bci 16kb , prze\u0142\u0105czane w obszar $4000..$7FFF . MADS te\u017c mo\u017ce to rozumie\u0107 w ten spos\u00f3b (opcja OPT B+ , Sprz\u0119towe banki pami\u0119ci ), jednak domy\u015blnie rozumie to w spos\u00f3b bardziej wirtualny (opcja OPT B- , Wirtualne banki pami\u0119ci ). Bank\u00f3w dotycz\u0105 n/w pseudo rozkazy: LMB #value NMB RMB LMB # Load Memory Bank Ustawiamy licznik bank\u00f3w MADS-a na konkretn\u0105 warto\u015b\u0107 z zakresu <$00..$FF> (BANK = value), np. lmb #0 lmb #bank lmb #5 , $6500 ; tylko gdy OPT B+ NMB Next Memory Bank Zwi\u0119kszamy o 1 licznik bank\u00f3w MADS -a (BANK = BANK + 1). nmb nmb $6500 ; tylko gdy OPT B+ RMB Reset Memory Bank Zerujemy licznik bank\u00f3w MADS -a (BANK = 0). rmb rmb $3500 ; tylko gdy OPT B+ rmb $8500 ; tylko gdy OPT B+ MADS podczas asemblacji, ka\u017cdej nowo zdefiniowanej etykiecie przypisuje aktualn\u0105 warto\u015b\u0107 licznika bank\u00f3w. Programista mo\u017ce mie\u0107 wp\u0142yw na warto\u015b\u0107 licznika bank\u00f3w dzi\u0119ki w/w pseudo rozkazom. Etykiety z przypisanym licznikiem bank\u00f3w MADS =0 s\u0105 zasi\u0119gu globalnego . Etykiety z przypisanym licznikiem bank\u00f3w MADS >0 s\u0105 zasi\u0119gu lokalnego . Wirtualne banki pami\u0119ci OPT B- W MADS przez poj\u0119cie wirtualny bank pami\u0119ci rozumiany jest ka\u017cdy obszar oznaczony przez nowo zdefiniowan\u0105 etykiet\u0119 z przypisan\u0105 aktualn\u0105 warto\u015bci\u0105 licznika bank\u00f3w (domy\u015blnie licznik bank\u00f3w jest wyzerowany). Czyli wirtualny bank pami\u0119ci to nie koniecznie obszar pami\u0119ci $4000..$7FFF , ale ka\u017cda etykieta reprezentuj\u0105ca jaki\u015b obszar kodu programu, kt\u00f3rej przypisany zosta\u0142 kod (warto\u015b\u0107 licznika bank\u00f3w) z zakresu $00..$FF przy pomocy odpowiednich pseudo rozkaz\u00f3w oddanych na u\u017cytek programisty NMB RMB LMB . Wyj\u0105tek stanowi\u0105 bloki .RELOC w kt\u00f3rych nie mo\u017cna samodzielnie zmienia\u0107 licznika bank\u00f3w, realizuje to automatycznie MADS , kt\u00f3ry zwi\u0119ksza licznik za ka\u017cdym wywo\u0142aniem dyrektywy .RELOC . Licznik bank\u00f3w w takim przypadku przyjmuje warto\u015bci z zakresu $0001..$FFF7 . Programista mo\u017ce odczyta\u0107 warto\u015b\u0107 licznika bank\u00f3w, kt\u00f3ry zosta\u0142 przypisany etykiecie za pomoc\u0105 operatora = np.: label ldx #=label W w/w przyk\u0142adzie do rejestru X CPU zapisali\u015bmy warto\u015b\u0107 licznika bank\u00f3w pami\u0119ci MADS przypisany etykiecie LABEL . Innym przydatnym operatorem mo\u017ce by\u0107 znak dwukropka : umieszczony na pocz\u0105tku nazwy etykiety. Spowoduje to \u017ce MADS odczyta warto\u015b\u0107 takiej etykiety pomijaj\u0105c ograniczenia zasi\u0119gu, kt\u00f3re wprowadza licznik bank\u00f3w MADS . Niekiedy mo\u017ce spowodowa\u0107 to komplikacje, np. je\u015bli wyst\u0105pi\u0142o wi\u0119cej etykiet o tej samej nazwie ale w r\u00f3\u017cnych obszarach lokalnych albo w obszarach o r\u00f3\u017cnych warto\u015bciach licznika wirtualnych bank\u00f3w. lmb #5 label5 nop lmb #6 label6 nop lda :label5 Dla w/w przyk\u0142adu brak operatora : na pocz\u0105tku nazwy etykiety w rozkazie lda :label5 sko\u0144czy si\u0119 komunikatem b\u0142\u0119du ERROR: Undeclared label LABEL5 (BANK=6) . Wirtualnych bank\u00f3w pami\u0119ci mo\u017cna u\u017cyc do indeksowania tablicy zawieraj\u0105cej warto\u015bci dla PORTB . Takie te\u017c jest ich zastosowanie w przypadku wybrania opcji OPT B+ . Sprz\u0119towe banki pami\u0119ci OPT B+ Ten tryb dzia\u0142ania MADS mo\u017cna okre\u015bli\u0107 jako czu\u0142y na banki BANK SENSITIVE . Sprz\u0119towe banki pami\u0119ci s\u0105 rozszerzeniem wirtualnych bank\u00f3w. Rozumiane s\u0105 przez MADS jako banki rozszerzonej pami\u0119ci, w\u0142\u0105czane w obszar $4000..$7FFF . Dzia\u0142anie pseudo rozkaz\u00f3w NMB RMB LMB zostaje rozszerzone o wywo\u0142anie makra @BANK_ADD , kt\u00f3re mo\u017cna znale\u017a\u0107 w katalogu ..\\EXAMPLES\\MACROS\\ . W tym trybie dzia\u0142ania MADS potrzebuje deklaracji konkretnych makr: @BANK_ADD @BANK_JMP oraz potrzebuje definicji etykiet o nazwach: @TAB_MEM_BANKS @PROC_ADD_BANK Etykieta @TAB_MEM_BANKS definiuje adres tablicy, z kt\u00f3rej warto\u015bci b\u0119d\u0105 przepisywane do rejestru PORTB odpowiedzialnego za prze\u0142\u0105czanie bank\u00f3w rozszerzonej pami\u0119ci. Mo\u017cemy sobie u\u0142atwi\u0107 spraw\u0119 i skorzysta\u0107 z gotowej procedury wykrywaj\u0105cej banki rozszerzonej pami\u0119ci do\u0142\u0105czonej do MADS , plik ..\\EXAMPLES\\PROCEDURES\\@MEM_DETECT.ASM . Etykieta @PROC_ADD_BANK u\u017cywana jest przez makro @BANK_ADD i definiuje adres pod jakim znajdzie si\u0119 kod programu prze\u0142\u0105czaj\u0105cy bank pami\u0119ci rozszerzonej. Programista mo\u017ce odczyta\u0107 warto\u015b\u0107 licznika bank\u00f3w, kt\u00f3ry zosta\u0142 przypisany etykiecie za pomoc\u0105 operatora = , np.: label ldy #=label W w/w przyk\u0142adzie do rejestru regY zapisali\u015bmy warto\u015b\u0107 licznika bank\u00f3w pami\u0119ci MADS przypisany etykiecie LABEL . Je\u015bli licznik bank\u00f3w MADS = 0 to: kod programu musi znajdowa\u0107 si\u0119 poza obszarem $4000..$7FFF nowo zdefiniowane etykiety w tym obszarze s\u0105 globalne mo\u017cna odwo\u0142ywa\u0107 si\u0119 do wszystkich zdefiniowanych etykiet bez ogranicze\u0144, bez wzgl\u0119du na numer banku skok w obszar banku mo\u017cliwy przy u\u017cyciu makra @BANK_JMP , przyk\u0142ad w pliku ..\\EXAMPLES\\MACROS\\@BANK_JMP.MAC , parametr dla tego makra nie musi by\u0107 poprzedzony operatorem : Je\u015bli licznik bank\u00f3w MADS > 0 to: kod programu musi znajdowa\u0107 si\u0119 w obszarze $4000..$7FFF nowo zdefiniowane etykiety w tym obszarze s\u0105 lokalne mo\u017cna odwo\u0142ywa\u0107 si\u0119 tylko do etykiet globalnych i tych zdefiniowanych w obszarze aktualnego banku pseudo rozkaz LMB NMB powoduje wykonanie makra @BANK_ADD , kt\u00f3re w\u0142\u0105cza nowy bank rozszerzonej pami\u0119ci na podstawie licznika bank\u00f3w MADS-a oraz ustawia nowy adres asemblacji (domy\u015blnie na $4000 ) pseudo rozkaz RMB powoduje wyzerowanie licznika bank\u00f3w pami\u0119ci MADS oraz ustawienie nowego adresu asemblacji poza bankiem (domy\u015blnie na $8000 ) skok w obszar innego banku mo\u017cliwy przy u\u017cyciu makra @BANK_JMP , przyk\u0142ad w pliku ..\\EXAMPLES\\MACROS\\@BANK_JMP , parametr dla tego makra musi by\u0107 poprzedzony operatorem : Przyk\u0142adem wykorzystania tego trybu pracy MADS jest plik ..\\EXAMPLES\\XMS_BANKS.ASM . W tym przyk\u0142adzie kod programu znajduje si\u0119 w dw\u00f3ch r\u00f3\u017cnych bankach rozszerzonej pami\u0119ci i wykonuje si\u0119 jakby by\u0142 jedn\u0105 ca\u0142o\u015bci\u0105.","title":"Banki pami\u0119ci"},{"location":"banki-pamieci/#_1","text":"","title":""},{"location":"banki-pamieci/#wstep","text":"Pewnie ka\u017cdemu, kto mia\u0142 do czynienia z architektur\u0105 ma\u0142ego Atari , poj\u0119cie bank pami\u0119ci kojarzy si\u0119 z pami\u0119ci\u0105 rozszerzon\u0105, podzielon\u0105 na banki wielko\u015bci 16kb , prze\u0142\u0105czane w obszar $4000..$7FFF . MADS te\u017c mo\u017ce to rozumie\u0107 w ten spos\u00f3b (opcja OPT B+ , Sprz\u0119towe banki pami\u0119ci ), jednak domy\u015blnie rozumie to w spos\u00f3b bardziej wirtualny (opcja OPT B- , Wirtualne banki pami\u0119ci ). Bank\u00f3w dotycz\u0105 n/w pseudo rozkazy: LMB #value NMB RMB LMB # Load Memory Bank Ustawiamy licznik bank\u00f3w MADS-a na konkretn\u0105 warto\u015b\u0107 z zakresu <$00..$FF> (BANK = value), np. lmb #0 lmb #bank lmb #5 , $6500 ; tylko gdy OPT B+ NMB Next Memory Bank Zwi\u0119kszamy o 1 licznik bank\u00f3w MADS -a (BANK = BANK + 1). nmb nmb $6500 ; tylko gdy OPT B+ RMB Reset Memory Bank Zerujemy licznik bank\u00f3w MADS -a (BANK = 0). rmb rmb $3500 ; tylko gdy OPT B+ rmb $8500 ; tylko gdy OPT B+ MADS podczas asemblacji, ka\u017cdej nowo zdefiniowanej etykiecie przypisuje aktualn\u0105 warto\u015b\u0107 licznika bank\u00f3w. Programista mo\u017ce mie\u0107 wp\u0142yw na warto\u015b\u0107 licznika bank\u00f3w dzi\u0119ki w/w pseudo rozkazom. Etykiety z przypisanym licznikiem bank\u00f3w MADS =0 s\u0105 zasi\u0119gu globalnego . Etykiety z przypisanym licznikiem bank\u00f3w MADS >0 s\u0105 zasi\u0119gu lokalnego .","title":"Wst\u0119p"},{"location":"banki-pamieci/#wirtualne-banki-pamieci-opt-b-","text":"W MADS przez poj\u0119cie wirtualny bank pami\u0119ci rozumiany jest ka\u017cdy obszar oznaczony przez nowo zdefiniowan\u0105 etykiet\u0119 z przypisan\u0105 aktualn\u0105 warto\u015bci\u0105 licznika bank\u00f3w (domy\u015blnie licznik bank\u00f3w jest wyzerowany). Czyli wirtualny bank pami\u0119ci to nie koniecznie obszar pami\u0119ci $4000..$7FFF , ale ka\u017cda etykieta reprezentuj\u0105ca jaki\u015b obszar kodu programu, kt\u00f3rej przypisany zosta\u0142 kod (warto\u015b\u0107 licznika bank\u00f3w) z zakresu $00..$FF przy pomocy odpowiednich pseudo rozkaz\u00f3w oddanych na u\u017cytek programisty NMB RMB LMB . Wyj\u0105tek stanowi\u0105 bloki .RELOC w kt\u00f3rych nie mo\u017cna samodzielnie zmienia\u0107 licznika bank\u00f3w, realizuje to automatycznie MADS , kt\u00f3ry zwi\u0119ksza licznik za ka\u017cdym wywo\u0142aniem dyrektywy .RELOC . Licznik bank\u00f3w w takim przypadku przyjmuje warto\u015bci z zakresu $0001..$FFF7 . Programista mo\u017ce odczyta\u0107 warto\u015b\u0107 licznika bank\u00f3w, kt\u00f3ry zosta\u0142 przypisany etykiecie za pomoc\u0105 operatora = np.: label ldx #=label W w/w przyk\u0142adzie do rejestru X CPU zapisali\u015bmy warto\u015b\u0107 licznika bank\u00f3w pami\u0119ci MADS przypisany etykiecie LABEL . Innym przydatnym operatorem mo\u017ce by\u0107 znak dwukropka : umieszczony na pocz\u0105tku nazwy etykiety. Spowoduje to \u017ce MADS odczyta warto\u015b\u0107 takiej etykiety pomijaj\u0105c ograniczenia zasi\u0119gu, kt\u00f3re wprowadza licznik bank\u00f3w MADS . Niekiedy mo\u017ce spowodowa\u0107 to komplikacje, np. je\u015bli wyst\u0105pi\u0142o wi\u0119cej etykiet o tej samej nazwie ale w r\u00f3\u017cnych obszarach lokalnych albo w obszarach o r\u00f3\u017cnych warto\u015bciach licznika wirtualnych bank\u00f3w. lmb #5 label5 nop lmb #6 label6 nop lda :label5 Dla w/w przyk\u0142adu brak operatora : na pocz\u0105tku nazwy etykiety w rozkazie lda :label5 sko\u0144czy si\u0119 komunikatem b\u0142\u0119du ERROR: Undeclared label LABEL5 (BANK=6) . Wirtualnych bank\u00f3w pami\u0119ci mo\u017cna u\u017cyc do indeksowania tablicy zawieraj\u0105cej warto\u015bci dla PORTB . Takie te\u017c jest ich zastosowanie w przypadku wybrania opcji OPT B+ .","title":"Wirtualne banki pami\u0119ci OPT B-"},{"location":"banki-pamieci/#sprzetowe-banki-pamieci-opt-b","text":"Ten tryb dzia\u0142ania MADS mo\u017cna okre\u015bli\u0107 jako czu\u0142y na banki BANK SENSITIVE . Sprz\u0119towe banki pami\u0119ci s\u0105 rozszerzeniem wirtualnych bank\u00f3w. Rozumiane s\u0105 przez MADS jako banki rozszerzonej pami\u0119ci, w\u0142\u0105czane w obszar $4000..$7FFF . Dzia\u0142anie pseudo rozkaz\u00f3w NMB RMB LMB zostaje rozszerzone o wywo\u0142anie makra @BANK_ADD , kt\u00f3re mo\u017cna znale\u017a\u0107 w katalogu ..\\EXAMPLES\\MACROS\\ . W tym trybie dzia\u0142ania MADS potrzebuje deklaracji konkretnych makr: @BANK_ADD @BANK_JMP oraz potrzebuje definicji etykiet o nazwach: @TAB_MEM_BANKS @PROC_ADD_BANK Etykieta @TAB_MEM_BANKS definiuje adres tablicy, z kt\u00f3rej warto\u015bci b\u0119d\u0105 przepisywane do rejestru PORTB odpowiedzialnego za prze\u0142\u0105czanie bank\u00f3w rozszerzonej pami\u0119ci. Mo\u017cemy sobie u\u0142atwi\u0107 spraw\u0119 i skorzysta\u0107 z gotowej procedury wykrywaj\u0105cej banki rozszerzonej pami\u0119ci do\u0142\u0105czonej do MADS , plik ..\\EXAMPLES\\PROCEDURES\\@MEM_DETECT.ASM . Etykieta @PROC_ADD_BANK u\u017cywana jest przez makro @BANK_ADD i definiuje adres pod jakim znajdzie si\u0119 kod programu prze\u0142\u0105czaj\u0105cy bank pami\u0119ci rozszerzonej. Programista mo\u017ce odczyta\u0107 warto\u015b\u0107 licznika bank\u00f3w, kt\u00f3ry zosta\u0142 przypisany etykiecie za pomoc\u0105 operatora = , np.: label ldy #=label W w/w przyk\u0142adzie do rejestru regY zapisali\u015bmy warto\u015b\u0107 licznika bank\u00f3w pami\u0119ci MADS przypisany etykiecie LABEL . Je\u015bli licznik bank\u00f3w MADS = 0 to: kod programu musi znajdowa\u0107 si\u0119 poza obszarem $4000..$7FFF nowo zdefiniowane etykiety w tym obszarze s\u0105 globalne mo\u017cna odwo\u0142ywa\u0107 si\u0119 do wszystkich zdefiniowanych etykiet bez ogranicze\u0144, bez wzgl\u0119du na numer banku skok w obszar banku mo\u017cliwy przy u\u017cyciu makra @BANK_JMP , przyk\u0142ad w pliku ..\\EXAMPLES\\MACROS\\@BANK_JMP.MAC , parametr dla tego makra nie musi by\u0107 poprzedzony operatorem : Je\u015bli licznik bank\u00f3w MADS > 0 to: kod programu musi znajdowa\u0107 si\u0119 w obszarze $4000..$7FFF nowo zdefiniowane etykiety w tym obszarze s\u0105 lokalne mo\u017cna odwo\u0142ywa\u0107 si\u0119 tylko do etykiet globalnych i tych zdefiniowanych w obszarze aktualnego banku pseudo rozkaz LMB NMB powoduje wykonanie makra @BANK_ADD , kt\u00f3re w\u0142\u0105cza nowy bank rozszerzonej pami\u0119ci na podstawie licznika bank\u00f3w MADS-a oraz ustawia nowy adres asemblacji (domy\u015blnie na $4000 ) pseudo rozkaz RMB powoduje wyzerowanie licznika bank\u00f3w pami\u0119ci MADS oraz ustawienie nowego adresu asemblacji poza bankiem (domy\u015blnie na $8000 ) skok w obszar innego banku mo\u017cliwy przy u\u017cyciu makra @BANK_JMP , przyk\u0142ad w pliku ..\\EXAMPLES\\MACROS\\@BANK_JMP , parametr dla tego makra musi by\u0107 poprzedzony operatorem : Przyk\u0142adem wykorzystania tego trybu pracy MADS jest plik ..\\EXAMPLES\\XMS_BANKS.ASM . W tym przyk\u0142adzie kod programu znajduje si\u0119 w dw\u00f3ch r\u00f3\u017cnych bankach rozszerzonej pami\u0119ci i wykonuje si\u0119 jakby by\u0142 jedn\u0105 ca\u0142o\u015bci\u0105.","title":"Sprz\u0119towe banki pami\u0119ci OPT B+"},{"location":"detekcja-cpu/","text":"Detekcja CPU6502, CPU65816 Przyk\u0142ad zaczerpni\u0119ty z tej strony. Program potrafi zdiagnozowa\u0107 obecno\u015b\u0107 jednego z mikroprocesor\u00f3w: 6502 , 65C02 , 65816 . /* How to detect on which CPU the assembler code is running (This information is from Draco, the author of SYSINFO 2.0) You can test on plain 6502-Code if there is a 65c816 CPU, the 16-Bit processor avaible in some XLs as a turbo-board, avaible. Draco told me how to do this: First we make sure, whether we are running on NMOS-CPU (6502) or CMOS (65c02,65c816). I will just show the \"official\" way which doesn`t uses \"illegal opcodes\": */ org $2000 opt c+ DetectCPU lda #$99 clc sed adc #$01 cld beq DetectCPU_CMOS DetectCPU_02 ldx #<_6502 ldy #>_6502 jsr $c642 lda #0 rts DetectCPU_CMOS lda #0 rep #%00000010 ;wyzerowanie bitu Z bne DetectCPU_C816 DetectCPU_C02 ldx #<_65c02 ldy #>_65c02 jsr $c642 lda #1 rts DetectCPU_C816 ldx <_65816 ldy >_65816 jsr $c642 lda #$80 rts _6502 dta c'6502',$9b _65c02 dta c'65c02',$9b _65816 dta c'65816',$9b Nast\u0119pny przyk\u0142ad detekcji CPU , ogranicza si\u0119 do okre\u015blenia obecno\u015bci mikroprocesora 6502 lub 65816 . Program po disasemblacji inaczej wygl\u0105da dla 6502 , inaczej dla 65816 . 6502 rozkaz inc @ uzna za nop , rozkaz xba uzna za sbc # . Dzi\u0119ki takiej przezroczysto\u015bci mo\u017cemy by\u0107 pewni \u017ce program nie wykona \u017cadnej nielegalnej operacji i uczciwie rozpozna w\u0142a\u015bciwy CPU . Pomys\u0142odawc\u0105 tego zwi\u0119z\u0142ego i jak\u017ce sprytnego testu jest Ullrich von Bassewitz . org $2000 opt c+ ; 65816 enabled lda #0 inc @ ; increment accumulator cmp #1 bcc cpu6502 ; ostateczny test na obecnosc 65816 xba ; put $01 in B accu dec @ ; A=$00 if 65C02 xba ; get $01 back if 65816 inc @ ; make $01/$02 cmp #2 bne cpu6502 cpu65816 ldx <text65816 ldy >text65816 jsr $c642 rts cpu6502 ldx <text6502 ldy >text6502 jsr $c642 rts text6502 dta c'6502',$9b text65816 dta c'65816',$9b","title":"Detekcja CPU"},{"location":"detekcja-cpu/#_1","text":"","title":""},{"location":"detekcja-cpu/#detekcja-cpu6502-cpu65816","text":"Przyk\u0142ad zaczerpni\u0119ty z tej strony. Program potrafi zdiagnozowa\u0107 obecno\u015b\u0107 jednego z mikroprocesor\u00f3w: 6502 , 65C02 , 65816 . /* How to detect on which CPU the assembler code is running (This information is from Draco, the author of SYSINFO 2.0) You can test on plain 6502-Code if there is a 65c816 CPU, the 16-Bit processor avaible in some XLs as a turbo-board, avaible. Draco told me how to do this: First we make sure, whether we are running on NMOS-CPU (6502) or CMOS (65c02,65c816). I will just show the \"official\" way which doesn`t uses \"illegal opcodes\": */ org $2000 opt c+ DetectCPU lda #$99 clc sed adc #$01 cld beq DetectCPU_CMOS DetectCPU_02 ldx #<_6502 ldy #>_6502 jsr $c642 lda #0 rts DetectCPU_CMOS lda #0 rep #%00000010 ;wyzerowanie bitu Z bne DetectCPU_C816 DetectCPU_C02 ldx #<_65c02 ldy #>_65c02 jsr $c642 lda #1 rts DetectCPU_C816 ldx <_65816 ldy >_65816 jsr $c642 lda #$80 rts _6502 dta c'6502',$9b _65c02 dta c'65c02',$9b _65816 dta c'65816',$9b Nast\u0119pny przyk\u0142ad detekcji CPU , ogranicza si\u0119 do okre\u015blenia obecno\u015bci mikroprocesora 6502 lub 65816 . Program po disasemblacji inaczej wygl\u0105da dla 6502 , inaczej dla 65816 . 6502 rozkaz inc @ uzna za nop , rozkaz xba uzna za sbc # . Dzi\u0119ki takiej przezroczysto\u015bci mo\u017cemy by\u0107 pewni \u017ce program nie wykona \u017cadnej nielegalnej operacji i uczciwie rozpozna w\u0142a\u015bciwy CPU . Pomys\u0142odawc\u0105 tego zwi\u0119z\u0142ego i jak\u017ce sprytnego testu jest Ullrich von Bassewitz . org $2000 opt c+ ; 65816 enabled lda #0 inc @ ; increment accumulator cmp #1 bcc cpu6502 ; ostateczny test na obecnosc 65816 xba ; put $01 in B accu dec @ ; A=$00 if 65C02 xba ; get $01 back if 65816 inc @ ; make $01/$02 cmp #2 bne cpu6502 cpu65816 ldx <text65816 ldy >text65816 jsr $c642 rts cpu6502 ldx <text6502 ldy >text6502 jsr $c642 rts text6502 dta c'6502',$9b text65816 dta c'65816',$9b","title":"Detekcja CPU6502, CPU65816"},{"location":"dyrektywy-kodu/","text":"Dyrektywy generuj\u0105ce kod 6502 #IF type expression [.OR type expression] [.AND type expression] #ELSE #END #WHILE type expression [.OR type expression] [.AND type expression] #END #CYCLE #N #IF type expression [.OR type expression] [.AND type expression] Dyrektywa #IF to skromniejszy odpowiednik instrukcji IF z j\u0119zyk\u00f3w wy\u017cszego poziomu ( C , Pascal ). Dyrektywy #IF , #ELSE i #END pozwalaj\u0105 na wygenerowanie kodu maszynowego CPU 6502 instrukcji warunkowej IF dla wyznaczonego bloku programu, mo\u017cliwe jest ich zagnie\u017cd\u017canie. Dopuszczalne s\u0105 wszystkie typy .BYTE , .WORD , .LONG , .DWORD , mo\u017cliwe jest \u0142\u0105czenie wi\u0119kszej ilo\u015bci warunk\u00f3w przy pomocy dyrektyw .OR i .AND , nie ma mo\u017cliwo\u015bci okre\u015blenia kolejno\u015bci warto\u015bciowania poprzez nawiasy. Wykonanie dyrektywy #IF zaczyna si\u0119 od obliczenia warto\u015bci wyra\u017cenia prostego tzn. takiego kt\u00f3re sk\u0142ada si\u0119 z dw\u00f3ch argument\u00f3w i jednego operatora (wyra\u017cenia mo\u017cemy \u0142\u0105czy\u0107 dyrektywami .OR lub .AND ). Je\u017celi wyra\u017cenie ma warto\u015b\u0107 r\u00f3\u017cn\u0105 od zera ( TRUE ), to zostanie wykonywany blok programu wyst\u0119puj\u0105cy po dyrektywie #IF . Blok takiego programu automatycznie ko\u0144czony jest instrukcj\u0105 JMP realizuj\u0105c\u0105 skok do nast\u0119pnej instrukcji programu za dyrektyw\u0105 #END w przypadku wyst\u0119powania bloku #ELSE . Je\u017celi wyra\u017cenie ma warto\u015b\u0107 zero ( FALSE ), to wykonywany jest kod programu wyst\u0119puj\u0105cy po dyrektywie #ELSE , je\u015bli dyrektywa #ELSE nie wyst\u0119puje sterowanie przekazywane jest do nast\u0119pnej instrukcji programu za dyrektyw\u0105 #END , np.: #if .byte label>#10 .or .byte label<#5 #end #if .byte label>#100 #else #if .byte label<#200 #end #end #if .byte label>#100 .and .byte label<#200 .or .word lab=temp #end #if .byte @ #end #WHILE type expression [.OR type expression] [.AND type expression] Dyrektywa #WHILE jest odpowiednikiem instrukcji WHILE z j\u0119zyk\u00f3w wy\u017cszego poziomu ( C , Pascal ). Dyrektywy #WHILE i #END pozwalaj\u0105 na wygenerowanie kodu maszynowego CPU 6502 p\u0119tli dla wyznaczonego bloku programu, mo\u017cliwe jest ich zagnie\u017cd\u017canie. Dopuszczalne s\u0105 wszystkie typy .BYTE , .WORD , .LONG , .DWORD , mo\u017cliwe jest \u0142\u0105czenie wi\u0119kszej ilo\u015bci warunk\u00f3w przy pomocy dyrektyw .OR i .AND , nie ma mo\u017cliwo\u015bci okre\u015blenia kolejno\u015bci warto\u015bciowania poprzez nawiasy. Sekwencja dzia\u0142a\u0144 przy wykonywaniu dyrektywy #WHILE jest nast\u0119puj\u0105ca: Oblicz warto\u015b\u0107 wyra\u017cenia i sprawd\u017a, czy jest r\u00f3wne zeru ( FALSE ). je\u017celi tak, to pomi\u0144 krok 2; je\u017celi nie ( TRUE ), przejd\u017a do kroku 2. Wykonaj blok programu ograniczonego dyrektywami #WHILE i #END , nast\u0119pnie przejd\u017a do kroku 1. Je\u017celi pierwsze warto\u015bciowanie wyra\u017cenia wyka\u017ce, \u017ce ma ono warto\u015b\u0107 zero, to blok programu nigdy nie zostanie wykonany i sterowanie przejdzie do nast\u0119pnej instrukcji programu za dyrektyw\u0105 #END #while .byte label>#10 .or .byte label<#5 #end #while .byte label>#100 #while .byte label2<#200 #end #end #while .byte label>#100 .and .byte label<#200 .or .word lab=temp #end Wersja kr\u00f3tka p\u0119tli #WHILE , trwa dop\u00f3ki LABEL<>0 #while .word label #end #CYCLE #N Dyrektywa #CYCLE pozwala wygenerowa\u0107 kod 6502 o zadanej liczbie cykli. Wygenerowany kod nie modyfikuje \u017cadnej kom\u00f3rki pami\u0119ci, ani rejestru CPU , co najwy\u017cej znaczniki. #cycle #17 ; pha 3 cycle ; pla 4 cycle ; pha 3 cycle ; pla 4 cycle ; cmp $00 3 cycle --------- 17 cycle","title":"Dyrektywy generuj\u0105ce kod"},{"location":"dyrektywy-kodu/#dyrektywy-generujace-kod-6502","text":"#IF type expression [.OR type expression] [.AND type expression] #ELSE #END #WHILE type expression [.OR type expression] [.AND type expression] #END #CYCLE #N","title":"Dyrektywy generuj\u0105ce kod 6502"},{"location":"dyrektywy-kodu/#if-type-expression-or-type-expression-and-type-expression","text":"Dyrektywa #IF to skromniejszy odpowiednik instrukcji IF z j\u0119zyk\u00f3w wy\u017cszego poziomu ( C , Pascal ). Dyrektywy #IF , #ELSE i #END pozwalaj\u0105 na wygenerowanie kodu maszynowego CPU 6502 instrukcji warunkowej IF dla wyznaczonego bloku programu, mo\u017cliwe jest ich zagnie\u017cd\u017canie. Dopuszczalne s\u0105 wszystkie typy .BYTE , .WORD , .LONG , .DWORD , mo\u017cliwe jest \u0142\u0105czenie wi\u0119kszej ilo\u015bci warunk\u00f3w przy pomocy dyrektyw .OR i .AND , nie ma mo\u017cliwo\u015bci okre\u015blenia kolejno\u015bci warto\u015bciowania poprzez nawiasy. Wykonanie dyrektywy #IF zaczyna si\u0119 od obliczenia warto\u015bci wyra\u017cenia prostego tzn. takiego kt\u00f3re sk\u0142ada si\u0119 z dw\u00f3ch argument\u00f3w i jednego operatora (wyra\u017cenia mo\u017cemy \u0142\u0105czy\u0107 dyrektywami .OR lub .AND ). Je\u017celi wyra\u017cenie ma warto\u015b\u0107 r\u00f3\u017cn\u0105 od zera ( TRUE ), to zostanie wykonywany blok programu wyst\u0119puj\u0105cy po dyrektywie #IF . Blok takiego programu automatycznie ko\u0144czony jest instrukcj\u0105 JMP realizuj\u0105c\u0105 skok do nast\u0119pnej instrukcji programu za dyrektyw\u0105 #END w przypadku wyst\u0119powania bloku #ELSE . Je\u017celi wyra\u017cenie ma warto\u015b\u0107 zero ( FALSE ), to wykonywany jest kod programu wyst\u0119puj\u0105cy po dyrektywie #ELSE , je\u015bli dyrektywa #ELSE nie wyst\u0119puje sterowanie przekazywane jest do nast\u0119pnej instrukcji programu za dyrektyw\u0105 #END , np.: #if .byte label>#10 .or .byte label<#5 #end #if .byte label>#100 #else #if .byte label<#200 #end #end #if .byte label>#100 .and .byte label<#200 .or .word lab=temp #end #if .byte @ #end","title":"#IF type expression [.OR type expression] [.AND type expression]"},{"location":"dyrektywy-kodu/#while-type-expression-or-type-expression-and-type-expression","text":"Dyrektywa #WHILE jest odpowiednikiem instrukcji WHILE z j\u0119zyk\u00f3w wy\u017cszego poziomu ( C , Pascal ). Dyrektywy #WHILE i #END pozwalaj\u0105 na wygenerowanie kodu maszynowego CPU 6502 p\u0119tli dla wyznaczonego bloku programu, mo\u017cliwe jest ich zagnie\u017cd\u017canie. Dopuszczalne s\u0105 wszystkie typy .BYTE , .WORD , .LONG , .DWORD , mo\u017cliwe jest \u0142\u0105czenie wi\u0119kszej ilo\u015bci warunk\u00f3w przy pomocy dyrektyw .OR i .AND , nie ma mo\u017cliwo\u015bci okre\u015blenia kolejno\u015bci warto\u015bciowania poprzez nawiasy. Sekwencja dzia\u0142a\u0144 przy wykonywaniu dyrektywy #WHILE jest nast\u0119puj\u0105ca: Oblicz warto\u015b\u0107 wyra\u017cenia i sprawd\u017a, czy jest r\u00f3wne zeru ( FALSE ). je\u017celi tak, to pomi\u0144 krok 2; je\u017celi nie ( TRUE ), przejd\u017a do kroku 2. Wykonaj blok programu ograniczonego dyrektywami #WHILE i #END , nast\u0119pnie przejd\u017a do kroku 1. Je\u017celi pierwsze warto\u015bciowanie wyra\u017cenia wyka\u017ce, \u017ce ma ono warto\u015b\u0107 zero, to blok programu nigdy nie zostanie wykonany i sterowanie przejdzie do nast\u0119pnej instrukcji programu za dyrektyw\u0105 #END #while .byte label>#10 .or .byte label<#5 #end #while .byte label>#100 #while .byte label2<#200 #end #end #while .byte label>#100 .and .byte label<#200 .or .word lab=temp #end Wersja kr\u00f3tka p\u0119tli #WHILE , trwa dop\u00f3ki LABEL<>0 #while .word label #end","title":"#WHILE type expression [.OR type expression] [.AND type expression]"},{"location":"dyrektywy-kodu/#cycle-n","text":"Dyrektywa #CYCLE pozwala wygenerowa\u0107 kod 6502 o zadanej liczbie cykli. Wygenerowany kod nie modyfikuje \u017cadnej kom\u00f3rki pami\u0119ci, ani rejestru CPU , co najwy\u017cej znaczniki. #cycle #17 ; pha 3 cycle ; pla 4 cycle ; pha 3 cycle ; pla 4 cycle ; cmp $00 3 cycle --------- 17 cycle","title":"#CYCLE #N"},{"location":"dyrektywy/","text":"Dyrektywy .A8, .A16, .AI8, .AI16 .I8, .I16, .IA8, .IA16 .ASIZE .ISIZE .ALIGN N[,fill] .ARRAY label [elements0][elements1][...] .type [= init_value] .ENDA, [.AEND] .DEF label [= expression] .DEFINE macro_name expression .UNDEF macro_name .ENUM label .ENDE, [.EEND] .ERROR [ERT] 'string'[\"string\"] lub .ERROR [ERT] expression .EXTRN label [,label2,...] type .IF [IFT] expression .ELSE [ELS] .ELSEIF [ELI] expression .ENDIF [EIF] .IFDEF label .IFNDEF label .LOCAL label .ENDL, [.LEND] .LONGA ON|OFF .LONGI ON|OFF .LINK 'filename' .MACRO label .ENDM, [.MEND] :[%%]parameter .EXITM [.EXIT] .NOWARN .PRINT [.ECHO] 'string1','string2'...,value1,value2,... .PAGES [expression] .ENDPG, [.PGEND] .PUBLIC, [.GLOBAL], [.GLOBL] label [,label2,...] .PROC label .ENDP, [.PEND] .REG, .VAR .REPT expression [,parameter1, parameter2, ...] .ENDR, [.REND] .R .RELOC [.BYTE|.WORD] .STRUCT label .ENDS, [.SEND] .SYMBOL label .SEGDEF label address length [bank] .SEGMENT label .ENDSEG .USING, [.USE] proc_name, local_name .VAR var1[=value],var2[=value]... (.BYTE|.WORD|.LONG|.DWORD) .ZPVAR var1, var2... (.BYTE|.WORD|.LONG|.DWORD) .END .EN .BYTE .WORD .LONG .DWORD .OR .AND .XOR .NOT .LO (expression) .HI (expression) .DBYTE words .DS expression .BY [+byte] bytes and/or ASCII .WO words .HE hex bytes .SB [+byte] bytes and/or ASCII .CB [+byte] bytes and/or ASCII .FL floating point numbers .ADR label .LEN label ['filename'] .SIZEOF label .FILESIZE 'filename' .FILEEXISTS 'filename' .GET [index] 'filename'[\"filename\"][*][+-value][,+-ofset[,length]] .WGET [index] .LGET [index] .DGET [index] .PUT [index] = value .SAV [index] ['filename',] length .SYMBOL label Dyrektywa .SYMBOL to odpowiednik pseudo rozkazu SMB z t\u0105 r\u00f3\u017cnic\u0105 \u017ce nie trzeba podawa\u0107 symbolu, symbolem jest etykieta label. Dyrektyw\u0119 .SYMBOL mo\u017cna umieszcza\u0107 w dowolnym miejscu bloku relokowalnego SDX ( BLK RELOC ) w przeciwie\u0144stwie do SMB . Je\u015bli wyst\u0105pi\u0142a dyrektywa .SYMBOL zostanie wygenerowany odpowiedni blok aktualizacji: BLK UPDATE NEW LABEL 'LABEL' Wi\u0119cej na temat deklaracji symboli SDX w rozdziale Definiowanie symbolu SMB . .ALIGN N [,fill] Dyrektywa .ALIGN pozwala wyr\u00f3wna\u0107 adres asemblacji do zadanej warto\u015bci N , oraz potencjalnie wype\u0142ni\u0107 pami\u0119\u0107 zadan\u0105 warto\u015bci\u0105 FILL . Mo\u017cliwe jest wyr\u00f3wnanie adresu asemblacji dla kodu relokowalnego pod warunkiem \u017ce podamy warto\u015b\u0107 wype\u0142nienia pami\u0119ci FILL . Domy\u015blne warto\u015bci to: N=$0100 , FILL=0 . .align .align $400 .align $100,$ff .REPT expression [,parameter1, parameter2, ...] Dyrektywa .REPT jest rozwini\u0119ciem :repeat z t\u0105 r\u00f3\u017cnic\u0105, \u017ce nie jest powtarzana jedna linia, tylko zaznaczony blok programu. Pocz\u0105tek bloku definiowany jest dyrektyw\u0105 .REPT , po niej musi wyst\u0105pi\u0107 warto\u015b\u0107 lub wyra\u017cenie arytmetyczne okre\u015blaj\u0105ce liczb\u0119 powt\u00f3rze\u0144 z zakresu <0..2147483647>, po liczbie powt\u00f3rze\u0144 opcjonalnie mog\u0105 wyst\u0105pi\u0107 parametry. W przeciwie\u0144stwie do makr parametry dla .REPT zawsze s\u0105 najpierw obliczane i dopiero ich wynik jest podstawiany (t\u0105 w\u0142a\u015bciwo\u015b\u0107 mo\u017cna wykorzysta\u0107 do definiowania nowych etykiet). Z parametr\u00f3w w bloku .REPT korzystamy podobnie jak z parametr\u00f3w w bloku .MACRO . Koniec bloku .REPT definiuje dyrektywa .ENDR , przed kt\u00f3r\u0105 nie powinna znajdowa\u0107 si\u0119 \u017cadna etykieta. Dodatkowo w obszarze bloku oznaczonego przez .REPT i .ENDR mamy mo\u017cliwo\u015b\u0107 skorzystania ze znaku hash # (lub dyrektywy .R ), kt\u00f3ry zwraca aktualn\u0105 warto\u015b\u0107 licznika p\u0119tli .REPT (podobnie jak dla :repeat ). .rept 12, #*2, #*3 ; bloki .REPT mo\u017cemy \u0142\u0105czy\u0107 z :rept :+4 dta :1 ; :+4 aby odr\u00f3\u017cni\u0107 licznik powt\u00f3rze\u0144 od parametru :4 :+4 dta :2 .endr .rept 9, # ; definiujemy 9 etykiet label0..label8 label:1 mva #0 $d012+# .endr .PAGES [expression] Dyrektywa .PAGES pozwala okre\u015bli\u0107 liczb\u0119 stron pami\u0119ci w kt\u00f3rych powinien zmie\u015bci\u0107 si\u0119 nasz fragment kodu ograniczony przez <.PAGES .. .ENDPG> (domy\u015blnie jest to warto\u015b\u0107 1). Je\u015bli kod programu przekroczy zadeklarowan\u0105 liczb\u0119 stron pami\u0119ci w\u00f3wczas zostanie wygenerowany komunikat b\u0142\u0119du Page error at ???? . Dyrektywy te mog\u0105 nam pom\u00f3c gdy zale\u017cy nam aby fragment programu mie\u015bci\u0142 si\u0119 w granicach jednej strony pami\u0119ci albo gdy piszemy program mieszcz\u0105cy si\u0119 w dodatkowym banku pami\u0119ci (64 strony pami\u0119ci), np.: org $4000 .pages $40 ... ... .endpg .SEGDEF label address length [attrib] [bank] .SEGMENT label .ENDSEG Dyrektywa .SEGDEF definiuje nowy segment LABEL o adresie pocz\u0105tkowym ADDRESS i d\u0142ugo\u015bci LENGTH , dodatkowo mo\u017cliwe jest okre\u015blenie atrybutu dla segmentu (R-read, W-rite, RW-ReadWrite - domy\u015blnie) oraz przypisanie numeru wirtualnego banku BANK (domy\u015blnie BANK=0). Dyrektywa .SEGMENT aktywuje zapis kodu wynikowego segmentu LABEL . W przypadku przekroczenia zadanej d\u0142ugo\u015bci segmentu zostanie wygenerowany komunikat b\u0142\u0119du Segment LABEL error at ADDRESS . Dyrektywa .ENDSEG ko\u0144czy zapis do aktualnego segmentu, przywraca zapis do g\u0142\u00f3wnego bloku programu. .segdef sdata adr0 $100 .segdef test adr1 $40 org $2000 nop .cb 'ALA' .segment sdata nop .endseg lda #0 .segment test ldx #0 clc dta c'ATARI' .endseg adr0 .ds $100 adr1 .ds $40 .END Dyrektywa .END mo\u017ce by\u0107 zamiennie u\u017cywana z dyrektywami .ENDP , .ENDM , .ENDS , .ENDA , .ENDL , .ENDR , .ENDPG , .ENDW , .ENDT .VAR var1[=value1],var2[=value2]... (.BYTE|.WORD|.LONG|.DWORD) [=address] Dyrektywa .VAR s\u0142u\u017cy do deklaracji i inicjacji zmiennych w g\u0142\u00f3wnym bloku programu oraz w blokach .PROC i .LOCAL . MADS nie wykorzystuje informacji na temat takich zmiennych w dalszych operacjach z udzia\u0142em pseudo i makro rozkaz\u00f3w. Dopuszczalne typy zmiennych to .BYTE , .WORD , .LONG , .DWORD i ich wielokrotno\u015bci, a tak\u017ce typy zadeklarowane przez .STRUCT i .ENUM np.: .var a,b , c,d .word ; 4 zmienne typu .WORD .var a,b,f :256 .byte ; 3 zmienne ka\u017cda o wielko\u015bci 256 bajt\u00f3w .var c=5,d=2,f=$123344 .dword ; 3 zmienne .DWORD o warto\u015bciach 5, 2, $123344 .var .byte i=1, j=3 ; 2 zmienne typu .BYTE o warto\u015bciach 1, 3 .var a,b,c,d .byte = $a000 ; 4 zmienne typu .BYTE o adresach kolejno $A000, $A001, $A002, $A003 .var .byte a,b,c,d = $a0 ; 4 zmienne typu bajt, ostatnia zmiennna 'D' o warto\u015bci $A0 ; !!! dla takiego zapisu nie ma mo\u017cliwo\u015bci okre\u015blenia adresu alokacji zmiennych .proc name .var .word p1,p2,p3 ; deklaracja trzech zmiennych typu .WORD .endp .local .var a,b,c .byte lda a ldx b ldy c .endl .struct Point ; nowy typ danych strukturalnych POINT x .byte y .byte .ends .var a,b Point ; deklaracja zmiennych strukturalnych .var Point c,d ; odpowiednik sk\u0142adni 'label DTA POINT' Tak zadeklarowane zmienne zostan\u0105 fizycznie alokowane dopiero na ko\u0144cu bloku w kt\u00f3rym zosta\u0142y zadeklarowane, po dyrektywie .ENDP , .ENDL ( .END ). Wyj\u0105tek stanowi blok .PROC gdzie zmienne zadeklarowane przez .VAR zawsze alokowane s\u0105 przed dyrektyw\u0105 .ENDP niezale\u017cnie czy w bloku procedury wyst\u0105pi\u0142y jakiekolwiek dodatkowe bloki .LOCAL ze zmiennymi deklarowanymi przez .VAR .ZPVAR var1, var2... (.BYTE|.WORD|.LONG|.DWORD) [=address] Dyrektywa .ZPVAR s\u0142u\u017cy do deklaracji zmiennych strony zerowej w g\u0142\u00f3wnym bloku programu oraz w blokach .PROC i .LOCAL . Pr\u00f3ba przypisania warto\u015bci (zaincjowania) takiej zmiennej spowoduje wygenerowanie komunikatu ostrze\u017cenia Uninitialized variable . MADS nie wykorzystuje informacji na temat takich zmiennych w dalszych operacjach z udzia\u0142em pseudo i makro rozkaz\u00f3w. Dopuszczalne typy zmiennych to .BYTE , .WORD , .LONG , .DWORD i ich wielokrotno\u015bci, a tak\u017ce typy zadeklarowane przez .STRUCT i .ENUM np.: .zpvar a b c d .word = $80 ; 4 zmienne typu .WORD o adresie pocz\u0105tkowym $0080 .zpvar i j .byte ; dwie kolejne zmienne od adresu $0080+8 .zpvar .word a,b ; 2 zmienne typu .WORD ; !!! dla takiej sk\u0142adni nie ma mo\u017cliwo\u015bci okre\u015blenia adresu zmiennych .struct Point ; nowy typ danych strukturalnych POINT x .byte y .byte .ends .zpvar a,b Point ; deklaracja zmiennych strukturalnych .zpvar Point c,d ; odpowiednik sk\u0142adni 'label DTA POINT' Tak zadeklarowanym zmiennym strony zerowej zostan\u0105 przypisane adresy dopiero na ko\u0144cu bloku w kt\u00f3rym zosta\u0142y zadeklarowane, po dyrektywie .ENDP , .ENDL ( .END ). Wyj\u0105tek stanowi blok .PROC gdzie zmiennym zadeklarowanym przez .ZPVAR adresy przypisywane s\u0105 przed dyrektyw\u0105 .ENDP niezale\u017cnie czy w bloku procedury wyst\u0105pi\u0142y jakiekolwiek dodatkowe bloki .LOCAL ze zmiennymi deklarowanymi przez .ZPVAR . Przy pierwszym u\u017cyciu dyrektywy .ZPVAR nale\u017cy zaincjowa\u0107 adres jaki b\u0119dzie przypisywany kolejnym zmiennym (domy\u015blnym adresem jest $0080). .zpvar = $40 Z ka\u017cd\u0105 kolejn\u0105 zmienn\u0105 adres ten jest automatycznie zwi\u0119kszany przez MADS -a, w przypadku gdy adresy zmiennych powt\u00f3rz\u0105 si\u0119 zostanie wygenerowany komunikat ostrze\u017cenia Access violations at address $xxxx . W przypadku przekroczenia zakresu strony zerowej zostaje wygenerowany komunikat b\u0142\u0119du Value out of range . .PRINT [.ECHO] Powoduje wypisanie na ekranie podanej jako parametr warto\u015bci wyra\u017cenia lub ci\u0105gu znakowego ograniczonego apostrofami ' ' lub \" \" , np.: .print \"End: \",*,'..',$8000-* .echo \"End: \",*,'..',$8000-* .ERROR [ERT] 'string'[\"string\"] | .ERROR [ERT] expression Dyrektywa .ERROR i pseudo rozkaz ERT maj\u0105 to samo znaczenie. Zatrzymuj\u0105 asemblacj\u0119 programu oraz wy\u015bwietlaj\u0105 komunikat podany jako parametr, ograniczony apostrofami ' ' lub \" \" . Je\u015bli parametrem jest wyra\u017cenie logiczne, w\u00f3wczas asemblacja zostanie zatrzymana gdy warto\u015b\u0107 wyra\u017cenia logicznego jest prawd\u0105 (komunikat User error ), np.: ert \"halt\" ; ERROR: halt .error \"halt\" ert *>$7fff ; ERROR: User error .error *>$7fff .BYTE, .WORD, .LONG, .DWORD W/w dyrektywy s\u0142u\u017c\u0105 do oznaczenia dopuszczalnych typ\u00f3w parametr\u00f3w w deklaracji parametr\u00f3w procedury ( .BYTE , .WORD , .LONG , .DWORD ). Mo\u017cliwe jest tak\u017ce ich u\u017cycie w celu definicji danych, w zast\u0119pstwie pseudo rozkazu DTA . .proc test (.word tmp,a,b .byte value) .byte \"atari\",5,22 .word 12,$FFFF .long $34518F .dword $11223344 .DBYTE Definicja danych typu WORD w odwrotnej kolejno\u015bci tzn. najpierw starszy bajt, nast\u0119pnie m\u0142odszy bajt. .DBYTE $1234,-1,1 ; 12 34 FF FF 00 01 [label] .DS expression | label .DS [elements0][elements1][...] .type Ta dyrektywa zapo\u017cyczona zosta\u0142a z MAC'65 , pozwala zarezerwowa\u0107 pami\u0119\u0107 bez jej uprzedniej inicjalizacji. Jest to odpowiednik pseudo rozkazu ORG *+expression . Dyrektywy .DS nie mo\u017cna u\u017cywa\u0107 w kodzie relokowalnym podobnie jak ORG -a. U\u017cycie nawias\u00f3w kwadratowych w wyra\u017ceniu umo\u017cliwia rezerwowanie pami\u0119ci jako tablicy, podobnie jak .ARRAY , wymagane jest w\u00f3wczas podanie etykiety. U\u017cycie dyrektywy .DS w bloku relokowalnym Sparta DOS X wymusi utworzenie bloku pustego blk empty . purpose: reserves space for data without initializing then space to any particular value(s). usage: [label] .DS expression label .DS [elements0][elements1][...] .TYPE Using .DS expression is exactly equivalent of using ORG *+expression . That is, the label (if it is given) is set equal to the current value of the location counter. Then then value of the expression is added to then location counter. BUFFERLEN .DS 1 ;reserve a single byte BUFFER .DS [256] ;reserve 256 bytes as array [0..255] .BY [+byte] bytes and/or ASCII Store byte values in memory. ASCII strings can be specified by enclosing the string in either single or double quotes. If the first character of the operand field is a + , then the following byte will be used as a constant and added to all remaining bytes of the instruction. .BY +$80 1 10 $10 'Hello' $9B will generate: 81 8A 90 C8 E5 EC EC EF 1B Values in .BY statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type. .WO words Stores words in memory. Multiple words can be entered. Values in .WO statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type. .HE hex bytes Store hex bytes in memory. This is a convenient method to enter strings of hex bytes, since it does not require the use of the '$' character. The bytes are still separated by spaces however, which I feel makes a much more readable layout than the 'all run together' form of hex statement that some other assemblers use. .HE 0 55 AA FF Values in .HE statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type. .SB [+byte] bytes and/or ASCII This is in the same format as the .BY pseudo-op, except that it will convert all bytes into ATASCII screen codes before storing them. The ATASCII conversion is done before any constant is added with the '+' modifier. Values in .SB statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type. .CB [+byte] bytes and/or ASCII This is in the same format as the .BY pseudo-op, except that the last character on the line will be EOR'ed with $80. Values in .CB statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type. .FL floating point numbers Stores 6-byte BCD floating point numbers for use with the OS FP ROM routines. Values in .FL statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type. .EN Dyrektywa .EN jest odpowiednikiem pseudo rozkazu END , oznacza koniec asemblowanego bloku programu. This is an optional pseudo-op to mark the end of assembly. It can be placed before the end of your source file to prevent a portion of it from being assembled. .ADR label Dyrektywa .ADR zwraca warto\u015b\u0107 etykiety LABEL przed zmian\u0105 adresu asemblacji (mo\u017cliwe jest umieszczenie nazwy etykiety LABEL pomi\u0119dzy nawiasami okr\u0105g\u0142ymi lub kwadratowymi), np.: org $2000 .proc tb,$1000 tmp lda #0 .endp lda .adr tb.tmp ; = $2000 lda tb.tmp ; = $1000 .LEN label ['filename'], .SIZEOF label, .FILESIZE 'filename' Dyrektywa .LEN zwraca d\u0142ugo\u015b\u0107 (wyra\u017con\u0105 w bajtach) bloku .PROC , .ARRAY , .LOCAL , .STRUCT lub d\u0142ugo\u015b\u0107 pliku o nazwie 'filename' . Etykieta LABEL to nazwa bloku .PROC , .ARRAY , .LOCAL lub .STRUCT (mo\u017cliwe jest umieszczenie nazwy etykiety LABEL pomi\u0119dzy nawiasami okr\u0105g\u0142ymi lub kwadratowymi), np.: label .array [255] .dword .enda dta a(.len label) ; = $400 .proc wait lda:cmp:req 20 rts .endp dta .sizeof wait ; = 7 Dyrektywy .SIZEOF i .FILESIZE to alternatywne nazwy dla .LEN , mo\u017cna u\u017cywa\u0107 ich zamiennie zale\u017cnie od upodoba\u0144 programuj\u0105cego. .FILEEXISTS 'filename' Dyrektywa .FILEEXISTS zwraca '1' gdy plik 'filename' istnieje w przeciwnym wypadku zwraca warto\u015b\u0107 '0' np.: ift .fileexists 'filename' .print 'true' els .print 'false' eif .DEFINE macro_name expression Dyrektywa .DEFINE pozwala zdefiniowa\u0107 jedno-liniowe makro MACRO_NAME . Dopuszczalnych jest dziewi\u0119\u0107 parametr\u00f3w %%1.%%9 ( :1..:9 ) reprezentowanych w ten sam spos\u00f3b jak dla makr .MACRO , poprzez znaki %% lub znak : . Nazwy literowe parametr\u00f3w nie s\u0105 akceptowane, nie ma mo\u017cliwo\u015bci u\u017cycia znaku podzia\u0142u linii \\ . .define poke mva #%%2 %%1 poke(712, 100) Makro jedno-liniowe .DEFINE mo\u017cna wielokrotnie definiowa\u0107 w trakcie jednego przebiegu asemblacji. .define pisz %%1+%%2 .print pisz(712, 100) .define pisz %%1-%%2 .print pisz(712, 100) .UNDEF macro_name Dyrektywa .UNDEF usuwa definicj\u0119 jedno-liniowego makra MACRO_NAME . .define poke mva #%%2 %%1 .undef poke .DEF label [= expression] Dyrektywa .DEF pozwala sprawdzi\u0107 obecno\u015b\u0107 definicji etykiety LABEL lub j\u0105 zdefiniowa\u0107. Je\u015bli etykieta zosta\u0142a zdefiniowana zwraca warto\u015b\u0107 1 czyli TRUE , w przeciwnym wypadku zwraca 0 czyli FALSE . Mo\u017cliwe jest umieszczenie nazwy etykiety LABEL pomi\u0119dzy nawiasami okr\u0105g\u0142ymi lub kwadratowymi, np.: ift .not(.def label) .def label eif Definiowane etykiety s\u0105 zasi\u0119gu aktualnego obszaru lokalnego, je\u015bli chcemy zdefiniowa\u0107 etykiety globalne stawiamy przed etykiet\u0105 znak : , np. .local test :10 .def :label%%1 .endl This unary operator tests whether the following label has been defined yet, returning TRUE or FALSE as appropriate. CAUTION: Defining a label AFTER the use of a .DEF which references it can be dangerous, particularly if the .DEF is used in a .IF directive. .IFDEF label Dyrektywa .IFDEF jest kr\u00f3tszym odpowiednikiem warunku .IF .DEF LABEL .ifdef label jsr proc1 .else jsr proc2 .endif .IFNDEF label Dyrektywa .IFNDEF jest kr\u00f3tszym odpowiednikiem warunku .IF .NOT .DEF LABEL .ifndef label clc .else sec .endif Dla n/w przyk\u0142adu asemblacja bloku .IFNDEF ( .IF ) b\u0119dzie mia\u0142a miejsce tylko w pierwszym przebiegu, je\u015bli umie\u015bcimy w takim bloku jakikolwiek kod programu na pewno nie zostanie on wygenerowany do pliku, definicje etykiet zostan\u0105 przeprowadzone tylko w pierwszym przebiegu, je\u015bli wyst\u0105pi\u0142y jakiekolwiek b\u0142\u0119dy zwi\u0105zane z ich definiowaniem dowiemy si\u0119 o nich dopiero w momencie pr\u00f3by odwo\u0142ania do takich etykiet, b\u0119dzie to komunikat b\u0142\u0119du Undeclared label LABEL_NAME .ifndef label .def label lda #0 ; ten rozkaz nie zostanie zasemblowany, tylko ostatni przebieg asemblacji generuje kod temp = 100 ; etykieta TEMP zostanie zdefiniowana tylko w 1 przebiegu asemblacji .endif .NOWARN Dyrektywa .NOWARN wy\u0142\u0105cza komunikat ostrze\u017cenia dla aktualnie asemblowanego wiersza programu. .nowarn .proc temp ; nie zostanie wygenerowane ostrze\u017cenie 'Unreferenced procedure TEMP' .endp .USING, [.USE] Dyrektywa .USING ( .USE ) pozwala okre\u015bli\u0107 dodatkow\u0105 \u015bcie\u017ck\u0119 poszukiwa\u0144 dla nazw etykiet. Dzia\u0142anie .USING ( .USE ) obowi\u0105zuje w aktualnej przestrzeni nazw jak i kolejnych zawieraj\u0105cych si\u0119 w tej przestrzeni. .local move tmp lda #0 hlp sta $a000 .local move2 tmp2 ldx #0 hlp2 stx $b000 .endl .endl .local main .use move.move2 lda tmp2 .use move lda tmp .endl .GET [index] 'filename'... [.BYTE, .WORD, .LONG, .DWORD] .WGET [index] | .LGET [index] | .DGET [index] .GET jest odpowiednikiem pseudo rozkazu INS (podobna sk\u0142adnia), z t\u0105 r\u00f3\u017cnic\u0105 \u017ce plik nie jest do\u0142\u0105czany do asemblowanego pliku tylko \u0142adowany do pami\u0119ci MADS -a. Ta dyrektywa pozwala wczyta\u0107 okre\u015blony plik do pami\u0119ci MADS -a i odwo\u0142ywa\u0107 si\u0119 do bajt\u00f3w tego pliku jak do tablicy jednowymiarowej. .get 'file' ; wczytanie pliku do tablicy MADS-a .get [5] 'file' ; wczytanie pliku do tablicy MADS-a od indeksu = 5 .get 'file',0,3 ; wczytanie do tablicy MADS-a 3-ech warto\u015bci lda #.get[7] ; odczytanie 7 bajtu z tablicy MADS-a adres = .get[2]+.get[3]<<8 ; 2 i 3 bajt w nag\u0142\u00f3wku pliku DOS zawiera informacje o adresie \u0142adowania adres = .wget[2] ; word tmp = .lget[5] ; long ?x = .dget[11] ; dword Przy pomocy dyrektyw .GET , .PUT mo\u017cna odczyta\u0107 np modu\u0142 Theta Music Composer ( TMC ) i dokona\u0107 jego relokacji. Realizuje to za\u0142\u0105czone do MADS -a makro z katalogu ../EXAMPLES/MSX/TMC_PLAYER/tmc_relocator.mac. Dopuszczalny zakres warto\u015bci dla INDEX = <0..65535> . Warto\u015bci odczytywane przez .GET s\u0105 typu BYTE . Warto\u015bci odczytywane przez .WGET s\u0105 typu WORD . Warto\u015bci odczytywane przez .LGET s\u0105 typu LONG . Warto\u015bci odczytywane przez .DGET s\u0105 typu DWORD . .PUT [index] = value Dyrektywa .PUT pozwala odwo\u0142a\u0107 si\u0119 do tablicy jednowymiarowej w pami\u0119ci MADS -a i zapisa\u0107 w niej warto\u015b\u0107 typu BYTE . Jest to ta sama tablica do kt\u00f3rej dyrektywa .GET zapisuje plik. Dopuszczalny zakres warto\u015bci dla INDEX = <0..65535>. .put [5] = 12 ; zapisanie wartosci 12 w talicy MADS-a na pozycji 5-ej .SAV [index] ['filename',] length Dyrektywa .SAV pozwala zapisa\u0107 bufor u\u017cywany przez dyrektywy .GET , .PUT do pliku zewn\u0119trznego lub do\u0142\u0105czenie do aktualnie asemblowanego. .sav ?length ; do\u0142\u0105czenie do asemblowanego pliku zawarto\u015bci bufora [0..?length-1] .sav [200] 256 ; do\u0142\u0105czenie do asemblowanego pliku zawarto\u015bci bufora [200..200+256-1] .sav [6] 'filename',32 ; zapisanie do pliku FILENAME zawarto\u015bci bufora [6..6+32-1] Dopuszczalny zakres warto\u015bci dla INDEX = <0..65535>. .OR, .AND, .XOR, .NOT W/w dyrektywy to odpowiedniki operator\u00f3w logicznych || ( .OR ), && ( .AND ), ^ ( .XOR ), ! ( .NOT ). .LO (expression), .HI (expression) W/w dyrektywy to odpowiedniki operator\u00f3w odpowiednio < (m\u0142odszy bajt) i > (starszy bajt). .IF, .ELSE, .ELSEIF, .ENDIF .IF [IFT] expression .ELSE [ELS] .ELSEIF [ELI] expression .ENDIF [EIF] W/w dyrektywy i pseudo rozkazy wp\u0142ywaj\u0105 na przebieg asemblacji (mo\u017cna ich u\u017cywa\u0107 zamiennie), np.: .IF .NOT .DEF label_name label_name = 1 .ENDIF .IF [.NOT .DEF label_name] .AND [.NOT .DEF label_name2] label_name = 1 label_name2 = 2 .ENDIF W w/w przyk\u0142adzie nawiasy (kwadratowe lub okr\u0105g\u0142e) s\u0105 konieczno\u015bci\u0105, ich brak spowodowa\u0142by \u017ce dla pierwszej dyrektywy .DEF parametrem by\u0142aby nazwa etykiety label_name.AND.NOT.DEFlabel_name2 (spacje s\u0105 pomijane, a znak kropki akceptowany w nazwie etykiety).","title":"Dyrektywy"},{"location":"dyrektywy/#dyrektywy","text":".A8, .A16, .AI8, .AI16 .I8, .I16, .IA8, .IA16 .ASIZE .ISIZE .ALIGN N[,fill] .ARRAY label [elements0][elements1][...] .type [= init_value] .ENDA, [.AEND] .DEF label [= expression] .DEFINE macro_name expression .UNDEF macro_name .ENUM label .ENDE, [.EEND] .ERROR [ERT] 'string'[\"string\"] lub .ERROR [ERT] expression .EXTRN label [,label2,...] type .IF [IFT] expression .ELSE [ELS] .ELSEIF [ELI] expression .ENDIF [EIF] .IFDEF label .IFNDEF label .LOCAL label .ENDL, [.LEND] .LONGA ON|OFF .LONGI ON|OFF .LINK 'filename' .MACRO label .ENDM, [.MEND] :[%%]parameter .EXITM [.EXIT] .NOWARN .PRINT [.ECHO] 'string1','string2'...,value1,value2,... .PAGES [expression] .ENDPG, [.PGEND] .PUBLIC, [.GLOBAL], [.GLOBL] label [,label2,...] .PROC label .ENDP, [.PEND] .REG, .VAR .REPT expression [,parameter1, parameter2, ...] .ENDR, [.REND] .R .RELOC [.BYTE|.WORD] .STRUCT label .ENDS, [.SEND] .SYMBOL label .SEGDEF label address length [bank] .SEGMENT label .ENDSEG .USING, [.USE] proc_name, local_name .VAR var1[=value],var2[=value]... (.BYTE|.WORD|.LONG|.DWORD) .ZPVAR var1, var2... (.BYTE|.WORD|.LONG|.DWORD) .END .EN .BYTE .WORD .LONG .DWORD .OR .AND .XOR .NOT .LO (expression) .HI (expression) .DBYTE words .DS expression .BY [+byte] bytes and/or ASCII .WO words .HE hex bytes .SB [+byte] bytes and/or ASCII .CB [+byte] bytes and/or ASCII .FL floating point numbers .ADR label .LEN label ['filename'] .SIZEOF label .FILESIZE 'filename' .FILEEXISTS 'filename' .GET [index] 'filename'[\"filename\"][*][+-value][,+-ofset[,length]] .WGET [index] .LGET [index] .DGET [index] .PUT [index] = value .SAV [index] ['filename',] length","title":"Dyrektywy"},{"location":"dyrektywy/#symbol-label","text":"Dyrektywa .SYMBOL to odpowiednik pseudo rozkazu SMB z t\u0105 r\u00f3\u017cnic\u0105 \u017ce nie trzeba podawa\u0107 symbolu, symbolem jest etykieta label. Dyrektyw\u0119 .SYMBOL mo\u017cna umieszcza\u0107 w dowolnym miejscu bloku relokowalnego SDX ( BLK RELOC ) w przeciwie\u0144stwie do SMB . Je\u015bli wyst\u0105pi\u0142a dyrektywa .SYMBOL zostanie wygenerowany odpowiedni blok aktualizacji: BLK UPDATE NEW LABEL 'LABEL' Wi\u0119cej na temat deklaracji symboli SDX w rozdziale Definiowanie symbolu SMB .","title":".SYMBOL label"},{"location":"dyrektywy/#align-n-fill","text":"Dyrektywa .ALIGN pozwala wyr\u00f3wna\u0107 adres asemblacji do zadanej warto\u015bci N , oraz potencjalnie wype\u0142ni\u0107 pami\u0119\u0107 zadan\u0105 warto\u015bci\u0105 FILL . Mo\u017cliwe jest wyr\u00f3wnanie adresu asemblacji dla kodu relokowalnego pod warunkiem \u017ce podamy warto\u015b\u0107 wype\u0142nienia pami\u0119ci FILL . Domy\u015blne warto\u015bci to: N=$0100 , FILL=0 . .align .align $400 .align $100,$ff","title":".ALIGN N [,fill]"},{"location":"dyrektywy/#rept-expression-parameter1-parameter2","text":"Dyrektywa .REPT jest rozwini\u0119ciem :repeat z t\u0105 r\u00f3\u017cnic\u0105, \u017ce nie jest powtarzana jedna linia, tylko zaznaczony blok programu. Pocz\u0105tek bloku definiowany jest dyrektyw\u0105 .REPT , po niej musi wyst\u0105pi\u0107 warto\u015b\u0107 lub wyra\u017cenie arytmetyczne okre\u015blaj\u0105ce liczb\u0119 powt\u00f3rze\u0144 z zakresu <0..2147483647>, po liczbie powt\u00f3rze\u0144 opcjonalnie mog\u0105 wyst\u0105pi\u0107 parametry. W przeciwie\u0144stwie do makr parametry dla .REPT zawsze s\u0105 najpierw obliczane i dopiero ich wynik jest podstawiany (t\u0105 w\u0142a\u015bciwo\u015b\u0107 mo\u017cna wykorzysta\u0107 do definiowania nowych etykiet). Z parametr\u00f3w w bloku .REPT korzystamy podobnie jak z parametr\u00f3w w bloku .MACRO . Koniec bloku .REPT definiuje dyrektywa .ENDR , przed kt\u00f3r\u0105 nie powinna znajdowa\u0107 si\u0119 \u017cadna etykieta. Dodatkowo w obszarze bloku oznaczonego przez .REPT i .ENDR mamy mo\u017cliwo\u015b\u0107 skorzystania ze znaku hash # (lub dyrektywy .R ), kt\u00f3ry zwraca aktualn\u0105 warto\u015b\u0107 licznika p\u0119tli .REPT (podobnie jak dla :repeat ). .rept 12, #*2, #*3 ; bloki .REPT mo\u017cemy \u0142\u0105czy\u0107 z :rept :+4 dta :1 ; :+4 aby odr\u00f3\u017cni\u0107 licznik powt\u00f3rze\u0144 od parametru :4 :+4 dta :2 .endr .rept 9, # ; definiujemy 9 etykiet label0..label8 label:1 mva #0 $d012+# .endr","title":".REPT expression [,parameter1, parameter2, ...]"},{"location":"dyrektywy/#pages-expression","text":"Dyrektywa .PAGES pozwala okre\u015bli\u0107 liczb\u0119 stron pami\u0119ci w kt\u00f3rych powinien zmie\u015bci\u0107 si\u0119 nasz fragment kodu ograniczony przez <.PAGES .. .ENDPG> (domy\u015blnie jest to warto\u015b\u0107 1). Je\u015bli kod programu przekroczy zadeklarowan\u0105 liczb\u0119 stron pami\u0119ci w\u00f3wczas zostanie wygenerowany komunikat b\u0142\u0119du Page error at ???? . Dyrektywy te mog\u0105 nam pom\u00f3c gdy zale\u017cy nam aby fragment programu mie\u015bci\u0142 si\u0119 w granicach jednej strony pami\u0119ci albo gdy piszemy program mieszcz\u0105cy si\u0119 w dodatkowym banku pami\u0119ci (64 strony pami\u0119ci), np.: org $4000 .pages $40 ... ... .endpg","title":".PAGES [expression]"},{"location":"dyrektywy/#segdef-label-address-length-attrib-bank","text":"","title":".SEGDEF label address length [attrib] [bank]"},{"location":"dyrektywy/#segment-label","text":"","title":".SEGMENT label"},{"location":"dyrektywy/#endseg","text":"Dyrektywa .SEGDEF definiuje nowy segment LABEL o adresie pocz\u0105tkowym ADDRESS i d\u0142ugo\u015bci LENGTH , dodatkowo mo\u017cliwe jest okre\u015blenie atrybutu dla segmentu (R-read, W-rite, RW-ReadWrite - domy\u015blnie) oraz przypisanie numeru wirtualnego banku BANK (domy\u015blnie BANK=0). Dyrektywa .SEGMENT aktywuje zapis kodu wynikowego segmentu LABEL . W przypadku przekroczenia zadanej d\u0142ugo\u015bci segmentu zostanie wygenerowany komunikat b\u0142\u0119du Segment LABEL error at ADDRESS . Dyrektywa .ENDSEG ko\u0144czy zapis do aktualnego segmentu, przywraca zapis do g\u0142\u00f3wnego bloku programu. .segdef sdata adr0 $100 .segdef test adr1 $40 org $2000 nop .cb 'ALA' .segment sdata nop .endseg lda #0 .segment test ldx #0 clc dta c'ATARI' .endseg adr0 .ds $100 adr1 .ds $40","title":".ENDSEG"},{"location":"dyrektywy/#end","text":"Dyrektywa .END mo\u017ce by\u0107 zamiennie u\u017cywana z dyrektywami .ENDP , .ENDM , .ENDS , .ENDA , .ENDL , .ENDR , .ENDPG , .ENDW , .ENDT","title":".END"},{"location":"dyrektywy/#var-var1value1var2value2-bytewordlongdword-address","text":"Dyrektywa .VAR s\u0142u\u017cy do deklaracji i inicjacji zmiennych w g\u0142\u00f3wnym bloku programu oraz w blokach .PROC i .LOCAL . MADS nie wykorzystuje informacji na temat takich zmiennych w dalszych operacjach z udzia\u0142em pseudo i makro rozkaz\u00f3w. Dopuszczalne typy zmiennych to .BYTE , .WORD , .LONG , .DWORD i ich wielokrotno\u015bci, a tak\u017ce typy zadeklarowane przez .STRUCT i .ENUM np.: .var a,b , c,d .word ; 4 zmienne typu .WORD .var a,b,f :256 .byte ; 3 zmienne ka\u017cda o wielko\u015bci 256 bajt\u00f3w .var c=5,d=2,f=$123344 .dword ; 3 zmienne .DWORD o warto\u015bciach 5, 2, $123344 .var .byte i=1, j=3 ; 2 zmienne typu .BYTE o warto\u015bciach 1, 3 .var a,b,c,d .byte = $a000 ; 4 zmienne typu .BYTE o adresach kolejno $A000, $A001, $A002, $A003 .var .byte a,b,c,d = $a0 ; 4 zmienne typu bajt, ostatnia zmiennna 'D' o warto\u015bci $A0 ; !!! dla takiego zapisu nie ma mo\u017cliwo\u015bci okre\u015blenia adresu alokacji zmiennych .proc name .var .word p1,p2,p3 ; deklaracja trzech zmiennych typu .WORD .endp .local .var a,b,c .byte lda a ldx b ldy c .endl .struct Point ; nowy typ danych strukturalnych POINT x .byte y .byte .ends .var a,b Point ; deklaracja zmiennych strukturalnych .var Point c,d ; odpowiednik sk\u0142adni 'label DTA POINT' Tak zadeklarowane zmienne zostan\u0105 fizycznie alokowane dopiero na ko\u0144cu bloku w kt\u00f3rym zosta\u0142y zadeklarowane, po dyrektywie .ENDP , .ENDL ( .END ). Wyj\u0105tek stanowi blok .PROC gdzie zmienne zadeklarowane przez .VAR zawsze alokowane s\u0105 przed dyrektyw\u0105 .ENDP niezale\u017cnie czy w bloku procedury wyst\u0105pi\u0142y jakiekolwiek dodatkowe bloki .LOCAL ze zmiennymi deklarowanymi przez .VAR","title":".VAR var1[=value1],var2[=value2]... (.BYTE|.WORD|.LONG|.DWORD) [=address]"},{"location":"dyrektywy/#zpvar-var1-var2-bytewordlongdword-address","text":"Dyrektywa .ZPVAR s\u0142u\u017cy do deklaracji zmiennych strony zerowej w g\u0142\u00f3wnym bloku programu oraz w blokach .PROC i .LOCAL . Pr\u00f3ba przypisania warto\u015bci (zaincjowania) takiej zmiennej spowoduje wygenerowanie komunikatu ostrze\u017cenia Uninitialized variable . MADS nie wykorzystuje informacji na temat takich zmiennych w dalszych operacjach z udzia\u0142em pseudo i makro rozkaz\u00f3w. Dopuszczalne typy zmiennych to .BYTE , .WORD , .LONG , .DWORD i ich wielokrotno\u015bci, a tak\u017ce typy zadeklarowane przez .STRUCT i .ENUM np.: .zpvar a b c d .word = $80 ; 4 zmienne typu .WORD o adresie pocz\u0105tkowym $0080 .zpvar i j .byte ; dwie kolejne zmienne od adresu $0080+8 .zpvar .word a,b ; 2 zmienne typu .WORD ; !!! dla takiej sk\u0142adni nie ma mo\u017cliwo\u015bci okre\u015blenia adresu zmiennych .struct Point ; nowy typ danych strukturalnych POINT x .byte y .byte .ends .zpvar a,b Point ; deklaracja zmiennych strukturalnych .zpvar Point c,d ; odpowiednik sk\u0142adni 'label DTA POINT' Tak zadeklarowanym zmiennym strony zerowej zostan\u0105 przypisane adresy dopiero na ko\u0144cu bloku w kt\u00f3rym zosta\u0142y zadeklarowane, po dyrektywie .ENDP , .ENDL ( .END ). Wyj\u0105tek stanowi blok .PROC gdzie zmiennym zadeklarowanym przez .ZPVAR adresy przypisywane s\u0105 przed dyrektyw\u0105 .ENDP niezale\u017cnie czy w bloku procedury wyst\u0105pi\u0142y jakiekolwiek dodatkowe bloki .LOCAL ze zmiennymi deklarowanymi przez .ZPVAR . Przy pierwszym u\u017cyciu dyrektywy .ZPVAR nale\u017cy zaincjowa\u0107 adres jaki b\u0119dzie przypisywany kolejnym zmiennym (domy\u015blnym adresem jest $0080). .zpvar = $40 Z ka\u017cd\u0105 kolejn\u0105 zmienn\u0105 adres ten jest automatycznie zwi\u0119kszany przez MADS -a, w przypadku gdy adresy zmiennych powt\u00f3rz\u0105 si\u0119 zostanie wygenerowany komunikat ostrze\u017cenia Access violations at address $xxxx . W przypadku przekroczenia zakresu strony zerowej zostaje wygenerowany komunikat b\u0142\u0119du Value out of range .","title":".ZPVAR var1, var2... (.BYTE|.WORD|.LONG|.DWORD) [=address]"},{"location":"dyrektywy/#print-echo","text":"Powoduje wypisanie na ekranie podanej jako parametr warto\u015bci wyra\u017cenia lub ci\u0105gu znakowego ograniczonego apostrofami ' ' lub \" \" , np.: .print \"End: \",*,'..',$8000-* .echo \"End: \",*,'..',$8000-*","title":".PRINT [.ECHO]"},{"location":"dyrektywy/#error-ert-stringstring-error-ert-expression","text":"Dyrektywa .ERROR i pseudo rozkaz ERT maj\u0105 to samo znaczenie. Zatrzymuj\u0105 asemblacj\u0119 programu oraz wy\u015bwietlaj\u0105 komunikat podany jako parametr, ograniczony apostrofami ' ' lub \" \" . Je\u015bli parametrem jest wyra\u017cenie logiczne, w\u00f3wczas asemblacja zostanie zatrzymana gdy warto\u015b\u0107 wyra\u017cenia logicznego jest prawd\u0105 (komunikat User error ), np.: ert \"halt\" ; ERROR: halt .error \"halt\" ert *>$7fff ; ERROR: User error .error *>$7fff","title":".ERROR [ERT] 'string'[\"string\"] | .ERROR [ERT] expression"},{"location":"dyrektywy/#byte-word-long-dword","text":"W/w dyrektywy s\u0142u\u017c\u0105 do oznaczenia dopuszczalnych typ\u00f3w parametr\u00f3w w deklaracji parametr\u00f3w procedury ( .BYTE , .WORD , .LONG , .DWORD ). Mo\u017cliwe jest tak\u017ce ich u\u017cycie w celu definicji danych, w zast\u0119pstwie pseudo rozkazu DTA . .proc test (.word tmp,a,b .byte value) .byte \"atari\",5,22 .word 12,$FFFF .long $34518F .dword $11223344","title":".BYTE, .WORD, .LONG, .DWORD"},{"location":"dyrektywy/#dbyte","text":"Definicja danych typu WORD w odwrotnej kolejno\u015bci tzn. najpierw starszy bajt, nast\u0119pnie m\u0142odszy bajt. .DBYTE $1234,-1,1 ; 12 34 FF FF 00 01","title":".DBYTE"},{"location":"dyrektywy/#label-ds-expression-label-ds-elements0elements1-type","text":"Ta dyrektywa zapo\u017cyczona zosta\u0142a z MAC'65 , pozwala zarezerwowa\u0107 pami\u0119\u0107 bez jej uprzedniej inicjalizacji. Jest to odpowiednik pseudo rozkazu ORG *+expression . Dyrektywy .DS nie mo\u017cna u\u017cywa\u0107 w kodzie relokowalnym podobnie jak ORG -a. U\u017cycie nawias\u00f3w kwadratowych w wyra\u017ceniu umo\u017cliwia rezerwowanie pami\u0119ci jako tablicy, podobnie jak .ARRAY , wymagane jest w\u00f3wczas podanie etykiety. U\u017cycie dyrektywy .DS w bloku relokowalnym Sparta DOS X wymusi utworzenie bloku pustego blk empty . purpose: reserves space for data without initializing then space to any particular value(s). usage: [label] .DS expression label .DS [elements0][elements1][...] .TYPE Using .DS expression is exactly equivalent of using ORG *+expression . That is, the label (if it is given) is set equal to the current value of the location counter. Then then value of the expression is added to then location counter. BUFFERLEN .DS 1 ;reserve a single byte BUFFER .DS [256] ;reserve 256 bytes as array [0..255]","title":"[label] .DS expression | label .DS [elements0][elements1][...] .type"},{"location":"dyrektywy/#by-byte-bytes-andor-ascii","text":"Store byte values in memory. ASCII strings can be specified by enclosing the string in either single or double quotes. If the first character of the operand field is a + , then the following byte will be used as a constant and added to all remaining bytes of the instruction. .BY +$80 1 10 $10 'Hello' $9B will generate: 81 8A 90 C8 E5 EC EC EF 1B Values in .BY statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.","title":".BY [+byte] bytes and/or ASCII"},{"location":"dyrektywy/#wo-words","text":"Stores words in memory. Multiple words can be entered. Values in .WO statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.","title":".WO words"},{"location":"dyrektywy/#he-hex-bytes","text":"Store hex bytes in memory. This is a convenient method to enter strings of hex bytes, since it does not require the use of the '$' character. The bytes are still separated by spaces however, which I feel makes a much more readable layout than the 'all run together' form of hex statement that some other assemblers use. .HE 0 55 AA FF Values in .HE statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.","title":".HE hex bytes"},{"location":"dyrektywy/#sb-byte-bytes-andor-ascii","text":"This is in the same format as the .BY pseudo-op, except that it will convert all bytes into ATASCII screen codes before storing them. The ATASCII conversion is done before any constant is added with the '+' modifier. Values in .SB statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.","title":".SB [+byte] bytes and/or ASCII"},{"location":"dyrektywy/#cb-byte-bytes-andor-ascii","text":"This is in the same format as the .BY pseudo-op, except that the last character on the line will be EOR'ed with $80. Values in .CB statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.","title":".CB [+byte] bytes and/or ASCII"},{"location":"dyrektywy/#fl-floating-point-numbers","text":"Stores 6-byte BCD floating point numbers for use with the OS FP ROM routines. Values in .FL statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.","title":".FL floating point numbers"},{"location":"dyrektywy/#en","text":"Dyrektywa .EN jest odpowiednikiem pseudo rozkazu END , oznacza koniec asemblowanego bloku programu. This is an optional pseudo-op to mark the end of assembly. It can be placed before the end of your source file to prevent a portion of it from being assembled.","title":".EN"},{"location":"dyrektywy/#adr-label","text":"Dyrektywa .ADR zwraca warto\u015b\u0107 etykiety LABEL przed zmian\u0105 adresu asemblacji (mo\u017cliwe jest umieszczenie nazwy etykiety LABEL pomi\u0119dzy nawiasami okr\u0105g\u0142ymi lub kwadratowymi), np.: org $2000 .proc tb,$1000 tmp lda #0 .endp lda .adr tb.tmp ; = $2000 lda tb.tmp ; = $1000","title":".ADR label"},{"location":"dyrektywy/#len-label-filename-sizeof-label-filesize-filename","text":"Dyrektywa .LEN zwraca d\u0142ugo\u015b\u0107 (wyra\u017con\u0105 w bajtach) bloku .PROC , .ARRAY , .LOCAL , .STRUCT lub d\u0142ugo\u015b\u0107 pliku o nazwie 'filename' . Etykieta LABEL to nazwa bloku .PROC , .ARRAY , .LOCAL lub .STRUCT (mo\u017cliwe jest umieszczenie nazwy etykiety LABEL pomi\u0119dzy nawiasami okr\u0105g\u0142ymi lub kwadratowymi), np.: label .array [255] .dword .enda dta a(.len label) ; = $400 .proc wait lda:cmp:req 20 rts .endp dta .sizeof wait ; = 7 Dyrektywy .SIZEOF i .FILESIZE to alternatywne nazwy dla .LEN , mo\u017cna u\u017cywa\u0107 ich zamiennie zale\u017cnie od upodoba\u0144 programuj\u0105cego.","title":".LEN label ['filename'], .SIZEOF label, .FILESIZE 'filename'"},{"location":"dyrektywy/#fileexists-filename","text":"Dyrektywa .FILEEXISTS zwraca '1' gdy plik 'filename' istnieje w przeciwnym wypadku zwraca warto\u015b\u0107 '0' np.: ift .fileexists 'filename' .print 'true' els .print 'false' eif","title":".FILEEXISTS 'filename'"},{"location":"dyrektywy/#define-macro_name-expression","text":"Dyrektywa .DEFINE pozwala zdefiniowa\u0107 jedno-liniowe makro MACRO_NAME . Dopuszczalnych jest dziewi\u0119\u0107 parametr\u00f3w %%1.%%9 ( :1..:9 ) reprezentowanych w ten sam spos\u00f3b jak dla makr .MACRO , poprzez znaki %% lub znak : . Nazwy literowe parametr\u00f3w nie s\u0105 akceptowane, nie ma mo\u017cliwo\u015bci u\u017cycia znaku podzia\u0142u linii \\ . .define poke mva #%%2 %%1 poke(712, 100) Makro jedno-liniowe .DEFINE mo\u017cna wielokrotnie definiowa\u0107 w trakcie jednego przebiegu asemblacji. .define pisz %%1+%%2 .print pisz(712, 100) .define pisz %%1-%%2 .print pisz(712, 100)","title":".DEFINE macro_name expression"},{"location":"dyrektywy/#undef-macro_name","text":"Dyrektywa .UNDEF usuwa definicj\u0119 jedno-liniowego makra MACRO_NAME . .define poke mva #%%2 %%1 .undef poke","title":".UNDEF macro_name"},{"location":"dyrektywy/#def-label-expression","text":"Dyrektywa .DEF pozwala sprawdzi\u0107 obecno\u015b\u0107 definicji etykiety LABEL lub j\u0105 zdefiniowa\u0107. Je\u015bli etykieta zosta\u0142a zdefiniowana zwraca warto\u015b\u0107 1 czyli TRUE , w przeciwnym wypadku zwraca 0 czyli FALSE . Mo\u017cliwe jest umieszczenie nazwy etykiety LABEL pomi\u0119dzy nawiasami okr\u0105g\u0142ymi lub kwadratowymi, np.: ift .not(.def label) .def label eif Definiowane etykiety s\u0105 zasi\u0119gu aktualnego obszaru lokalnego, je\u015bli chcemy zdefiniowa\u0107 etykiety globalne stawiamy przed etykiet\u0105 znak : , np. .local test :10 .def :label%%1 .endl This unary operator tests whether the following label has been defined yet, returning TRUE or FALSE as appropriate. CAUTION: Defining a label AFTER the use of a .DEF which references it can be dangerous, particularly if the .DEF is used in a .IF directive.","title":".DEF label [= expression]"},{"location":"dyrektywy/#ifdef-label","text":"Dyrektywa .IFDEF jest kr\u00f3tszym odpowiednikiem warunku .IF .DEF LABEL .ifdef label jsr proc1 .else jsr proc2 .endif","title":".IFDEF label"},{"location":"dyrektywy/#ifndef-label","text":"Dyrektywa .IFNDEF jest kr\u00f3tszym odpowiednikiem warunku .IF .NOT .DEF LABEL .ifndef label clc .else sec .endif Dla n/w przyk\u0142adu asemblacja bloku .IFNDEF ( .IF ) b\u0119dzie mia\u0142a miejsce tylko w pierwszym przebiegu, je\u015bli umie\u015bcimy w takim bloku jakikolwiek kod programu na pewno nie zostanie on wygenerowany do pliku, definicje etykiet zostan\u0105 przeprowadzone tylko w pierwszym przebiegu, je\u015bli wyst\u0105pi\u0142y jakiekolwiek b\u0142\u0119dy zwi\u0105zane z ich definiowaniem dowiemy si\u0119 o nich dopiero w momencie pr\u00f3by odwo\u0142ania do takich etykiet, b\u0119dzie to komunikat b\u0142\u0119du Undeclared label LABEL_NAME .ifndef label .def label lda #0 ; ten rozkaz nie zostanie zasemblowany, tylko ostatni przebieg asemblacji generuje kod temp = 100 ; etykieta TEMP zostanie zdefiniowana tylko w 1 przebiegu asemblacji .endif","title":".IFNDEF label"},{"location":"dyrektywy/#nowarn","text":"Dyrektywa .NOWARN wy\u0142\u0105cza komunikat ostrze\u017cenia dla aktualnie asemblowanego wiersza programu. .nowarn .proc temp ; nie zostanie wygenerowane ostrze\u017cenie 'Unreferenced procedure TEMP' .endp","title":".NOWARN"},{"location":"dyrektywy/#using-use","text":"Dyrektywa .USING ( .USE ) pozwala okre\u015bli\u0107 dodatkow\u0105 \u015bcie\u017ck\u0119 poszukiwa\u0144 dla nazw etykiet. Dzia\u0142anie .USING ( .USE ) obowi\u0105zuje w aktualnej przestrzeni nazw jak i kolejnych zawieraj\u0105cych si\u0119 w tej przestrzeni. .local move tmp lda #0 hlp sta $a000 .local move2 tmp2 ldx #0 hlp2 stx $b000 .endl .endl .local main .use move.move2 lda tmp2 .use move lda tmp .endl","title":".USING, [.USE]"},{"location":"dyrektywy/#get-index-filename-byte-word-long-dword","text":"","title":".GET [index] 'filename'... [.BYTE, .WORD, .LONG, .DWORD]"},{"location":"dyrektywy/#wget-index-lget-index-dget-index","text":".GET jest odpowiednikiem pseudo rozkazu INS (podobna sk\u0142adnia), z t\u0105 r\u00f3\u017cnic\u0105 \u017ce plik nie jest do\u0142\u0105czany do asemblowanego pliku tylko \u0142adowany do pami\u0119ci MADS -a. Ta dyrektywa pozwala wczyta\u0107 okre\u015blony plik do pami\u0119ci MADS -a i odwo\u0142ywa\u0107 si\u0119 do bajt\u00f3w tego pliku jak do tablicy jednowymiarowej. .get 'file' ; wczytanie pliku do tablicy MADS-a .get [5] 'file' ; wczytanie pliku do tablicy MADS-a od indeksu = 5 .get 'file',0,3 ; wczytanie do tablicy MADS-a 3-ech warto\u015bci lda #.get[7] ; odczytanie 7 bajtu z tablicy MADS-a adres = .get[2]+.get[3]<<8 ; 2 i 3 bajt w nag\u0142\u00f3wku pliku DOS zawiera informacje o adresie \u0142adowania adres = .wget[2] ; word tmp = .lget[5] ; long ?x = .dget[11] ; dword Przy pomocy dyrektyw .GET , .PUT mo\u017cna odczyta\u0107 np modu\u0142 Theta Music Composer ( TMC ) i dokona\u0107 jego relokacji. Realizuje to za\u0142\u0105czone do MADS -a makro z katalogu ../EXAMPLES/MSX/TMC_PLAYER/tmc_relocator.mac. Dopuszczalny zakres warto\u015bci dla INDEX = <0..65535> . Warto\u015bci odczytywane przez .GET s\u0105 typu BYTE . Warto\u015bci odczytywane przez .WGET s\u0105 typu WORD . Warto\u015bci odczytywane przez .LGET s\u0105 typu LONG . Warto\u015bci odczytywane przez .DGET s\u0105 typu DWORD .","title":".WGET [index] | .LGET [index] | .DGET [index]"},{"location":"dyrektywy/#put-index-value","text":"Dyrektywa .PUT pozwala odwo\u0142a\u0107 si\u0119 do tablicy jednowymiarowej w pami\u0119ci MADS -a i zapisa\u0107 w niej warto\u015b\u0107 typu BYTE . Jest to ta sama tablica do kt\u00f3rej dyrektywa .GET zapisuje plik. Dopuszczalny zakres warto\u015bci dla INDEX = <0..65535>. .put [5] = 12 ; zapisanie wartosci 12 w talicy MADS-a na pozycji 5-ej","title":".PUT [index] = value"},{"location":"dyrektywy/#sav-index-filename-length","text":"Dyrektywa .SAV pozwala zapisa\u0107 bufor u\u017cywany przez dyrektywy .GET , .PUT do pliku zewn\u0119trznego lub do\u0142\u0105czenie do aktualnie asemblowanego. .sav ?length ; do\u0142\u0105czenie do asemblowanego pliku zawarto\u015bci bufora [0..?length-1] .sav [200] 256 ; do\u0142\u0105czenie do asemblowanego pliku zawarto\u015bci bufora [200..200+256-1] .sav [6] 'filename',32 ; zapisanie do pliku FILENAME zawarto\u015bci bufora [6..6+32-1] Dopuszczalny zakres warto\u015bci dla INDEX = <0..65535>.","title":".SAV [index] ['filename',] length"},{"location":"dyrektywy/#or-and-xor-not","text":"W/w dyrektywy to odpowiedniki operator\u00f3w logicznych || ( .OR ), && ( .AND ), ^ ( .XOR ), ! ( .NOT ).","title":".OR, .AND, .XOR, .NOT"},{"location":"dyrektywy/#lo-expression-hi-expression","text":"W/w dyrektywy to odpowiedniki operator\u00f3w odpowiednio < (m\u0142odszy bajt) i > (starszy bajt).","title":".LO (expression), .HI (expression)"},{"location":"dyrektywy/#if-else-elseif-endif","text":".IF [IFT] expression .ELSE [ELS] .ELSEIF [ELI] expression .ENDIF [EIF] W/w dyrektywy i pseudo rozkazy wp\u0142ywaj\u0105 na przebieg asemblacji (mo\u017cna ich u\u017cywa\u0107 zamiennie), np.: .IF .NOT .DEF label_name label_name = 1 .ENDIF .IF [.NOT .DEF label_name] .AND [.NOT .DEF label_name2] label_name = 1 label_name2 = 2 .ENDIF W w/w przyk\u0142adzie nawiasy (kwadratowe lub okr\u0105g\u0142e) s\u0105 konieczno\u015bci\u0105, ich brak spowodowa\u0142by \u017ce dla pierwszej dyrektywy .DEF parametrem by\u0142aby nazwa etykiety label_name.AND.NOT.DEFlabel_name2 (spacje s\u0105 pomijane, a znak kropki akceptowany w nazwie etykiety).","title":".IF, .ELSE, .ELSEIF, .ENDIF"},{"location":"etykiety/","text":"Etykiety Etykiety zdefiniowane w programie mog\u0105 posiada\u0107 zasi\u0119g lokalny lub globalny, w zale\u017cno\u015bci od miejsca w jakim zosta\u0142y zdefiniowane. Opr\u00f3cz tego mo\u017cna zdefiniowa\u0107 etykiety tymczasowe, kt\u00f3re tak\u017ce mog\u0105 posiada\u0107 zasi\u0119g lokalny lub globalny. zasi\u0119g globalny etykiety oznacza, \u017ce jest ona widoczna z ka\u017cdego miejsca w programie, niezale\u017cnie czy jest to makro .MACRO , procedura .PROC czy obszar lokalny .LOCAL . zasi\u0119g lokalny etykiety oznacza, \u017ce jest ona widoczna tylko w konkretnie zdefiniowanym obszarze, np. przez dyrektywy: .MACRO , .PROC , .LOCAL . etykiety musz\u0105 zaczyna\u0107 si\u0119 znakiem 'A'..'Z','a'..'z','_','?','@' pozosta\u0142e dopuszczalne znaki etykiety to 'A'..'Z','a'..'z','0'..'9','_','?','@' etykiety wyst\u0119puj\u0105 zawsze na pocz\u0105tku wiersza etykiety poprzedzone \"bia\u0142ymi znakami\" powinny ko\u0144czy\u0107 si\u0119 znakiem : aby unikn\u0105\u0107 b\u0142\u0119dnej interpretacji takiej etykiety jako makra w adresowaniu etykieta mo\u017ce by\u0107 poprzedzona znakiem : informuje to asembler \u017ce odwo\u0142ujemy si\u0119 do etykiety w bloku g\u0142\u00f3wnym programu (odwo\u0142ujemy si\u0119 do etykiety globalnej) Przyk\u0142ad definicji etykiet: ?nazwa EQU $A000 ; definicja etykiety tymczasowej globalnej nazwa = * ; definicja etykiety globalnej nazwa2=12 ; definicja etykiety globalnej @?nazwa EQU 'a'+32 ; definicja etykiety globalnej name: equ 12 ; definicja etykiety globalnej nie zaczynaj\u0105cej si\u0119 od pierwszego znaku wiersza nazwa: = 'v' ; definicja etykiety globalnej nie zaczynaj\u0105cej si\u0119 od pierwszego znaku wiersza W por\u00f3wnaniu do QA/XASM dosz\u0142a mo\u017cliwo\u015b\u0107 u\u017cycia znaku zapytania ? i @ w nazwach etykiet. U\u017cycie znaku kropki . w nazwie etykiety jest dopuszczalne, jednak nie zalecane. Znak kropki zarezerwowany jest do oznaczania rozszerzenia mnemonika, do oznaczenia dyrektyw assemblera, w adresowaniu nowych struktur MADS . Znak kropki . na pocz\u0105tku nazwy etykiety sugeruje \u017ce jest to dyrektywa assemblera, natomiast znak zapytania ? na pocz\u0105tku etykiety oznacza etykiet\u0119 tymczasow\u0105 , tak\u0105 kt\u00f3rej warto\u015b\u0107 mo\u017ce si\u0119 zmienia\u0107 wielokrotnie w trakcie asemblacji. Anonimowe W celu zapewnienia przejrzysto\u015bci kodu u\u017cycie etykiet anonimowych ograniczone jest tylko dla skok\u00f3w warunkowych oraz do 10-u wyst\u0105pie\u0144 w prz\u00f3d/ty\u0142. Dla etykiet anonimowych zosta\u0142 zarezerwowany znak @ , po takim znaku musi wyst\u0105pi\u0107 znak okre\u015blaj\u0105cy skok w prz\u00f3d + lub w ty\u0142 - . Dodatkowo mo\u017cna okre\u015bli\u0107 numer wyst\u0105pienia etykiety anonimowej z zakresu [0..9] , brak numeru wyst\u0105pienia oznacza domy\u015blnie 0 . @+[0..9] ; forward @-[0..9] ; backward @+ ; @+0 @- ; @-0 @ dex ---- ------- bne @+ | -- | stx $80 | | | @ lda #0 | -- | bne @- --- | bne @-1 --------- ldx #6 @ lda:cmp:req 20 @ dex bne @-1 Lokalne Ka\u017cda definicja etykiety w obr\u0119bie makra .MACRO , procedury .PROC czy obszaru lokalnego .LOCAL domy\u015blnie jest zasi\u0119gu lokalnego, innymi s\u0142owy jest lokalna. Takich etykiet u\u017cytkownik nie musi dodatkowo oznacza\u0107. Etykiety lokalne definiujemy u\u017cywaj\u0105c n/w r\u00f3wnowa\u017cnych pseudo rozkaz\u00f3w: EQU = Aby mie\u0107 dost\u0119p do etykiet o zasi\u0119gu globalnym (czyli zdefiniowanych poza makrem .MACRO , procedur\u0105 .PROC , obszarem lokalnym .LOCAL ) i o takich samych nazwach jak lokalne, nale\u017cy u\u017cy\u0107 operatora : , np.: lp ldx #0 ; definicja globalna etykiety LP test test test .macro lda :lp ; znak ':' przed etykiet\u0105 odczyta warto\u015b\u0107 etykiety globalnej LP sta lp+1 ; odwo\u0142anie do etykiety lokalnej LP w obszarze makra lp lda #0 ; definicja etykiety lokalnej LP w obszarze makra .endm W w/w przyk\u0142adzie wyst\u0119puj\u0105 definicje etykiet o tych samych nazwach (LP), lecz ka\u017cda z nich ma inn\u0105 warto\u015b\u0107 i jest innego zasi\u0119gu. Globalne Ka\u017cda definicja etykiety dokonana w g\u0142\u00f3wnym bloku programu poza obszarem makra .MACRO , procedury .PROC czy obszaru lokalnego .LOCAL jest zasi\u0119gu globalnego, innymi s\u0142owy jest globalna. Etykiety globalne definiujemy u\u017cywaj\u0105c n/w r\u00f3wnowa\u017cnych pseudo rozkaz\u00f3w: EQU = lub dyrektywy .DEF o sk\u0142adni: .DEF :label [= expression] Dyrektywa .DEF umo\u017cliwia zdefiniowanie etykiety w aktualnym obszarze lokalnym, znak : na pocz\u0105tku etykiety sygnalizuje etykiet\u0119 globaln\u0105. U\u017cycie dyrektywy o sk\u0142adni .DEF :label pozwala na zdefiniowanie etykiety globalnej z pomini\u0119ciem aktualnego poziomu lokalno\u015bci. Znak dwukropka : na pocz\u0105tku etykiety ma specjalne znaczenie, informuje \u017ce odwo\u0142ujemy si\u0119 do etykiety globalnej, czyli etykiety z g\u0142\u00f3wnego bloku programu z pomini\u0119ciem wszystkich poziom\u00f3w lokalno\u015bci. Wi\u0119cej informacji na temat u\u017cycia dyrektywy .DEF w rozdziale Dyrektywa .DEF Przyk\u0142ad definicji etykiet globalnych: lab equ * lab2 equ $4000 ?tmp = 0 ?tmp += 40 .proc name .def :?nazwa = $A000 .def :nazwa=20 .local lok1 .def :@?nazw = 'a'+32 .endl .endp Przyk\u0142adem zastosowania definicji etykiety globalnej tymczasowej jest m.in. makro @CALL , przyk\u0142ad w pliku ..\\EXAMPLES\\MACROS\\@CALL.MAC , w kt\u00f3rym wyst\u0119puje definicja etykiety tymczasowej ?@STACK_OFFSET . Jest ona p\u00f3\u017aniej wykorzystywana przez pozosta\u0142e makra wywo\u0142ywane z poziomu makra @CALL , a s\u0142u\u017cy do optymalizacji programu odk\u0142adaj\u0105cego parametry na stos programowy. @CALL .macro .def ?@stack_offset = 0 ; definicja etykiety globalnej tymczasowej ?@stack_offset ... ... @CALL_@ .macro sta @stack_address+?@stack_offset,x .def ?@stack_offset = ?@stack_offset + 1 ; modyfikacja etykiety ?@stack_offset .endm Tymczasowe Definicja etykiety tymczasowej posiada t\u0105 w\u0142a\u015bciwo\u015b\u0107, \u017ce jej warto\u015b\u0107 mo\u017ce ulega\u0107 zmianie wielokrotnie nawet podczas jednego przebiegu asemblacji. Normalnie pr\u00f3ba ponownej definicji etykiety ko\u0144czy si\u0119 komunikatem Label declared twice . Nie b\u0119dzie takiego komunikatu je\u015bli jest to etykieta tymczasowa. Zasi\u0119g etykiet tymczasowych uzale\u017cniony jest od obszaru w jakim etykieta zosta\u0142a zdefiniowana. Etykiety tymczasowe mog\u0105 posiada\u0107 zasi\u0119g lokalny ( Etykiety lokalne ) lub globalny ( Etykiety globalne ). ?label Etykiet\u0119 tymczasow\u0105 definiuje u\u017cytkownik poprzez umieszczenie na pocz\u0105tku nazwy etykiety znaku zapytania ? , np.: ?label Etykiet tymczasowych nie powinno u\u017cywa\u0107 si\u0119 do nazw procedur .PROC , makr .MACRO , obszar\u00f3w lokalnych .LOCAL , struktur .STRUCT , tablic .ARRAY . Etykiety tymczasowe definiujemy u\u017cywaj\u0105c n/w r\u00f3wnowa\u017cnych pseudo rozkaz\u00f3w: EQU = Dodatkowo mo\u017cemy je modyfikowa\u0107 za pomoc\u0105 znanych z C operator\u00f3w: -= expression += expression -- ++ W/w operatory modyfikuj\u0105ce dotycz\u0105 tylko etykiet tymczasowych, pr\u00f3ba ich u\u017cycia dla innego typu etykiety sko\u0144czy si\u0119 komunikatem b\u0142\u0119du Improper syntax . Przyk\u0142ad u\u017cycia etykiet tymczasowych: ?loc = $567 ?loc2 = ?loc+$2000 lda ?loc sta ?loc2 ?loc = $123 lda ?loc label SET value Pseudorozkaz SET umo\u017cliwia redefinicj\u0119 etykiety LABEL , dzia\u0142a ze zwyk\u0142ymi etykietami tzn. takimi kt\u00f3re nie maj\u0105 pierwszego znaku w nazwie ? . Etykiet zdefiniowanych przez SET nie mo\u017cna p\u00f3\u017aniej definiowa\u0107 inaczej ni\u017c przez SET . tmp set 1 tmp = 2 Dla w/w przyk\u0142adu powstanie niesko\u0144czona p\u0119tla Infinite loop , prawid\u0142owo powinno by\u0107 : tmp set 1 tmp set 2 Automodyfikacji Etykieta d\u0142u\u017csza ni\u017c 1 znak, umieszczona po mnemoniku i zako\u0144czona znakiem : definiuje adres automodyfikacji kodu. lda label:#$00 add plus:#$00 lda src:$ff00,y sta dst:$ff00,y W/w przyk\u0142ady s\u0105 odpowiednikiem kodu: lda #$00 label equ *-1 add #$00 plus equ *-1 lda $ff00,y src equ *-2 sta $ff00,y dst equ *-2 Lokalne w stylu MAE Opcja OPT ?+ informuje MADS aby etykiety zaczynaj\u0105ce si\u0119 znakiem ? interpretowa\u0142 jako etykiety lokalne tak jak robi to MAE . Domy\u015blnie etykiety zaczynaj\u0105ce si\u0119 znakiem ? traktowane s\u0105 przez MADS jako etykiety tymczasowe. Przyk\u0142ad u\u017cycia etykiet lokalnych w stylu MAE : opt ?+ org $2000 local1 ldx #7 ?lop sta $a000,x dex bpl ?lop local2 ldx #7 ?lop sta $b000,x dex bpl ?lop","title":"Etykiety"},{"location":"etykiety/#etykiety","text":"Etykiety zdefiniowane w programie mog\u0105 posiada\u0107 zasi\u0119g lokalny lub globalny, w zale\u017cno\u015bci od miejsca w jakim zosta\u0142y zdefiniowane. Opr\u00f3cz tego mo\u017cna zdefiniowa\u0107 etykiety tymczasowe, kt\u00f3re tak\u017ce mog\u0105 posiada\u0107 zasi\u0119g lokalny lub globalny. zasi\u0119g globalny etykiety oznacza, \u017ce jest ona widoczna z ka\u017cdego miejsca w programie, niezale\u017cnie czy jest to makro .MACRO , procedura .PROC czy obszar lokalny .LOCAL . zasi\u0119g lokalny etykiety oznacza, \u017ce jest ona widoczna tylko w konkretnie zdefiniowanym obszarze, np. przez dyrektywy: .MACRO , .PROC , .LOCAL . etykiety musz\u0105 zaczyna\u0107 si\u0119 znakiem 'A'..'Z','a'..'z','_','?','@' pozosta\u0142e dopuszczalne znaki etykiety to 'A'..'Z','a'..'z','0'..'9','_','?','@' etykiety wyst\u0119puj\u0105 zawsze na pocz\u0105tku wiersza etykiety poprzedzone \"bia\u0142ymi znakami\" powinny ko\u0144czy\u0107 si\u0119 znakiem : aby unikn\u0105\u0107 b\u0142\u0119dnej interpretacji takiej etykiety jako makra w adresowaniu etykieta mo\u017ce by\u0107 poprzedzona znakiem : informuje to asembler \u017ce odwo\u0142ujemy si\u0119 do etykiety w bloku g\u0142\u00f3wnym programu (odwo\u0142ujemy si\u0119 do etykiety globalnej) Przyk\u0142ad definicji etykiet: ?nazwa EQU $A000 ; definicja etykiety tymczasowej globalnej nazwa = * ; definicja etykiety globalnej nazwa2=12 ; definicja etykiety globalnej @?nazwa EQU 'a'+32 ; definicja etykiety globalnej name: equ 12 ; definicja etykiety globalnej nie zaczynaj\u0105cej si\u0119 od pierwszego znaku wiersza nazwa: = 'v' ; definicja etykiety globalnej nie zaczynaj\u0105cej si\u0119 od pierwszego znaku wiersza W por\u00f3wnaniu do QA/XASM dosz\u0142a mo\u017cliwo\u015b\u0107 u\u017cycia znaku zapytania ? i @ w nazwach etykiet. U\u017cycie znaku kropki . w nazwie etykiety jest dopuszczalne, jednak nie zalecane. Znak kropki zarezerwowany jest do oznaczania rozszerzenia mnemonika, do oznaczenia dyrektyw assemblera, w adresowaniu nowych struktur MADS . Znak kropki . na pocz\u0105tku nazwy etykiety sugeruje \u017ce jest to dyrektywa assemblera, natomiast znak zapytania ? na pocz\u0105tku etykiety oznacza etykiet\u0119 tymczasow\u0105 , tak\u0105 kt\u00f3rej warto\u015b\u0107 mo\u017ce si\u0119 zmienia\u0107 wielokrotnie w trakcie asemblacji.","title":"Etykiety"},{"location":"etykiety/#anonimowe","text":"W celu zapewnienia przejrzysto\u015bci kodu u\u017cycie etykiet anonimowych ograniczone jest tylko dla skok\u00f3w warunkowych oraz do 10-u wyst\u0105pie\u0144 w prz\u00f3d/ty\u0142. Dla etykiet anonimowych zosta\u0142 zarezerwowany znak @ , po takim znaku musi wyst\u0105pi\u0107 znak okre\u015blaj\u0105cy skok w prz\u00f3d + lub w ty\u0142 - . Dodatkowo mo\u017cna okre\u015bli\u0107 numer wyst\u0105pienia etykiety anonimowej z zakresu [0..9] , brak numeru wyst\u0105pienia oznacza domy\u015blnie 0 . @+[0..9] ; forward @-[0..9] ; backward @+ ; @+0 @- ; @-0 @ dex ---- ------- bne @+ | -- | stx $80 | | | @ lda #0 | -- | bne @- --- | bne @-1 --------- ldx #6 @ lda:cmp:req 20 @ dex bne @-1","title":"Anonimowe"},{"location":"etykiety/#lokalne","text":"Ka\u017cda definicja etykiety w obr\u0119bie makra .MACRO , procedury .PROC czy obszaru lokalnego .LOCAL domy\u015blnie jest zasi\u0119gu lokalnego, innymi s\u0142owy jest lokalna. Takich etykiet u\u017cytkownik nie musi dodatkowo oznacza\u0107. Etykiety lokalne definiujemy u\u017cywaj\u0105c n/w r\u00f3wnowa\u017cnych pseudo rozkaz\u00f3w: EQU = Aby mie\u0107 dost\u0119p do etykiet o zasi\u0119gu globalnym (czyli zdefiniowanych poza makrem .MACRO , procedur\u0105 .PROC , obszarem lokalnym .LOCAL ) i o takich samych nazwach jak lokalne, nale\u017cy u\u017cy\u0107 operatora : , np.: lp ldx #0 ; definicja globalna etykiety LP test test test .macro lda :lp ; znak ':' przed etykiet\u0105 odczyta warto\u015b\u0107 etykiety globalnej LP sta lp+1 ; odwo\u0142anie do etykiety lokalnej LP w obszarze makra lp lda #0 ; definicja etykiety lokalnej LP w obszarze makra .endm W w/w przyk\u0142adzie wyst\u0119puj\u0105 definicje etykiet o tych samych nazwach (LP), lecz ka\u017cda z nich ma inn\u0105 warto\u015b\u0107 i jest innego zasi\u0119gu.","title":"Lokalne"},{"location":"etykiety/#globalne","text":"Ka\u017cda definicja etykiety dokonana w g\u0142\u00f3wnym bloku programu poza obszarem makra .MACRO , procedury .PROC czy obszaru lokalnego .LOCAL jest zasi\u0119gu globalnego, innymi s\u0142owy jest globalna. Etykiety globalne definiujemy u\u017cywaj\u0105c n/w r\u00f3wnowa\u017cnych pseudo rozkaz\u00f3w: EQU = lub dyrektywy .DEF o sk\u0142adni: .DEF :label [= expression] Dyrektywa .DEF umo\u017cliwia zdefiniowanie etykiety w aktualnym obszarze lokalnym, znak : na pocz\u0105tku etykiety sygnalizuje etykiet\u0119 globaln\u0105. U\u017cycie dyrektywy o sk\u0142adni .DEF :label pozwala na zdefiniowanie etykiety globalnej z pomini\u0119ciem aktualnego poziomu lokalno\u015bci. Znak dwukropka : na pocz\u0105tku etykiety ma specjalne znaczenie, informuje \u017ce odwo\u0142ujemy si\u0119 do etykiety globalnej, czyli etykiety z g\u0142\u00f3wnego bloku programu z pomini\u0119ciem wszystkich poziom\u00f3w lokalno\u015bci. Wi\u0119cej informacji na temat u\u017cycia dyrektywy .DEF w rozdziale Dyrektywa .DEF Przyk\u0142ad definicji etykiet globalnych: lab equ * lab2 equ $4000 ?tmp = 0 ?tmp += 40 .proc name .def :?nazwa = $A000 .def :nazwa=20 .local lok1 .def :@?nazw = 'a'+32 .endl .endp Przyk\u0142adem zastosowania definicji etykiety globalnej tymczasowej jest m.in. makro @CALL , przyk\u0142ad w pliku ..\\EXAMPLES\\MACROS\\@CALL.MAC , w kt\u00f3rym wyst\u0119puje definicja etykiety tymczasowej ?@STACK_OFFSET . Jest ona p\u00f3\u017aniej wykorzystywana przez pozosta\u0142e makra wywo\u0142ywane z poziomu makra @CALL , a s\u0142u\u017cy do optymalizacji programu odk\u0142adaj\u0105cego parametry na stos programowy. @CALL .macro .def ?@stack_offset = 0 ; definicja etykiety globalnej tymczasowej ?@stack_offset ... ... @CALL_@ .macro sta @stack_address+?@stack_offset,x .def ?@stack_offset = ?@stack_offset + 1 ; modyfikacja etykiety ?@stack_offset .endm","title":"Globalne"},{"location":"etykiety/#tymczasowe","text":"Definicja etykiety tymczasowej posiada t\u0105 w\u0142a\u015bciwo\u015b\u0107, \u017ce jej warto\u015b\u0107 mo\u017ce ulega\u0107 zmianie wielokrotnie nawet podczas jednego przebiegu asemblacji. Normalnie pr\u00f3ba ponownej definicji etykiety ko\u0144czy si\u0119 komunikatem Label declared twice . Nie b\u0119dzie takiego komunikatu je\u015bli jest to etykieta tymczasowa. Zasi\u0119g etykiet tymczasowych uzale\u017cniony jest od obszaru w jakim etykieta zosta\u0142a zdefiniowana. Etykiety tymczasowe mog\u0105 posiada\u0107 zasi\u0119g lokalny ( Etykiety lokalne ) lub globalny ( Etykiety globalne ).","title":"Tymczasowe"},{"location":"etykiety/#label","text":"Etykiet\u0119 tymczasow\u0105 definiuje u\u017cytkownik poprzez umieszczenie na pocz\u0105tku nazwy etykiety znaku zapytania ? , np.: ?label Etykiet tymczasowych nie powinno u\u017cywa\u0107 si\u0119 do nazw procedur .PROC , makr .MACRO , obszar\u00f3w lokalnych .LOCAL , struktur .STRUCT , tablic .ARRAY . Etykiety tymczasowe definiujemy u\u017cywaj\u0105c n/w r\u00f3wnowa\u017cnych pseudo rozkaz\u00f3w: EQU = Dodatkowo mo\u017cemy je modyfikowa\u0107 za pomoc\u0105 znanych z C operator\u00f3w: -= expression += expression -- ++ W/w operatory modyfikuj\u0105ce dotycz\u0105 tylko etykiet tymczasowych, pr\u00f3ba ich u\u017cycia dla innego typu etykiety sko\u0144czy si\u0119 komunikatem b\u0142\u0119du Improper syntax . Przyk\u0142ad u\u017cycia etykiet tymczasowych: ?loc = $567 ?loc2 = ?loc+$2000 lda ?loc sta ?loc2 ?loc = $123 lda ?loc","title":"?label"},{"location":"etykiety/#label-set-value","text":"Pseudorozkaz SET umo\u017cliwia redefinicj\u0119 etykiety LABEL , dzia\u0142a ze zwyk\u0142ymi etykietami tzn. takimi kt\u00f3re nie maj\u0105 pierwszego znaku w nazwie ? . Etykiet zdefiniowanych przez SET nie mo\u017cna p\u00f3\u017aniej definiowa\u0107 inaczej ni\u017c przez SET . tmp set 1 tmp = 2 Dla w/w przyk\u0142adu powstanie niesko\u0144czona p\u0119tla Infinite loop , prawid\u0142owo powinno by\u0107 : tmp set 1 tmp set 2","title":"label SET value"},{"location":"etykiety/#automodyfikacji","text":"Etykieta d\u0142u\u017csza ni\u017c 1 znak, umieszczona po mnemoniku i zako\u0144czona znakiem : definiuje adres automodyfikacji kodu. lda label:#$00 add plus:#$00 lda src:$ff00,y sta dst:$ff00,y W/w przyk\u0142ady s\u0105 odpowiednikiem kodu: lda #$00 label equ *-1 add #$00 plus equ *-1 lda $ff00,y src equ *-2 sta $ff00,y dst equ *-2","title":"Automodyfikacji"},{"location":"etykiety/#lokalne-w-stylu-mae","text":"Opcja OPT ?+ informuje MADS aby etykiety zaczynaj\u0105ce si\u0119 znakiem ? interpretowa\u0142 jako etykiety lokalne tak jak robi to MAE . Domy\u015blnie etykiety zaczynaj\u0105ce si\u0119 znakiem ? traktowane s\u0105 przez MADS jako etykiety tymczasowe. Przyk\u0142ad u\u017cycia etykiet lokalnych w stylu MAE : opt ?+ org $2000 local1 ldx #7 ?lop sta $a000,x dex bpl ?lop local2 ldx #7 ?lop sta $b000,x dex bpl ?lop","title":"Lokalne w stylu MAE"},{"location":"kod-relokowalny/","text":"Wst\u0119p Kod relokowalny to taki kod, kt\u00f3ry nie ma z g\u00f3ry okre\u015blonego adresu \u0142adowania do pami\u0119ci komputera, kod taki musi zadzia\u0142a\u0107 niezale\u017cnie od adresu za\u0142adowania. W Atari XE/XL kod relokowalny udost\u0119pnia system Sparta DOS X ( SDX ), wi\u0119cej na ten temat mo\u017cna przeczyta\u0107 w rozdziale Sparta DOS X - Programowanie . Kod relokowalny dla SDX posiada podstawowe ograniczenie jakim jest relokowanie tylko adres\u00f3w typu WORD , nie ma tak\u017ce obs\u0142ugi rozkaz\u00f3w CPU 65816 . MADS udost\u0119pnia mo\u017cliwo\u015b\u0107 generowania kodu relokowalnego w formacie SDX jak i swoim w\u0142asnym niekompatybilnym z SDX , kt\u00f3ry znosi wcze\u015bniej wymienione ograniczenia. Format zapisu pliku z kodem relokowalnym MADS jest podobny do tego znanego z SDX , podobnie wyst\u0119puje tutaj blok g\u0142\u00f3wny i bloki dodatkowe z informacj\u0105 o adresach kt\u00f3re nale\u017cy podda\u0107 relokacji. MADS stosuje prostszy zapis blok\u00f3w aktualizacji, bez kompresji jak\u0105 stosuje SDX . Zalety kodu relokowalnego MADS : uwzgl\u0119dnia rozmiar argument\u00f3w dla CPU 6502 , 65816 mo\u017cna u\u017cywa\u0107 wszystkie rozkazy CPU , bez ogranicze\u0144 pozwala na relokacje m\u0142odszych i starszych bajt\u00f3w adresu Ograniczenia kodu relokowalnego MADS : deklaracji etykiet przez EQU dokonujemy przed blokiem .RELOC je\u015bli chcemy zdefiniowa\u0107 now\u0105 etykiet\u0119 w bloku .RELOC musimy jej nazw\u0119 poprzedzi\u0107 spacj\u0105 lub tabulatorem (etykieta globalna) nie mo\u017cna u\u017cywa\u0107 pseudo rozkaz\u00f3w ORG RMB LMB NMB oraz dyrektywy .DS nie mo\u017cna relokowa\u0107 najstarszego bajtu ze s\u0142owa 24bit, np. lda ^$121416 Przyk\u0142adem tego jak prosto mo\u017cna stworzy\u0107 kod relokowalny jest plik ..\\EXAMPLES\\TETRIS_RELOC.ASM , kt\u00f3ry od strony u\u017cytej listy rozkaz\u00f3w CPU i pseudo rozkaz\u00f3w definiuj\u0105cych dane niczym nie r\u00f3\u017cni si\u0119 od wersji nierelokowalnej ..\\EXAMPLES\\TETRIS.ASM . Blok relokowalny .RELOC Blok relokowalny MADS zostanie wygenerowany po u\u017cyciu dyrektywy: .RELOC [.BYTE|.WORD] Blok aktualizacji dla bloku relokowalnego MADS wywo\u0142ujemy u\u017cywaj\u0105c pseudo rozkazu BLK : BLK UPDATE ADDRESS Po dyrektywie .RELOC mo\u017cliwe jest podanie typu bloku relokowalnego .BYTE .WORD , domy\u015blnie jest to typ .WORD . Typ .BYTE dotyczy bloku przeznaczonego do umieszczenia wy\u0142\u0105cznie na stronie zerowej (b\u0119dzie zawiera\u0142 rozkazy strony zerowej), MADS b\u0119dzie asemblowa\u0142 taki blok od adresu $0000 . Typ .WORD oznacza \u017ce MADS b\u0119dzie asemblowa\u0142 blok relokowalny od adresu $0100 i b\u0119dzie przeznaczony do umieszczenia w dowolnym obszarze pami\u0119ci (nie b\u0119dzie zawiera\u0142 rozkaz\u00f3w strony zerowej). Nag\u0142\u00f3wek bloku .RELOC przypomina ten znany z DOS , dodatkowo zosta\u0142 on rozszerzony o 10 nowych bajt\u00f3w czyli w sumie zajmuje 16 bajt\u00f3w, np.: HEADER .WORD = $FFFF START_ADDRESS .WORD = $0000 END_ADDRESS .WORD = FILE_LENGTH-1 MADS_RELOC_HEADER .WORD = $524D UNUSED .BYTE = $00 CONFIG .BYTE (bit0) @STACK_POINTER .WORD @STACK_ADDRESS .WORD @PROC_VARS_ADR .WORD MADS_RELOC_HEADER Zawsze o warto\u015bci $524D co odpowiada znakom MR (M-ADS R-ELOC). FILE_LENGTH To d\u0142ugo\u015b\u0107 bloku relokowalnego bez 16 bajtowego nag\u0142\u00f3wka. CONFIG Wykorzystany jest obecnie tylko bit0 tego bajtu, bit0=0 oznacza blok relokowalny asemblowany od adresu $0000 , bit0=1 blok relokowalny asemblowany od adresu $0100 Ostatnie 6 bajt\u00f3w zawiera informacj\u0119 o warto\u015bciach etykiet potrzebnych do dzia\u0142ania stosu programowego @STACK_POINTER , @STACK_ADDRESS , @PROC_VARS_ADR je\u015bli zosta\u0142y u\u017cyte podczas asemblacji blok\u00f3w relokowalnych. Je\u015bli poszczeg\u00f3lne bloki .RELOC zosta\u0142y zasemblowane z r\u00f3\u017cnymi warto\u015bciami tych etykiet i s\u0105 one linkowane wyst\u0105pi w\u00f3wczas komunikat ostrze\u017cenia Incompatible stack parameters . Je\u015bli stos programowy nie zosta\u0142 u\u017cyty warto\u015bciami tych etykiet s\u0105 zera. Pseudo rozkaz .RELOC powoduje prze\u0142\u0105czenie MADS w tryb generowania kodu relokowalnego z uwzgl\u0119dnianiem rozmiaru argument\u00f3w rozkaz\u00f3w CPU 6502 , 65816 . W obszarze takiego kodu niemo\u017cliwe jest u\u017cywanie pseudo rozkaz\u00f3w ORG LMB NMB RMB oraz dyrektywy .DS . Niemo\u017cliwy jest powr\u00f3t MADS do trybu generowania kodu nie relokowalnego, mo\u017cliwe jest wygenerowanie wi\u0119cej ni\u017c jednego bloku .RELOC . U\u017cycie dyrektywy .RELOC powoduje dodatkowo zwi\u0119kszenie licznika wirtualnych bank\u00f3w MADS przez co taki obszar staje si\u0119 lokalny i niewidoczny dla innych blok\u00f3w. Wi\u0119cej informacji na temat wirtualnych bank\u00f3w w rozdziale Wirtualne banki pami\u0119ci OPT B- . Na ko\u0144cu bloku .RELOC wymagane jest wygenerowanie bloku aktualizacji, realizuje to pseudo rozkaz BLK z identyczn\u0105 sk\u0142adni\u0105 jak dla bloku relokowalnego SDX ( BLK UPDATE ADDRESS ). Format zapisu takiego bloku aktualizacji nie jest jednak identyczny z SDX , ma nast\u0119puj\u0105c\u0105 posta\u0107: HEADER WORD ($FFEF) TYPE CHAR (B-YTE, W-ORD, L-ONG, D-WORD, <, >) DATA_LENGTH WORD DATA WORD [BYTE] HEADER Zawsze o warto\u015bci $FFEF . TYPE Typ danych zapisany jest na bitach 0..6 tego bajtu i okre\u015bla typ modyfikowanych adres\u00f3w, znak < oznacza m\u0142odszy bajt adresu, znak > oznacza starszy bajt adresu. DATA_LENGTH To liczba 2-bajtowych danych (adres\u00f3w) do modyfikacji. DATA To w\u0142a\u015bciwy ci\u0105g danych s\u0142u\u017c\u0105cych modyfikacji g\u0142\u00f3wnego bloku relokowalnego. Pod wskazanym tutaj adresem nale\u017cy odczyta\u0107 warto\u015b\u0107 typu TYPE a nast\u0119pnie zmodyfikowa\u0107 na podstawie nowego adresu \u0142adowania. Wyj\u0105tek stanowi blok aktualizacji dla starszych bajt\u00f3w adres\u00f3w > , dla takiego bloku w DATA zapisywany jest jeszcze dodatkowy bajt BYTE (m\u0142odszy bajt modyfikowanego adresu). Aby dokona\u0107 aktualizacji starszych bajt\u00f3w, musimy odczyta\u0107 bajt spod adresu WORD w DATA , doda\u0107 go do aktualnego adresu relokacji i doda\u0107 jeszcze m\u0142odszy bajt z BYTE w DATA . Tak nowo obliczony starszy bajt umieszczamy pod adresem WORD z DATA . Symbole zewn\u0119trzne .EXTRN Symbole zewn\u0119trzne informuj\u0105, \u017ce zmienne i procedury kt\u00f3re reprezentuj\u0105 b\u0119d\u0105 znajdowa\u0142y si\u0119 gdzie\u015b na zewn\u0105trz, poza aktualnym programem. Nie musimy okre\u015bla\u0107 gdzie. Musimy jedynie poda\u0107 ich nazwy oraz typy. W zale\u017cno\u015bci od typu danych jakie reprezentuje symbol instrukcje asemblera t\u0142umaczone s\u0105 na odpowiednie kody maszynowe, asembler musi zna\u0107 rozmiar u\u017cywanych danych. UWAGA: Aktualnie nie istnieje mo\u017cliwo\u015b\u0107 dokonywania operacji na symbolach external typu ^ (najstarszy bajt). Symbole zewn\u0119trzne mog\u0105 by\u0107 u\u017cywane w blokach relokowalnych .RELOC jak i w zwyk\u0142ych blokach DOS . Symbole zewn\u0119trzne external deklarujemy u\u017cywaj\u0105c pseudo rozkazu EXT lub dyrektywy .EXTRN : label EXT type label .EXTRN type .EXTRN label1,label2,label3... type .extrn PlaySfx .proc (.byte PlaySfx.note, PlaySfx.fx) .var Blok aktualizacji dla symboli external wywo\u0142ujemy u\u017cywaj\u0105c pseudo rozkazu BLK : BLK UPDATE EXTERNAL UWAGA: Zostan\u0105 zapisane symbole, kt\u00f3re zosta\u0142y u\u017cyte w programie. Symbole external nie maj\u0105 zdefiniowanej warto\u015bci tylko typ .BYTE .WORD .LONG .DWORD np.: name EXT .BYTE label_name EXT .WORD .EXTRN label_name .WORD wait EXT .PROC (.BYTE delay) Symbol external z deklaracj\u0105 procedury .PROC przyjmuje domy\u015blnie typ .WORD , pr\u00f3ba odwo\u0142ania si\u0119 do nazwy takiej etykiety zostanie potraktowana przez MADS jako pr\u00f3ba wywo\u0142ania procedury, wi\u0119cej na temat wywo\u0142a\u0144 procedur .PROC w rozdziale Procedury . W procesie asemblacji po napotkaniu odwo\u0142ania do symbolu external zawsze podstawiane s\u0105 zera. Symbole external przyda\u0107 si\u0119 nam mog\u0105 w\u00f3wczas gdy chcemy zasemblowa\u0107 program oddzielnie, niezale\u017cnie od reszty w\u0142a\u015bciwego programu. W takim programie wyst\u0119puj\u0105 w\u00f3wczas najcz\u0119\u015bciej odwo\u0142ania do procedur, zmiennych kt\u00f3re zosta\u0142y zdefiniowane gdzie\u015b indziej, na zewn\u0105trz, a my nie znamy ich warto\u015bci tylko typ. W tym momencie z pomoc\u0105 przychodz\u0105 symbole external , kt\u00f3re umo\u017cliwiaj\u0105 asemblacj\u0119 takiego programu mimo braku w\u0142a\u015bciwych procedur czy zmiennych. Innym zastosowaniem symboli external mog\u0105 by\u0107 tzw. pluginy programy zewn\u0119trzne po\u0142\u0105czone z programem g\u0142\u00f3wnym i realizuj\u0105ce dodatkowe czynno\u015bci. S\u0105 to swoistego rodzaje biblioteki, wykorzystuj\u0105ce procedury programu g\u0142\u00f3wnego, rozszerzaj\u0105ce jego funkcjonalno\u015b\u0107. Aby stworzy\u0107 taki plugin nale\u017ca\u0142oby okre\u015bli\u0107 jakie procedury udost\u0119pnia program g\u0142\u00f3wny (ich nazwy+parametry i typ) oraz stworzy\u0107 procedur\u0119 odczytu pliku z symbolami external , ta procedura realizowa\u0142aby do\u0142\u0105czanie plugin\u00f3w do g\u0142\u00f3wnego programu. Poni\u017cej format zapisu nag\u0142\u00f3wka w pliku z symbolami external typu B -YTE, W -ORD, L -ONG i D -WORD po wywo\u0142aniu przez BLK UPDATE EXTERNAL : HEADER WORD ($FFEE) TYPE CHAR (B-YTE, W-ORD, L-ONG, D-WORD, <, >) DATA_LENGTH WORD LABEL_LENGTH WORD LABEL_NAME ATASCII DATA WORD .. .. .. HEADER Zawsze o warto\u015bci $FFEE . TYPE Typ danych zapisany jest na bitach 0..6 tego bajtu i okre\u015bla typ modyfikowanych adres\u00f3w. DATA_LENGTH To liczba 2-bajtowych danych (adres\u00f3w) do modyfikacji. LABEL_LENGTH To d\u0142ugo\u015b\u0107 nazwy symbolu wyra\u017cona w bajtach. LABEL_NAME To nazwa symbolu w kodach ATASCII . DATA W\u0142a\u015bciwy ci\u0105g danych s\u0142u\u017c\u0105cych modyfikacji g\u0142\u00f3wnego bloku relokowalnego. Pod wskazanym tutaj adresem nale\u017cy odczyta\u0107 warto\u015b\u0107 typu TYPE a nast\u0119pnie zmodyfikowa\u0107 na podstawie nowej warto\u015bci symbolu. Przyk\u0142adem zastosowania symboli external i struktur .STRUCT jest przyk\u0142adowa biblioteka prymityw\u00f3w graficznych PLOT LINE CIRCLE z katalogu ..\\EXAMPLES\\LIBRARIES\\GRAPHICS\\LIB . Poszczeg\u00f3lne modu\u0142y wykorzystuj\u0105 tutaj do\u015b\u0107 spor\u0105 liczb\u0119 zmiennych na stronie zerowej, je\u015bli chcemy aby adresy tych zmiennych by\u0142y relokowalne musieliby\u015bmy ka\u017cd\u0105 z osobna zmienn\u0105 zadeklarowa\u0107 jako symbol zewn\u0119trzny przez EXT .EXTRN . Mo\u017cemy to upro\u015bci\u0107 wykorzystuj\u0105c tylko jeden symbol zewn\u0119trzny i struktur\u0119 danych .STRUCT . Za pomoc\u0105 struktur definiujemy map\u0119 zmiennych ZP , potem jeden symbol external ZPAGE typu .BYTE bo chcemy aby zmienne by\u0142y na stronie zerowej. Teraz odwo\u0142uj\u0105c si\u0119 do zmiennej musimy zapisa\u0107 to w spos\u00f3b wymuszaj\u0105cy relokowalno\u015b\u0107 np. ZPAGE+ZP.DX i tak powsta\u0142 modu\u0142 ca\u0142kowicie relokowalny z mo\u017cliwo\u015bci\u0105 zmiany adresu zmiennych w przestrzeni strony zerowej. Symbole publiczne .PUBLIC Symbole publiczne udost\u0119pniaj\u0105 zmienne i procedury wyst\u0119puj\u0105ce w bloku relokowalnym pozosta\u0142ej cz\u0119\u015bci asemblowanego programu. Dzi\u0119ki symbolom publicznym mo\u017cemy odwo\u0142ywa\u0107 si\u0119 do zmiennych i procedur zaszytych np. w bibliotekach. Symbole publiczne mog\u0105 by\u0107 u\u017cywane w blokach relokowalnych .RELOC jak i w zwyk\u0142ych blokach DOS . MADS sam rozpoznaje czy podana do upublicznienia etykieta jest zmienn\u0105, sta\u0142\u0105 czy te\u017c procedur\u0105 zadeklarown\u0105 przez .PROC , nie jest wymagana \u017cadna dodatkowa informacja jak w przypadku symboli zewn\u0119trznych. Symbole publiczne deklarujemy u\u017cywaj\u0105c n/w dyrektyw: .PUBLIC label [,label2,...] .GLOBAL label [,label2,...] .GLOBL label [,label2,...] Dyrektywy .GLOBAL .GLOBL zosta\u0142y dodane z my\u015bl\u0105 o kompatybilno\u015bci z innymi assemblerami, ich znaczenie jest identyczne z dyrektyw\u0105 .PUBLIC . Blok aktualizacji dla symboli publicznych wywo\u0142ujemy u\u017cywaj\u0105c pseudo rozkazu BLK : BLK UPDATE PUBLIC Poni\u017cej format zapisu nag\u0142\u00f3wka w pliku z symbolami publicznymi po wywo\u0142aniu przez BLK UPDATE PUBLIC : HEADER WORD ($FFED) LENGTH WORD TYPE BYTE (B-YTE, W-ORD, L-ONG, D-WORD) LABEL_TYPE CHAR (C-ONSTANT, V-ARIABLE, P-ROCEDURE, A-RRAY, S-TRUCT) LABEL_LENGTH WORD LABEL_NAME ATASCII ADDRESS WORD MADS automatycznie dobiera odpowiedni typ dla upublicznianej etykiety: C-ONSTANT etykieta nie poddaj\u0105ca si\u0119 relokacji V-ARIABLE etykieta poddaj\u0105ca si\u0119 relokacji P-ROCEDURE procedura zadeklarowana przez .PROC, podlega relokacji A-RRAY tablica zadeklarowana przez .ARRAY, podlega relokacji S-TRUCT struktura zadeklarowana przez .STRUCT, nie podlega relokacji Je\u015bli symbol dotyczy struktury .STRUCT w\u00f3wczas zapisywane s\u0105 dodatkowe informacje (typ pola struktury, nazwa pola struktury, liczba powt\u00f3rze\u0144 pola struktury): STRUCT_LABEL_TYPE CHAR (B-YTE, W-ORD, L-ONG, D-WORD) STRUCT_LABEL_LENGTH WORD STRUCT_LABEL_NAME ATASCII STRUCT_LABEL_REPEAT WORD Je\u015bli symbol dotyczy tablicy .ARRAY w\u00f3wczas zapisywane s\u0105 dodatkowe informacje (maksymalny zadeklarowany indeks tablicy, typ zadeklarowanych p\u00f3l tablicy): ARRAY_MAX_INDEX WORD ARRAY_TYPE CHAR (B-YTE, W-ORD, L-ONG, D-WORD) Je\u015bli symbol dotyczy procedury .PROC w\u00f3wczas zapisywane s\u0105 dodatkowe informacje, niezale\u017cnie od tego czy procedura mia\u0142a czy te\u017c nie mia\u0142a zadeklarowane parametry: PROC_CPU_REG BYTE (bits 00 - regA, 01 - regX, 10 - regY) PROC_TYPE BYTE (D-EFAULT, R-EGISTRY, V-ARIABLE) PARAM_COUNT WORD Dla symboli dotycz\u0105cych procedur .REG zapisywane s\u0105 ju\u017c teraz tylko typy tych parametr\u00f3w w ilo\u015bci PARAM_COUNT : PARAM_TYPE CHAR (B-YTE, W-ORD, L-ONG, D-WORD) ... ... Dla symboli dotycz\u0105cych procedur .VAR zapisywane s\u0105 typy parametr\u00f3w i ich nazwy. PARAM_COUNT okre\u015bla ca\u0142kowit\u0105 d\u0142ugo\u015b\u0107 tych danych: PARAM_TYPE CHAR (B-YTE, W-ORD, L-ONG, D-WORD) PARAM_LENGTH WORD PARAM_NAME ATASCII ... ... HEADER Zawsze o warto\u015bci $FFED . LENGTH To liczba symboli zapisanych w bloku aktualizacji. TYPE Typ symbolizowanych danych B -YTE, W -ORD, L -ONG, D -WORD. LABEL_TYPE Typ symbolu: V-ARIABLE, C-ONSTANT, P-ROCEDURE, A-RRAY, S-TRUCT Dla typu P zapisywane s\u0105 dodatkowe informacje: PROC_CPU_REG, PROC_TYPE, PARAM_COUNT, PARAM_TYPE Dla typu A zapisywane s\u0105 dodatkowe informacje: ARRAY_MAX_INDEX, ARRAY_TYPE Dla typu S zapisywane s\u0105 dodatkowe informacje: STRUCT_LABEL_TYPE, STRUCT_LABEL_LENGTH, STRUCT_LABEL_NAME, STRUCT_LABEL_REPEAT Typ symbolizowanych danych B -YTE, W -ORD, L -ONG, D -WORD. LABEL_LENGTH D\u0142ugo\u015b\u0107 etykiety symbolu publicznego wyra\u017cona w bajtach LABEL_LENGTH D\u0142ugo\u015b\u0107 etykiety symbolu publicznego wyra\u017cona w bajtach LABEL_NAME Etykieta symbolu publicznego zapisana w kodach ATASCII ADDRESS Adres przypisany symbolowi w bloku relokowalnym .RELOC . Ta warto\u015b\u0107 zostaje poddana relokacji poprzez dodanie do niej aktualnego adresu asemblacji. PROC_CPU_REG Informacja o kolejno\u015bci u\u017cycia rejestr\u00f3w CPU dla procedury typu .REG PROC_TYPE D -EFAULT domy\u015blny typ wykorzystuj\u0105cy do przekazywania parametr\u00f3w stos programowy MADS R -EGISTRY parametry do procedury przekazywane s\u0105 przez rejestry CPU .REG V -ARIABLE parametry do procedury przekazywane s\u0105 przez zmienne .VAR PARAM_COUNT Informacja o liczbie parametr\u00f3w procedury .REG lub ca\u0142kowitej d\u0142ugo\u015bci danych zawieraj\u0105cych informacj\u0119 o typie parametr\u00f3w i ich nazwach .VAR . PARAM_TYPE Typ parametr\u00f3w zapisany za pomoc\u0105 znak\u00f3w B W L D PARAM_LENGTH D\u0142ugo\u015b\u0107 nazwy parametru .VAR . PARAM_NAME Nazwa parametru w kodach ATASCII .VAR . Dyrektywy .LONGA .LONGI .LONGA ON|OFF .LONGI ON|OFF Dyrektywa .LONGA informuje assembler o rozmiarze rejestru akumulatora, 16bit gdy ON, 8bit gdy OFF. Dyrektywa .LONGI informuje assembler o rozmiarze rejestr\u00f3w indeksowych XY , 16bit gdy ON, 8bit gdy OFF. Dyrektywy wp\u0142ywaj\u0105 na rozmiar argumentu przy adresowaniu absolutnym CPU 65816 . Linkowanie .LINK .LINK 'filename' Dyrektywa .LINK wymaga podania jako parametru nazwy pliku do relokacji. Akceptowane s\u0105 tylko pliki DOS Atari , pliki SDX nie s\u0105 akceptowane. Je\u015bli adres \u0142adowania pliku jest inny ni\u017c $0000 oznacza to \u017ce plik nie zawiera kodu relokowalnego, jednak mo\u017ce zawiera\u0107 bloki aktualizacji dla symboli zewn\u0119trznych i publicznych. Dyrektywa .LINK akceptuje pliki o dowolnym adresie \u0142adowania, jednak relokacji poddawane s\u0105 tylko te o adresie \u0142adowania $0000 , wi\u0119cej szczeg\u00f3\u0142\u00f3w na temat budowy takiego pliku zosta\u0142o zawartych w rozdziale Blok relokowalny .RELOC . Dyrektywa .LINK pozwala na \u0142\u0105czenie kodu relokowalnego z nierelokowalnym. MADS na podstawie blok\u00f3w aktualizacji dokonuje automatycznej relokacji takiego pliku. Uwzgl\u0119dniane s\u0105 wszystkie 3 rodzaje blok\u00f3w aktualizacji ADDRESS EXTERNAL PUBLIC . Nie ma ogranicze\u0144 co do adresu pod kt\u00f3rym umieszczany jest plik relokowalny. Je\u015bli blok relokowalny do dzia\u0142ania wymaga stosu programowego MADS w\u00f3wczas etykiety @STACK_POINTER @STACK_ADDRESS @PROC_VARS_ADR zostan\u0105 automatycznie zaktualizowane na podstawie nag\u0142\u00f3wka bloku .RELOC . Wymagane jest aby bloki .RELOC i program g\u0142\u00f3wny operowa\u0142y na tym samym stosie programowym je\u015bli jest on konieczny.","title":"Kod relokowalny"},{"location":"kod-relokowalny/#_1","text":"","title":""},{"location":"kod-relokowalny/#wstep","text":"Kod relokowalny to taki kod, kt\u00f3ry nie ma z g\u00f3ry okre\u015blonego adresu \u0142adowania do pami\u0119ci komputera, kod taki musi zadzia\u0142a\u0107 niezale\u017cnie od adresu za\u0142adowania. W Atari XE/XL kod relokowalny udost\u0119pnia system Sparta DOS X ( SDX ), wi\u0119cej na ten temat mo\u017cna przeczyta\u0107 w rozdziale Sparta DOS X - Programowanie . Kod relokowalny dla SDX posiada podstawowe ograniczenie jakim jest relokowanie tylko adres\u00f3w typu WORD , nie ma tak\u017ce obs\u0142ugi rozkaz\u00f3w CPU 65816 . MADS udost\u0119pnia mo\u017cliwo\u015b\u0107 generowania kodu relokowalnego w formacie SDX jak i swoim w\u0142asnym niekompatybilnym z SDX , kt\u00f3ry znosi wcze\u015bniej wymienione ograniczenia. Format zapisu pliku z kodem relokowalnym MADS jest podobny do tego znanego z SDX , podobnie wyst\u0119puje tutaj blok g\u0142\u00f3wny i bloki dodatkowe z informacj\u0105 o adresach kt\u00f3re nale\u017cy podda\u0107 relokacji. MADS stosuje prostszy zapis blok\u00f3w aktualizacji, bez kompresji jak\u0105 stosuje SDX . Zalety kodu relokowalnego MADS : uwzgl\u0119dnia rozmiar argument\u00f3w dla CPU 6502 , 65816 mo\u017cna u\u017cywa\u0107 wszystkie rozkazy CPU , bez ogranicze\u0144 pozwala na relokacje m\u0142odszych i starszych bajt\u00f3w adresu Ograniczenia kodu relokowalnego MADS : deklaracji etykiet przez EQU dokonujemy przed blokiem .RELOC je\u015bli chcemy zdefiniowa\u0107 now\u0105 etykiet\u0119 w bloku .RELOC musimy jej nazw\u0119 poprzedzi\u0107 spacj\u0105 lub tabulatorem (etykieta globalna) nie mo\u017cna u\u017cywa\u0107 pseudo rozkaz\u00f3w ORG RMB LMB NMB oraz dyrektywy .DS nie mo\u017cna relokowa\u0107 najstarszego bajtu ze s\u0142owa 24bit, np. lda ^$121416 Przyk\u0142adem tego jak prosto mo\u017cna stworzy\u0107 kod relokowalny jest plik ..\\EXAMPLES\\TETRIS_RELOC.ASM , kt\u00f3ry od strony u\u017cytej listy rozkaz\u00f3w CPU i pseudo rozkaz\u00f3w definiuj\u0105cych dane niczym nie r\u00f3\u017cni si\u0119 od wersji nierelokowalnej ..\\EXAMPLES\\TETRIS.ASM .","title":"Wst\u0119p"},{"location":"kod-relokowalny/#blok-relokowalny-reloc","text":"Blok relokowalny MADS zostanie wygenerowany po u\u017cyciu dyrektywy: .RELOC [.BYTE|.WORD] Blok aktualizacji dla bloku relokowalnego MADS wywo\u0142ujemy u\u017cywaj\u0105c pseudo rozkazu BLK : BLK UPDATE ADDRESS Po dyrektywie .RELOC mo\u017cliwe jest podanie typu bloku relokowalnego .BYTE .WORD , domy\u015blnie jest to typ .WORD . Typ .BYTE dotyczy bloku przeznaczonego do umieszczenia wy\u0142\u0105cznie na stronie zerowej (b\u0119dzie zawiera\u0142 rozkazy strony zerowej), MADS b\u0119dzie asemblowa\u0142 taki blok od adresu $0000 . Typ .WORD oznacza \u017ce MADS b\u0119dzie asemblowa\u0142 blok relokowalny od adresu $0100 i b\u0119dzie przeznaczony do umieszczenia w dowolnym obszarze pami\u0119ci (nie b\u0119dzie zawiera\u0142 rozkaz\u00f3w strony zerowej). Nag\u0142\u00f3wek bloku .RELOC przypomina ten znany z DOS , dodatkowo zosta\u0142 on rozszerzony o 10 nowych bajt\u00f3w czyli w sumie zajmuje 16 bajt\u00f3w, np.: HEADER .WORD = $FFFF START_ADDRESS .WORD = $0000 END_ADDRESS .WORD = FILE_LENGTH-1 MADS_RELOC_HEADER .WORD = $524D UNUSED .BYTE = $00 CONFIG .BYTE (bit0) @STACK_POINTER .WORD @STACK_ADDRESS .WORD @PROC_VARS_ADR .WORD MADS_RELOC_HEADER Zawsze o warto\u015bci $524D co odpowiada znakom MR (M-ADS R-ELOC). FILE_LENGTH To d\u0142ugo\u015b\u0107 bloku relokowalnego bez 16 bajtowego nag\u0142\u00f3wka. CONFIG Wykorzystany jest obecnie tylko bit0 tego bajtu, bit0=0 oznacza blok relokowalny asemblowany od adresu $0000 , bit0=1 blok relokowalny asemblowany od adresu $0100 Ostatnie 6 bajt\u00f3w zawiera informacj\u0119 o warto\u015bciach etykiet potrzebnych do dzia\u0142ania stosu programowego @STACK_POINTER , @STACK_ADDRESS , @PROC_VARS_ADR je\u015bli zosta\u0142y u\u017cyte podczas asemblacji blok\u00f3w relokowalnych. Je\u015bli poszczeg\u00f3lne bloki .RELOC zosta\u0142y zasemblowane z r\u00f3\u017cnymi warto\u015bciami tych etykiet i s\u0105 one linkowane wyst\u0105pi w\u00f3wczas komunikat ostrze\u017cenia Incompatible stack parameters . Je\u015bli stos programowy nie zosta\u0142 u\u017cyty warto\u015bciami tych etykiet s\u0105 zera. Pseudo rozkaz .RELOC powoduje prze\u0142\u0105czenie MADS w tryb generowania kodu relokowalnego z uwzgl\u0119dnianiem rozmiaru argument\u00f3w rozkaz\u00f3w CPU 6502 , 65816 . W obszarze takiego kodu niemo\u017cliwe jest u\u017cywanie pseudo rozkaz\u00f3w ORG LMB NMB RMB oraz dyrektywy .DS . Niemo\u017cliwy jest powr\u00f3t MADS do trybu generowania kodu nie relokowalnego, mo\u017cliwe jest wygenerowanie wi\u0119cej ni\u017c jednego bloku .RELOC . U\u017cycie dyrektywy .RELOC powoduje dodatkowo zwi\u0119kszenie licznika wirtualnych bank\u00f3w MADS przez co taki obszar staje si\u0119 lokalny i niewidoczny dla innych blok\u00f3w. Wi\u0119cej informacji na temat wirtualnych bank\u00f3w w rozdziale Wirtualne banki pami\u0119ci OPT B- . Na ko\u0144cu bloku .RELOC wymagane jest wygenerowanie bloku aktualizacji, realizuje to pseudo rozkaz BLK z identyczn\u0105 sk\u0142adni\u0105 jak dla bloku relokowalnego SDX ( BLK UPDATE ADDRESS ). Format zapisu takiego bloku aktualizacji nie jest jednak identyczny z SDX , ma nast\u0119puj\u0105c\u0105 posta\u0107: HEADER WORD ($FFEF) TYPE CHAR (B-YTE, W-ORD, L-ONG, D-WORD, <, >) DATA_LENGTH WORD DATA WORD [BYTE] HEADER Zawsze o warto\u015bci $FFEF . TYPE Typ danych zapisany jest na bitach 0..6 tego bajtu i okre\u015bla typ modyfikowanych adres\u00f3w, znak < oznacza m\u0142odszy bajt adresu, znak > oznacza starszy bajt adresu. DATA_LENGTH To liczba 2-bajtowych danych (adres\u00f3w) do modyfikacji. DATA To w\u0142a\u015bciwy ci\u0105g danych s\u0142u\u017c\u0105cych modyfikacji g\u0142\u00f3wnego bloku relokowalnego. Pod wskazanym tutaj adresem nale\u017cy odczyta\u0107 warto\u015b\u0107 typu TYPE a nast\u0119pnie zmodyfikowa\u0107 na podstawie nowego adresu \u0142adowania. Wyj\u0105tek stanowi blok aktualizacji dla starszych bajt\u00f3w adres\u00f3w > , dla takiego bloku w DATA zapisywany jest jeszcze dodatkowy bajt BYTE (m\u0142odszy bajt modyfikowanego adresu). Aby dokona\u0107 aktualizacji starszych bajt\u00f3w, musimy odczyta\u0107 bajt spod adresu WORD w DATA , doda\u0107 go do aktualnego adresu relokacji i doda\u0107 jeszcze m\u0142odszy bajt z BYTE w DATA . Tak nowo obliczony starszy bajt umieszczamy pod adresem WORD z DATA .","title":"Blok relokowalny .RELOC"},{"location":"kod-relokowalny/#symbole-zewnetrzne-extrn","text":"Symbole zewn\u0119trzne informuj\u0105, \u017ce zmienne i procedury kt\u00f3re reprezentuj\u0105 b\u0119d\u0105 znajdowa\u0142y si\u0119 gdzie\u015b na zewn\u0105trz, poza aktualnym programem. Nie musimy okre\u015bla\u0107 gdzie. Musimy jedynie poda\u0107 ich nazwy oraz typy. W zale\u017cno\u015bci od typu danych jakie reprezentuje symbol instrukcje asemblera t\u0142umaczone s\u0105 na odpowiednie kody maszynowe, asembler musi zna\u0107 rozmiar u\u017cywanych danych. UWAGA: Aktualnie nie istnieje mo\u017cliwo\u015b\u0107 dokonywania operacji na symbolach external typu ^ (najstarszy bajt). Symbole zewn\u0119trzne mog\u0105 by\u0107 u\u017cywane w blokach relokowalnych .RELOC jak i w zwyk\u0142ych blokach DOS . Symbole zewn\u0119trzne external deklarujemy u\u017cywaj\u0105c pseudo rozkazu EXT lub dyrektywy .EXTRN : label EXT type label .EXTRN type .EXTRN label1,label2,label3... type .extrn PlaySfx .proc (.byte PlaySfx.note, PlaySfx.fx) .var Blok aktualizacji dla symboli external wywo\u0142ujemy u\u017cywaj\u0105c pseudo rozkazu BLK : BLK UPDATE EXTERNAL UWAGA: Zostan\u0105 zapisane symbole, kt\u00f3re zosta\u0142y u\u017cyte w programie. Symbole external nie maj\u0105 zdefiniowanej warto\u015bci tylko typ .BYTE .WORD .LONG .DWORD np.: name EXT .BYTE label_name EXT .WORD .EXTRN label_name .WORD wait EXT .PROC (.BYTE delay) Symbol external z deklaracj\u0105 procedury .PROC przyjmuje domy\u015blnie typ .WORD , pr\u00f3ba odwo\u0142ania si\u0119 do nazwy takiej etykiety zostanie potraktowana przez MADS jako pr\u00f3ba wywo\u0142ania procedury, wi\u0119cej na temat wywo\u0142a\u0144 procedur .PROC w rozdziale Procedury . W procesie asemblacji po napotkaniu odwo\u0142ania do symbolu external zawsze podstawiane s\u0105 zera. Symbole external przyda\u0107 si\u0119 nam mog\u0105 w\u00f3wczas gdy chcemy zasemblowa\u0107 program oddzielnie, niezale\u017cnie od reszty w\u0142a\u015bciwego programu. W takim programie wyst\u0119puj\u0105 w\u00f3wczas najcz\u0119\u015bciej odwo\u0142ania do procedur, zmiennych kt\u00f3re zosta\u0142y zdefiniowane gdzie\u015b indziej, na zewn\u0105trz, a my nie znamy ich warto\u015bci tylko typ. W tym momencie z pomoc\u0105 przychodz\u0105 symbole external , kt\u00f3re umo\u017cliwiaj\u0105 asemblacj\u0119 takiego programu mimo braku w\u0142a\u015bciwych procedur czy zmiennych. Innym zastosowaniem symboli external mog\u0105 by\u0107 tzw. pluginy programy zewn\u0119trzne po\u0142\u0105czone z programem g\u0142\u00f3wnym i realizuj\u0105ce dodatkowe czynno\u015bci. S\u0105 to swoistego rodzaje biblioteki, wykorzystuj\u0105ce procedury programu g\u0142\u00f3wnego, rozszerzaj\u0105ce jego funkcjonalno\u015b\u0107. Aby stworzy\u0107 taki plugin nale\u017ca\u0142oby okre\u015bli\u0107 jakie procedury udost\u0119pnia program g\u0142\u00f3wny (ich nazwy+parametry i typ) oraz stworzy\u0107 procedur\u0119 odczytu pliku z symbolami external , ta procedura realizowa\u0142aby do\u0142\u0105czanie plugin\u00f3w do g\u0142\u00f3wnego programu. Poni\u017cej format zapisu nag\u0142\u00f3wka w pliku z symbolami external typu B -YTE, W -ORD, L -ONG i D -WORD po wywo\u0142aniu przez BLK UPDATE EXTERNAL : HEADER WORD ($FFEE) TYPE CHAR (B-YTE, W-ORD, L-ONG, D-WORD, <, >) DATA_LENGTH WORD LABEL_LENGTH WORD LABEL_NAME ATASCII DATA WORD .. .. .. HEADER Zawsze o warto\u015bci $FFEE . TYPE Typ danych zapisany jest na bitach 0..6 tego bajtu i okre\u015bla typ modyfikowanych adres\u00f3w. DATA_LENGTH To liczba 2-bajtowych danych (adres\u00f3w) do modyfikacji. LABEL_LENGTH To d\u0142ugo\u015b\u0107 nazwy symbolu wyra\u017cona w bajtach. LABEL_NAME To nazwa symbolu w kodach ATASCII . DATA W\u0142a\u015bciwy ci\u0105g danych s\u0142u\u017c\u0105cych modyfikacji g\u0142\u00f3wnego bloku relokowalnego. Pod wskazanym tutaj adresem nale\u017cy odczyta\u0107 warto\u015b\u0107 typu TYPE a nast\u0119pnie zmodyfikowa\u0107 na podstawie nowej warto\u015bci symbolu. Przyk\u0142adem zastosowania symboli external i struktur .STRUCT jest przyk\u0142adowa biblioteka prymityw\u00f3w graficznych PLOT LINE CIRCLE z katalogu ..\\EXAMPLES\\LIBRARIES\\GRAPHICS\\LIB . Poszczeg\u00f3lne modu\u0142y wykorzystuj\u0105 tutaj do\u015b\u0107 spor\u0105 liczb\u0119 zmiennych na stronie zerowej, je\u015bli chcemy aby adresy tych zmiennych by\u0142y relokowalne musieliby\u015bmy ka\u017cd\u0105 z osobna zmienn\u0105 zadeklarowa\u0107 jako symbol zewn\u0119trzny przez EXT .EXTRN . Mo\u017cemy to upro\u015bci\u0107 wykorzystuj\u0105c tylko jeden symbol zewn\u0119trzny i struktur\u0119 danych .STRUCT . Za pomoc\u0105 struktur definiujemy map\u0119 zmiennych ZP , potem jeden symbol external ZPAGE typu .BYTE bo chcemy aby zmienne by\u0142y na stronie zerowej. Teraz odwo\u0142uj\u0105c si\u0119 do zmiennej musimy zapisa\u0107 to w spos\u00f3b wymuszaj\u0105cy relokowalno\u015b\u0107 np. ZPAGE+ZP.DX i tak powsta\u0142 modu\u0142 ca\u0142kowicie relokowalny z mo\u017cliwo\u015bci\u0105 zmiany adresu zmiennych w przestrzeni strony zerowej.","title":"Symbole zewn\u0119trzne .EXTRN"},{"location":"kod-relokowalny/#symbole-publiczne-public","text":"Symbole publiczne udost\u0119pniaj\u0105 zmienne i procedury wyst\u0119puj\u0105ce w bloku relokowalnym pozosta\u0142ej cz\u0119\u015bci asemblowanego programu. Dzi\u0119ki symbolom publicznym mo\u017cemy odwo\u0142ywa\u0107 si\u0119 do zmiennych i procedur zaszytych np. w bibliotekach. Symbole publiczne mog\u0105 by\u0107 u\u017cywane w blokach relokowalnych .RELOC jak i w zwyk\u0142ych blokach DOS . MADS sam rozpoznaje czy podana do upublicznienia etykieta jest zmienn\u0105, sta\u0142\u0105 czy te\u017c procedur\u0105 zadeklarown\u0105 przez .PROC , nie jest wymagana \u017cadna dodatkowa informacja jak w przypadku symboli zewn\u0119trznych. Symbole publiczne deklarujemy u\u017cywaj\u0105c n/w dyrektyw: .PUBLIC label [,label2,...] .GLOBAL label [,label2,...] .GLOBL label [,label2,...] Dyrektywy .GLOBAL .GLOBL zosta\u0142y dodane z my\u015bl\u0105 o kompatybilno\u015bci z innymi assemblerami, ich znaczenie jest identyczne z dyrektyw\u0105 .PUBLIC . Blok aktualizacji dla symboli publicznych wywo\u0142ujemy u\u017cywaj\u0105c pseudo rozkazu BLK : BLK UPDATE PUBLIC Poni\u017cej format zapisu nag\u0142\u00f3wka w pliku z symbolami publicznymi po wywo\u0142aniu przez BLK UPDATE PUBLIC : HEADER WORD ($FFED) LENGTH WORD TYPE BYTE (B-YTE, W-ORD, L-ONG, D-WORD) LABEL_TYPE CHAR (C-ONSTANT, V-ARIABLE, P-ROCEDURE, A-RRAY, S-TRUCT) LABEL_LENGTH WORD LABEL_NAME ATASCII ADDRESS WORD MADS automatycznie dobiera odpowiedni typ dla upublicznianej etykiety: C-ONSTANT etykieta nie poddaj\u0105ca si\u0119 relokacji V-ARIABLE etykieta poddaj\u0105ca si\u0119 relokacji P-ROCEDURE procedura zadeklarowana przez .PROC, podlega relokacji A-RRAY tablica zadeklarowana przez .ARRAY, podlega relokacji S-TRUCT struktura zadeklarowana przez .STRUCT, nie podlega relokacji Je\u015bli symbol dotyczy struktury .STRUCT w\u00f3wczas zapisywane s\u0105 dodatkowe informacje (typ pola struktury, nazwa pola struktury, liczba powt\u00f3rze\u0144 pola struktury): STRUCT_LABEL_TYPE CHAR (B-YTE, W-ORD, L-ONG, D-WORD) STRUCT_LABEL_LENGTH WORD STRUCT_LABEL_NAME ATASCII STRUCT_LABEL_REPEAT WORD Je\u015bli symbol dotyczy tablicy .ARRAY w\u00f3wczas zapisywane s\u0105 dodatkowe informacje (maksymalny zadeklarowany indeks tablicy, typ zadeklarowanych p\u00f3l tablicy): ARRAY_MAX_INDEX WORD ARRAY_TYPE CHAR (B-YTE, W-ORD, L-ONG, D-WORD) Je\u015bli symbol dotyczy procedury .PROC w\u00f3wczas zapisywane s\u0105 dodatkowe informacje, niezale\u017cnie od tego czy procedura mia\u0142a czy te\u017c nie mia\u0142a zadeklarowane parametry: PROC_CPU_REG BYTE (bits 00 - regA, 01 - regX, 10 - regY) PROC_TYPE BYTE (D-EFAULT, R-EGISTRY, V-ARIABLE) PARAM_COUNT WORD Dla symboli dotycz\u0105cych procedur .REG zapisywane s\u0105 ju\u017c teraz tylko typy tych parametr\u00f3w w ilo\u015bci PARAM_COUNT : PARAM_TYPE CHAR (B-YTE, W-ORD, L-ONG, D-WORD) ... ... Dla symboli dotycz\u0105cych procedur .VAR zapisywane s\u0105 typy parametr\u00f3w i ich nazwy. PARAM_COUNT okre\u015bla ca\u0142kowit\u0105 d\u0142ugo\u015b\u0107 tych danych: PARAM_TYPE CHAR (B-YTE, W-ORD, L-ONG, D-WORD) PARAM_LENGTH WORD PARAM_NAME ATASCII ... ... HEADER Zawsze o warto\u015bci $FFED . LENGTH To liczba symboli zapisanych w bloku aktualizacji. TYPE Typ symbolizowanych danych B -YTE, W -ORD, L -ONG, D -WORD. LABEL_TYPE Typ symbolu: V-ARIABLE, C-ONSTANT, P-ROCEDURE, A-RRAY, S-TRUCT Dla typu P zapisywane s\u0105 dodatkowe informacje: PROC_CPU_REG, PROC_TYPE, PARAM_COUNT, PARAM_TYPE Dla typu A zapisywane s\u0105 dodatkowe informacje: ARRAY_MAX_INDEX, ARRAY_TYPE Dla typu S zapisywane s\u0105 dodatkowe informacje: STRUCT_LABEL_TYPE, STRUCT_LABEL_LENGTH, STRUCT_LABEL_NAME, STRUCT_LABEL_REPEAT Typ symbolizowanych danych B -YTE, W -ORD, L -ONG, D -WORD. LABEL_LENGTH D\u0142ugo\u015b\u0107 etykiety symbolu publicznego wyra\u017cona w bajtach LABEL_LENGTH D\u0142ugo\u015b\u0107 etykiety symbolu publicznego wyra\u017cona w bajtach LABEL_NAME Etykieta symbolu publicznego zapisana w kodach ATASCII ADDRESS Adres przypisany symbolowi w bloku relokowalnym .RELOC . Ta warto\u015b\u0107 zostaje poddana relokacji poprzez dodanie do niej aktualnego adresu asemblacji. PROC_CPU_REG Informacja o kolejno\u015bci u\u017cycia rejestr\u00f3w CPU dla procedury typu .REG PROC_TYPE D -EFAULT domy\u015blny typ wykorzystuj\u0105cy do przekazywania parametr\u00f3w stos programowy MADS R -EGISTRY parametry do procedury przekazywane s\u0105 przez rejestry CPU .REG V -ARIABLE parametry do procedury przekazywane s\u0105 przez zmienne .VAR PARAM_COUNT Informacja o liczbie parametr\u00f3w procedury .REG lub ca\u0142kowitej d\u0142ugo\u015bci danych zawieraj\u0105cych informacj\u0119 o typie parametr\u00f3w i ich nazwach .VAR . PARAM_TYPE Typ parametr\u00f3w zapisany za pomoc\u0105 znak\u00f3w B W L D PARAM_LENGTH D\u0142ugo\u015b\u0107 nazwy parametru .VAR . PARAM_NAME Nazwa parametru w kodach ATASCII .VAR .","title":"Symbole publiczne .PUBLIC"},{"location":"kod-relokowalny/#dyrektywy-longa-longi","text":".LONGA ON|OFF .LONGI ON|OFF Dyrektywa .LONGA informuje assembler o rozmiarze rejestru akumulatora, 16bit gdy ON, 8bit gdy OFF. Dyrektywa .LONGI informuje assembler o rozmiarze rejestr\u00f3w indeksowych XY , 16bit gdy ON, 8bit gdy OFF. Dyrektywy wp\u0142ywaj\u0105 na rozmiar argumentu przy adresowaniu absolutnym CPU 65816 .","title":"Dyrektywy .LONGA .LONGI"},{"location":"kod-relokowalny/#linkowanie-link","text":".LINK 'filename' Dyrektywa .LINK wymaga podania jako parametru nazwy pliku do relokacji. Akceptowane s\u0105 tylko pliki DOS Atari , pliki SDX nie s\u0105 akceptowane. Je\u015bli adres \u0142adowania pliku jest inny ni\u017c $0000 oznacza to \u017ce plik nie zawiera kodu relokowalnego, jednak mo\u017ce zawiera\u0107 bloki aktualizacji dla symboli zewn\u0119trznych i publicznych. Dyrektywa .LINK akceptuje pliki o dowolnym adresie \u0142adowania, jednak relokacji poddawane s\u0105 tylko te o adresie \u0142adowania $0000 , wi\u0119cej szczeg\u00f3\u0142\u00f3w na temat budowy takiego pliku zosta\u0142o zawartych w rozdziale Blok relokowalny .RELOC . Dyrektywa .LINK pozwala na \u0142\u0105czenie kodu relokowalnego z nierelokowalnym. MADS na podstawie blok\u00f3w aktualizacji dokonuje automatycznej relokacji takiego pliku. Uwzgl\u0119dniane s\u0105 wszystkie 3 rodzaje blok\u00f3w aktualizacji ADDRESS EXTERNAL PUBLIC . Nie ma ogranicze\u0144 co do adresu pod kt\u00f3rym umieszczany jest plik relokowalny. Je\u015bli blok relokowalny do dzia\u0142ania wymaga stosu programowego MADS w\u00f3wczas etykiety @STACK_POINTER @STACK_ADDRESS @PROC_VARS_ADR zostan\u0105 automatycznie zaktualizowane na podstawie nag\u0142\u00f3wka bloku .RELOC . Wymagane jest aby bloki .RELOC i program g\u0142\u00f3wny operowa\u0142y na tym samym stosie programowym je\u015bli jest on konieczny.","title":"Linkowanie .LINK"},{"location":"kontrola/","text":"Kontrola asemblacji Zmiana opcji asemblacji Asemblacja warunkowa Przerwanie asemblacji Asemblacja na stronie zerowej W przeciwie\u0144stwie do dwu-przebiegowych asembler\u00f3w takich jak QA i XASM , MADS jest wielo-przebiegowy. Co to daje ? We\u017amy sobie taki przyk\u0142ad: org $00 lda tmp+1 tmp lda #$00 Dwu-przebiegowy assembler nie znaj\u0105c warto\u015bci etykiety TMP przyjmie domy\u015blnie, \u017ce jej warto\u015b\u0107 b\u0119dzie dwu-bajtowa, czyli typu WORD i wygeneruje rozkaz LDA W . Natomiast MADS uprzejmie wygeneruje rozkaz strony zerowej LDA Z . I to w\u0142a\u015bciwie g\u0142\u00f3wna i najprostsza do wyt\u0142umaczenia w\u0142a\u015bciwo\u015b\u0107 wi\u0119kszej liczby przebieg\u00f3w. Teraz kto\u015b powie, \u017ce woli gdy rozkaz odwo\u0142uj\u0105cy si\u0119 do strony zerowej ma posta\u0107 LDA W . Nie ma sprawy, wystarczy \u017ce rozszerzy mnemonik: org $00 lda.w tmp+1 tmp lda #$00 S\u0105 dopuszczalne trzy rozszerzenia mnemonika .b[.z] .w[.a][.q] .l[.t] czyli odpowiednio BYTE , WORD , LONG . Z czego ostatni generuje 24bitow\u0105 warto\u015b\u0107 i odnosi si\u0119 do 65816 i pami\u0119ci o ci\u0105g\u0142ym obszarze. Wi\u0119cej informacji na temat mnemonik\u00f3w CPU 6502 , 65816 oraz ich dopuszczalnych rozszerze\u0144 w rodziale [Mnemoniki]. Innym sposobem na wymuszenie rozkazu strony zerowej jest u\u017cycie nawias\u00f3w klamrowych { } np. dta {lda $00},$80 ; lda $80 W MADS mo\u017cemy robi\u0107 tak samo, ale po co, ostatni przebieg za\u0142atwi spraw\u0119 za nas :) Problem stanowi teraz umieszczenie takiego fragmentu kodu w pami\u0119ci komputera. Mo\u017cemy spr\u00f3bowa\u0107 za\u0142adowa\u0107 taki program bezpo\u015brednio na stron\u0119 zerow\u0105 i je\u015bli obszar docelowy mie\u015bci si\u0119 w granicy $80..$FF to pewnie OS prze\u017cyje, poni\u017cej tego obszaru b\u0119dzie trudniej. Dlatego MADS umo\u017cliwia takie co\u015b: org $20,$3080 lda tmp+1 tmp lda #$00 Czyli asembluj od adresu $0020 , ale za\u0142aduj pod adres $3080 . Oczywi\u015bcie p\u00f3\u017aniejsze przeniesienie kodu pod w\u0142a\u015bciwy adres (w naszym przyk\u0142adzie $0020 ) nale\u017cy ju\u017c do zada\u0144 programisty. Podsumowuj\u0105c: org adres1,adres2 Asembluj od adresu adres1 , umie\u015b\u0107 w pami\u0119ci od adresu adres2 . Taki ORG zawsze spowoduje stworzenie nowego bloku w pliku, czyli zostan\u0105 zapisane dodatkowe cztery bajty nag\u0142\u00f3wka nowego bloku. Je\u015bli nie zale\u017cy nam na nowym adresie umiejscowienia danych w pami\u0119ci, adresem umiejscowienia danych ma by\u0107 aktualny adres w\u00f3wczas mo\u017cemy skorzysta\u0107 z w\u0142a\u015bciwo\u015bci blok\u00f3w .LOCAL i .PROC , bajty nag\u0142\u00f3wka nie b\u0119d\u0105 w takim przypadku zapisywane, np.: 1 2 org $2000 3 4 FFFF> 2000-200D> A9 00 lda #0 5 2002 EA nop 6 7 0060 .local temp, $60 8 9 0060 BD FF FF lda $ffff,x 10 0063 BE FF FF ldx $ffff,y 11 12 .endl 13 14 2009 A5 60 lda temp 15 200B AD 03 20 lda .adr temp 16 Dla w/w przyk\u0142adu blok programu TEMP zostanie zasemblowany z nowym adresem = $60 i umiejscowiony w pami\u0119ci pod adresem $2003 . Po dyrektywie ko\u0144cz\u0105cej blok ( .ENDL , .ENDP , .END ) przywracamy jest adres asemblacji sprzed bloku plus jeszcze d\u0142ugo\u015b\u0107 tak zasemblowanego bloku, w naszym przyk\u0142adzie adresem od kt\u00f3rego b\u0119dzie kontynuowana asemblacja po zako\u0144czeniu bloku .LOCAL b\u0119dzie adres $2009 . Nast\u0119pnie wykorzystuj\u0105c dyrektywy .ADR i .LEN mo\u017cna dokona\u0107 skopiowania takiego bloku pod w\u0142a\u015bciwy adres, np.: ldy #0 copy mva .adr(temp),y temp,y+ cpy #.len temp bne copy Wi\u0119cej informacji na temat dzia\u0142ania dyrektyw .ADR i .LEN .","title":"Kontrola asemblacji"},{"location":"kontrola/#kontrola-asemblacji","text":"","title":"Kontrola asemblacji"},{"location":"kontrola/#zmiana-opcji-asemblacji","text":"","title":"Zmiana opcji asemblacji"},{"location":"kontrola/#asemblacja-warunkowa","text":"","title":"Asemblacja warunkowa"},{"location":"kontrola/#przerwanie-asemblacji","text":"","title":"Przerwanie asemblacji"},{"location":"kontrola/#asemblacja-na-stronie-zerowej","text":"W przeciwie\u0144stwie do dwu-przebiegowych asembler\u00f3w takich jak QA i XASM , MADS jest wielo-przebiegowy. Co to daje ? We\u017amy sobie taki przyk\u0142ad: org $00 lda tmp+1 tmp lda #$00 Dwu-przebiegowy assembler nie znaj\u0105c warto\u015bci etykiety TMP przyjmie domy\u015blnie, \u017ce jej warto\u015b\u0107 b\u0119dzie dwu-bajtowa, czyli typu WORD i wygeneruje rozkaz LDA W . Natomiast MADS uprzejmie wygeneruje rozkaz strony zerowej LDA Z . I to w\u0142a\u015bciwie g\u0142\u00f3wna i najprostsza do wyt\u0142umaczenia w\u0142a\u015bciwo\u015b\u0107 wi\u0119kszej liczby przebieg\u00f3w. Teraz kto\u015b powie, \u017ce woli gdy rozkaz odwo\u0142uj\u0105cy si\u0119 do strony zerowej ma posta\u0107 LDA W . Nie ma sprawy, wystarczy \u017ce rozszerzy mnemonik: org $00 lda.w tmp+1 tmp lda #$00 S\u0105 dopuszczalne trzy rozszerzenia mnemonika .b[.z] .w[.a][.q] .l[.t] czyli odpowiednio BYTE , WORD , LONG . Z czego ostatni generuje 24bitow\u0105 warto\u015b\u0107 i odnosi si\u0119 do 65816 i pami\u0119ci o ci\u0105g\u0142ym obszarze. Wi\u0119cej informacji na temat mnemonik\u00f3w CPU 6502 , 65816 oraz ich dopuszczalnych rozszerze\u0144 w rodziale [Mnemoniki]. Innym sposobem na wymuszenie rozkazu strony zerowej jest u\u017cycie nawias\u00f3w klamrowych { } np. dta {lda $00},$80 ; lda $80 W MADS mo\u017cemy robi\u0107 tak samo, ale po co, ostatni przebieg za\u0142atwi spraw\u0119 za nas :) Problem stanowi teraz umieszczenie takiego fragmentu kodu w pami\u0119ci komputera. Mo\u017cemy spr\u00f3bowa\u0107 za\u0142adowa\u0107 taki program bezpo\u015brednio na stron\u0119 zerow\u0105 i je\u015bli obszar docelowy mie\u015bci si\u0119 w granicy $80..$FF to pewnie OS prze\u017cyje, poni\u017cej tego obszaru b\u0119dzie trudniej. Dlatego MADS umo\u017cliwia takie co\u015b: org $20,$3080 lda tmp+1 tmp lda #$00 Czyli asembluj od adresu $0020 , ale za\u0142aduj pod adres $3080 . Oczywi\u015bcie p\u00f3\u017aniejsze przeniesienie kodu pod w\u0142a\u015bciwy adres (w naszym przyk\u0142adzie $0020 ) nale\u017cy ju\u017c do zada\u0144 programisty. Podsumowuj\u0105c: org adres1,adres2 Asembluj od adresu adres1 , umie\u015b\u0107 w pami\u0119ci od adresu adres2 . Taki ORG zawsze spowoduje stworzenie nowego bloku w pliku, czyli zostan\u0105 zapisane dodatkowe cztery bajty nag\u0142\u00f3wka nowego bloku. Je\u015bli nie zale\u017cy nam na nowym adresie umiejscowienia danych w pami\u0119ci, adresem umiejscowienia danych ma by\u0107 aktualny adres w\u00f3wczas mo\u017cemy skorzysta\u0107 z w\u0142a\u015bciwo\u015bci blok\u00f3w .LOCAL i .PROC , bajty nag\u0142\u00f3wka nie b\u0119d\u0105 w takim przypadku zapisywane, np.: 1 2 org $2000 3 4 FFFF> 2000-200D> A9 00 lda #0 5 2002 EA nop 6 7 0060 .local temp, $60 8 9 0060 BD FF FF lda $ffff,x 10 0063 BE FF FF ldx $ffff,y 11 12 .endl 13 14 2009 A5 60 lda temp 15 200B AD 03 20 lda .adr temp 16 Dla w/w przyk\u0142adu blok programu TEMP zostanie zasemblowany z nowym adresem = $60 i umiejscowiony w pami\u0119ci pod adresem $2003 . Po dyrektywie ko\u0144cz\u0105cej blok ( .ENDL , .ENDP , .END ) przywracamy jest adres asemblacji sprzed bloku plus jeszcze d\u0142ugo\u015b\u0107 tak zasemblowanego bloku, w naszym przyk\u0142adzie adresem od kt\u00f3rego b\u0119dzie kontynuowana asemblacja po zako\u0144czeniu bloku .LOCAL b\u0119dzie adres $2009 . Nast\u0119pnie wykorzystuj\u0105c dyrektywy .ADR i .LEN mo\u017cna dokona\u0107 skopiowania takiego bloku pod w\u0142a\u015bciwy adres, np.: ldy #0 copy mva .adr(temp),y temp,y+ cpy #.len temp bne copy Wi\u0119cej informacji na temat dzia\u0142ania dyrektyw .ADR i .LEN .","title":"Asemblacja na stronie zerowej"},{"location":"lokal/","text":"Obszar lokalny G\u0142\u00f3wnym zadaniem obszaru lokalnego w MADS jest stworzenie nowej przestrzeni nazw dla etykiet. Wszelkie etykiety zdefiniowane w obszarze lokalnym .LOCAL s\u0105 zasi\u0119gu lokalnego, mo\u017cna je te\u017c okre\u015bli\u0107 jako etykiety globalne zdefiniowane lokalnie o dost\u0119pie swobodnym, poniewa\u017c mo\u017cna si\u0119 do nich odwo\u0142ywa\u0107 co nie jest normalne w innych j\u0119zykach programowania. Obszary lokalne s\u0105 addytywne tzn. \u017ce mo\u017ce by\u0107 wiele blok\u00f3w .LOCAL o tej samej nazwie, nie zostanie wygenerowany komunikat b\u0142\u0119du Label ... declared twice . Addytywno\u015b\u0107 obszar\u00f3w lokalnych odbywa si\u0119 na aktualnym poziomie przestrzeni nazw, je\u015bli chcemy po\u0142\u0105czy\u0107 si\u0119 z wybranym obszarem lokalnym w innej przestrzeni nazw, poprzedzamy pe\u0142n\u0105 nazw\u0119 prowadz\u0105c\u0105 do takiego obszaru znakiem + , np.: .local lvl tmp = 3 .endl .local temp tmp = 7 .local +lvl .print tmp .endl .endl Dla w/w przyk\u0142adu zostanie wy\u015bwietlona warto\u015b\u0107 etykiety TMP z obszaru lokalnego LVL o warto\u015bci 3 . Gdyby zabrak\u0142o znaku + w .LOCAL +LVL w\u00f3wczas warto\u015b\u0107 TMP jaka zostanie wy\u015bwietlona to 7 . W obszarze lokalnym .LOCAL istnieje mo\u017cliwo\u015b\u0107 zdefiniowania etykiet o zasi\u0119gu globalnym (patrz rozdzia\u0142 Etykiety globalne ). Je\u015bli poszukiwana przez assembler etykieta nie wyst\u0105pi\u0142a w obszarze lokalnym .LOCAL , w\u00f3wczas MADS b\u0119dzie poszukiwa\u0142 j\u0105 w obszarze ni\u017cszym a\u017c dojdzie do obszaru globalnego. Aby odczyta\u0107 natychmiastowo warto\u015b\u0107 etykiety globalnej z poziomu obszaru lokalnego .LOCAL (czy te\u017c innego obszaru lokalnego) poprzedzamy nazw\u0119 etykiety znakiem dwukropka : . Obszar\u00f3w lokalnych dotycz\u0105 n/w dyrektywy: [name] .LOCAL [,address] .LOCAL [name] [,address] .ENDL [.LEND] [.END] [name] .LOCAL [,address] Deklaracja obszaru lokalnego o nazwie name za pomoc\u0105 dyrektywy .LOCAL . Nazwa obszaru nie jest wymagana i nie jest konieczna. Do nazw obszar\u00f3w lokalnych nie mo\u017cna u\u017cywa\u0107 nazw mnemonik\u00f3w i pseudo rozkaz\u00f3w. Je\u015bli nazwa jest zarezerwowana wyst\u0105pi b\u0142\u0105d z komunikatem Reserved word . Po nazwie obszaru lokalnego (lub po dyrektywie .LOCAL ) mo\u017cemy poda\u0107 nowy adres asemblacji bloku lokalnego. Po zako\u0144czeniu takiego bloku ( .ENDL ) przywracany jest poprzedni adres asemblacji zwi\u0119kszony o d\u0142ugo\u015b\u0107 bloku lokalnego. label .local,$4000 .endl .local label2,$8000 .endl .local .endl .local label3 .endl Wszelkie definicje etykiet w obszarze .LOCAL s\u0105 typu lokalnego. Aby odwo\u0142a\u0107 si\u0119 do etykiety globalnej o tej samej nazwie co etykieta lokalna nale\u017cy poprzedzi\u0107 j\u0105 znakiem dwukropka : , np.: lab equ 1 .local lab equ 2 lda #lab ldx #:lab .endl W w/w przyk\u0142adzie do rejestru A zostanie za\u0142adowana warto\u015b\u0107 2 , natomiast do rejestru X warto\u015b\u0107 1 . Je\u015bli poszukiwana przez assembler etykieta nie wyst\u0105pi\u0142a w obszarze .LOCAL , w\u00f3wczas nast\u0105pi jej szukanie w obszarze makra (je\u015bli jest aktualnie przetwarzane), potem w procedurze (je\u015bli procedura jest aktualnie przetwarzana), na ko\u0144cu w g\u0142\u00f3wnym programie. W zadeklarowanym obszarze lokalnym wszystkie definicje etykiet rozr\u00f3\u017cniane s\u0105 na podstawie nazwy obszaru lokalnego. Aby dotrze\u0107 do zdefiniowanej etykiety w obszarze lokalnym spoza obszaru lokalnego musimy zna\u0107 nazw\u0119 obszaru i etykiety w nim wyst\u0119puj\u0105cej, np.: lda #name.lab1 ldx #name.lab2 .local name lab1 = 1 lab2 = 2 .endl W adresowaniu takiej struktury .LOCAL u\u017cywamy znaku kropki . . Obszary lokalne mo\u017cemy zagnie\u017cd\u017ca\u0107, mo\u017cemy je umieszcza\u0107 w ciele procedur zadeklarowanych przez dyrektyw\u0119 .PROC . Obszary lokalne s\u0105 addytywne, tzn. mo\u017ce istnie\u0107 wiele obszar\u00f3w lokalnych o tej samej nazwie, wszystkie symbole wyst\u0119puj\u0105ce w tych obszarach nale\u017ce\u0107 b\u0119d\u0105 do wsp\u00f3lnej przestrzeni nazw. D\u0142ugo\u015b\u0107 wygenerowanego kodu w bloku .LOCAL mo\u017cna sprawdzi\u0107 przy pomocy dyrektywy .LEN ( .SIZEOF ). .ENDL Dyrektywa .ENDL ko\u0144czy deklaracj\u0119 obszaru lokalnego. Przyk\u0142ad deklaracji obszaru lokalnego: org $2000 tmp ldx #0 <------------- etykieta w obszarze globalnym | lda obszar.pole <--- | odwolanie do obszaru lokalnego | | .local obszar | | deklaracja obszaru lokalnego | | lda tmp <--- | | | | | lda :tmp | | <--- odwolanie do obszaru globalnego | | tmp nop <--- | definicja w obszarze lokalnym | pole lda #0 <--- <--- definicja w obszarze lokalnym | lda pole <----------------- odwolanie w obszarze lokalnym .endl koniec deklaracji obszaru lokalnego","title":"Obszar lokalny"},{"location":"lokal/#obszar-lokalny","text":"G\u0142\u00f3wnym zadaniem obszaru lokalnego w MADS jest stworzenie nowej przestrzeni nazw dla etykiet. Wszelkie etykiety zdefiniowane w obszarze lokalnym .LOCAL s\u0105 zasi\u0119gu lokalnego, mo\u017cna je te\u017c okre\u015bli\u0107 jako etykiety globalne zdefiniowane lokalnie o dost\u0119pie swobodnym, poniewa\u017c mo\u017cna si\u0119 do nich odwo\u0142ywa\u0107 co nie jest normalne w innych j\u0119zykach programowania. Obszary lokalne s\u0105 addytywne tzn. \u017ce mo\u017ce by\u0107 wiele blok\u00f3w .LOCAL o tej samej nazwie, nie zostanie wygenerowany komunikat b\u0142\u0119du Label ... declared twice . Addytywno\u015b\u0107 obszar\u00f3w lokalnych odbywa si\u0119 na aktualnym poziomie przestrzeni nazw, je\u015bli chcemy po\u0142\u0105czy\u0107 si\u0119 z wybranym obszarem lokalnym w innej przestrzeni nazw, poprzedzamy pe\u0142n\u0105 nazw\u0119 prowadz\u0105c\u0105 do takiego obszaru znakiem + , np.: .local lvl tmp = 3 .endl .local temp tmp = 7 .local +lvl .print tmp .endl .endl Dla w/w przyk\u0142adu zostanie wy\u015bwietlona warto\u015b\u0107 etykiety TMP z obszaru lokalnego LVL o warto\u015bci 3 . Gdyby zabrak\u0142o znaku + w .LOCAL +LVL w\u00f3wczas warto\u015b\u0107 TMP jaka zostanie wy\u015bwietlona to 7 . W obszarze lokalnym .LOCAL istnieje mo\u017cliwo\u015b\u0107 zdefiniowania etykiet o zasi\u0119gu globalnym (patrz rozdzia\u0142 Etykiety globalne ). Je\u015bli poszukiwana przez assembler etykieta nie wyst\u0105pi\u0142a w obszarze lokalnym .LOCAL , w\u00f3wczas MADS b\u0119dzie poszukiwa\u0142 j\u0105 w obszarze ni\u017cszym a\u017c dojdzie do obszaru globalnego. Aby odczyta\u0107 natychmiastowo warto\u015b\u0107 etykiety globalnej z poziomu obszaru lokalnego .LOCAL (czy te\u017c innego obszaru lokalnego) poprzedzamy nazw\u0119 etykiety znakiem dwukropka : . Obszar\u00f3w lokalnych dotycz\u0105 n/w dyrektywy: [name] .LOCAL [,address] .LOCAL [name] [,address] .ENDL [.LEND] [.END]","title":"Obszar lokalny"},{"location":"lokal/#name-local-address","text":"Deklaracja obszaru lokalnego o nazwie name za pomoc\u0105 dyrektywy .LOCAL . Nazwa obszaru nie jest wymagana i nie jest konieczna. Do nazw obszar\u00f3w lokalnych nie mo\u017cna u\u017cywa\u0107 nazw mnemonik\u00f3w i pseudo rozkaz\u00f3w. Je\u015bli nazwa jest zarezerwowana wyst\u0105pi b\u0142\u0105d z komunikatem Reserved word . Po nazwie obszaru lokalnego (lub po dyrektywie .LOCAL ) mo\u017cemy poda\u0107 nowy adres asemblacji bloku lokalnego. Po zako\u0144czeniu takiego bloku ( .ENDL ) przywracany jest poprzedni adres asemblacji zwi\u0119kszony o d\u0142ugo\u015b\u0107 bloku lokalnego. label .local,$4000 .endl .local label2,$8000 .endl .local .endl .local label3 .endl Wszelkie definicje etykiet w obszarze .LOCAL s\u0105 typu lokalnego. Aby odwo\u0142a\u0107 si\u0119 do etykiety globalnej o tej samej nazwie co etykieta lokalna nale\u017cy poprzedzi\u0107 j\u0105 znakiem dwukropka : , np.: lab equ 1 .local lab equ 2 lda #lab ldx #:lab .endl W w/w przyk\u0142adzie do rejestru A zostanie za\u0142adowana warto\u015b\u0107 2 , natomiast do rejestru X warto\u015b\u0107 1 . Je\u015bli poszukiwana przez assembler etykieta nie wyst\u0105pi\u0142a w obszarze .LOCAL , w\u00f3wczas nast\u0105pi jej szukanie w obszarze makra (je\u015bli jest aktualnie przetwarzane), potem w procedurze (je\u015bli procedura jest aktualnie przetwarzana), na ko\u0144cu w g\u0142\u00f3wnym programie. W zadeklarowanym obszarze lokalnym wszystkie definicje etykiet rozr\u00f3\u017cniane s\u0105 na podstawie nazwy obszaru lokalnego. Aby dotrze\u0107 do zdefiniowanej etykiety w obszarze lokalnym spoza obszaru lokalnego musimy zna\u0107 nazw\u0119 obszaru i etykiety w nim wyst\u0119puj\u0105cej, np.: lda #name.lab1 ldx #name.lab2 .local name lab1 = 1 lab2 = 2 .endl W adresowaniu takiej struktury .LOCAL u\u017cywamy znaku kropki . . Obszary lokalne mo\u017cemy zagnie\u017cd\u017ca\u0107, mo\u017cemy je umieszcza\u0107 w ciele procedur zadeklarowanych przez dyrektyw\u0119 .PROC . Obszary lokalne s\u0105 addytywne, tzn. mo\u017ce istnie\u0107 wiele obszar\u00f3w lokalnych o tej samej nazwie, wszystkie symbole wyst\u0119puj\u0105ce w tych obszarach nale\u017ce\u0107 b\u0119d\u0105 do wsp\u00f3lnej przestrzeni nazw. D\u0142ugo\u015b\u0107 wygenerowanego kodu w bloku .LOCAL mo\u017cna sprawdzi\u0107 przy pomocy dyrektywy .LEN ( .SIZEOF ).","title":"[name] .LOCAL [,address]"},{"location":"lokal/#endl","text":"Dyrektywa .ENDL ko\u0144czy deklaracj\u0119 obszaru lokalnego. Przyk\u0142ad deklaracji obszaru lokalnego: org $2000 tmp ldx #0 <------------- etykieta w obszarze globalnym | lda obszar.pole <--- | odwolanie do obszaru lokalnego | | .local obszar | | deklaracja obszaru lokalnego | | lda tmp <--- | | | | | lda :tmp | | <--- odwolanie do obszaru globalnego | | tmp nop <--- | definicja w obszarze lokalnym | pole lda #0 <--- <--- definicja w obszarze lokalnym | lda pole <----------------- odwolanie w obszarze lokalnym .endl koniec deklaracji obszaru lokalnego","title":".ENDL"},{"location":"makra/","text":"Makra Makra u\u0142atwiaj\u0105 nam wykonywanie powtarzaj\u0105cych si\u0119 czynno\u015bci, automatyzuj\u0105 je. Istniej\u0105 tylko w pami\u0119ci assemblera, dopiero w momencie wywo\u0142ania s\u0105 asemblowane. Przy ich pomocy MADS mo\u017ce odk\u0142ada\u0107 i zdejmowa\u0107 z programowego stosu parametry dla procedur zadeklarowanych dyrektyw\u0105 .PROC oraz prze\u0142\u0105cza\u0107 banki rozszerzonej pami\u0119ci w trybie BANK SENSITIVE ( OPT B+ ). Makra czytane s\u0105 tylko w pierwszym przebiegu assemblacji, dla n/w przyk\u0142adu makra znajduj\u0105ce si\u0119 w pliku do\u0142\u0105czanym przez ICL nie zostan\u0105 rozpoznane : .macro test icl 'dodatkowe_makra.mac' .endm Deklaracja makra Makr dotycz\u0105 n/w pseudo rozkazy i dyrektywy: name .MACRO [arg1, arg2 ...] ['separator'] [\"separator\"] .MACRO name [(arg1, arg2 ...)] ['separator'] [\"separator\"] .EXITM [.EXIT] .ENDM [.MEND] :[%%]parameter :[%%]label name .MACRO [(arg1, arg2 ...)] ['separator'] [\"separator\"] Deklaracja makra o nazwie name za pomoc\u0105 dyrektywy .MACRO . Nazwa makra jest wymagana i konieczna, jej brak wygeneruje b\u0142\u0105d. Do nazw makr nie mo\u017cna u\u017cywa\u0107 nazw mnemonik\u00f3w i pseudo rozkaz\u00f3w (b\u0142\u0105d Reserved word ). Dopuszczalna jest lista z etykietami nazw argument\u00f3w jakie b\u0119d\u0105 przekazywane do makra, taka lista mo\u017ce by\u0107 ograniczona dodatkowo nawiasem okr\u0105g\u0142ym ( ) . Przedstawianie argument\u00f3w w postaci nazw etykiet ma na celu poprawienie przejrzysto\u015bci kodu makra. W samym ciele makra mo\u017cna u\u017cywa\u0107 zamiennie nazw etykiet argument\u00f3w lub ich numerycznych odpowiednik\u00f3w. .macro SetColor val,reg lda :val sta :reg .endm Na ko\u0144cu deklaracji makra mo\u017ce wyst\u0105pi\u0107 deklaracja separatora i zarazem trybu przekazywania parametr\u00f3w do makra (pojedy\u0144czy apostrof bez zmian, podw\u00f3jny apostrof z rozbijaniem parametr\u00f3w na tryb adresacji i argument). Domy\u015blnym separatorem, rozdzielaj\u0105cym parametry przekazywane do makra jest znak przecinka , oraz spacji ' ' . name .MACRO 'separator' Pomi\u0119dzy pojedy\u0144czymi apostrofami ' ' mo\u017cemy umie\u015bci\u0107 znak separatora, kt\u00f3ry b\u0119dzie u\u017cywany do oddzielenia parametr\u00f3w przy wywo\u0142aniu makra (tylko do tego mog\u0105 s\u0142u\u017cy\u0107 pojedy\u0144cze apostrofy). name .MACRO \"separator\" Pomi\u0119dzy podw\u00f3jnymi apostrofami \" \" mo\u017cemy tak\u017ce umie\u015bci\u0107 znak separatora, kt\u00f3ry b\u0119dzie u\u017cywany do oddzielenia parametr\u00f3w przy wywo\u0142aniu makra. Dodatkowo u\u017cycie podw\u00f3jnego apostrofu sygnalizuje MADS -owi aby rozk\u0142ada\u0142 przekazywane parametry na dwa elementy: tryb adresacji i argument, np.: test #12 200 <30 test .macro \" \" .endm Makro TEST ma zadeklarowany separator-spacj\u0119 przy u\u017cyciu apostrofu \" , czyli po wywo\u0142aniu makra parametry zostan\u0105 roz\u0142o\u017cone na dwa elementy: tryb adresacji i argument. #12 -> tryb adresacji '#' argument 12 200 -> tryb adresacji ' ' argument 200 <30 -> tryb adresacji '#' argument 0 (obliczona warto\u015b\u0107 wyra\u017cenia \"<30\") test '#' 12 ' ' 200 '#' 0 UAWAGA #1: Parametry ze znakiem operatora < , > zostaj\u0105 obliczone i dopiero ich wynik jest przekazywany do makra (podstawiany pod parametr). UAWAGA #2: Je\u015bli parametrem makra jest licznik p\u0119tli # , .R (!!! pojedy\u0144czy znak # lub dyrektywa .R a nie wyra\u017cenie z udzia\u0142em tego znaku, tej dyrektywy !!!) w\u00f3wczas do makra przekazywana jest warto\u015b\u0107 licznika p\u0119tli (podstawiana pod parametr). T\u0105 w\u0142a\u015bciwo\u015b\u0107 mo\u017cemy wykorzysta\u0107 do stworzenia \"samopisz\u0105cego\" si\u0119 kodu, kiedy potrzebujemy tworzy\u0107 nowe etykiety typu \"label0\", \"label1\", \"label2\", \"label3\" ... itd. , np.: :32 find # find .macro ift .def label:1 dta a(label:1) eif .endm W/w przyk\u0142ad zapisuje adres etykiety pod warunkiem \u017ce taka etykiety istnieje (zosta\u0142a zdefiniowana). .EXITM [.EXIT] Zako\u0144czenie dzia\u0142ania makra. Powoduje bezwzgl\u0119dne zako\u0144czenie dzia\u0142ania makra. .ENDM [.MEND] Przy pomocy dyrektywy .ENDM lub .MEND ko\u0144czymy deklaracj\u0119 aktualnego makra. Nie ma mo\u017cliwo\u015bci u\u017cycia dyrektywy .END jak ma to miejsce dla innych obszar\u00f3w deklarowanych przez dyrektywy .LOCAL , .PROC , .ARRAY , .STRUCT , .REPT :[%%]parameter Parametr jest liczb\u0105 decymaln\u0105 dodatni\u0105 ( >=0 ), poprzedzon\u0105 znakiem dwukropka : lub dwoma znakami procentu %% . Je\u015bli w makrze chcemy aby znak : okre\u015bla\u0142 liczb\u0119 powt\u00f3rze\u0144 a nie numer parametru wystarczy \u017ce nast\u0119pny znak po dwukropku nie b\u0119dzie z przedzia\u0142u '0'..'9' , tylko np: :$2 nop :+2 nop :%10 nop Parametr :0 ( %%0 ) ma specjalne znaczenie, zawiera liczb\u0119 przekazanych parametr\u00f3w. Z jego pomoc\u0105 mo\u017cemy sprawdzi\u0107 czy wymagana liczba parametr\u00f3w zosta\u0142a przekazana do makra, np.: .IF :0<2 || :0>5 .ERROR \"Wrong number of arguments\" .ENDIF IFT %%0<2 .or :0>5 ERT \"Wrong number of arguments\" EIF Przyk\u0142ad makra: .macro load_word lda <:1 sta :2 lda >:1 sta :2+1 .endm test ne test eq .macro test b%%1 skip .endm Wywo\u0142anie makra Makro wywo\u0142ujemy poprzez jego nazw\u0119, po niej mog\u0105 wyst\u0105pi\u0107 parametry makra, rozdzielone separatorem kt\u00f3rym jest domy\u015blnie znak przecinka , lub spacji ' ' . Liczba parametr\u00f3w uzale\u017cniona jest od wolnej pami\u0119ci komputera PC . Je\u015bli przekazana liczba parametr\u00f3w jest mniejsza od liczby parametr\u00f3w u\u017cywanych w danym makrze, w\u00f3wczas pod brakuj\u0105ce parametry zostanie podstawiona warto\u015b\u0107 -1 ( $FFFFFFFF ). T\u0105 w\u0142a\u015bciwo\u015b\u0107 mo\u017cna wykorzysta\u0107 do sprawdzenia czy zosta\u0142 przekazany parametr czy te\u017c nie, \u0142atwiej jednak tego dokona\u0107 za pomoc\u0105 parametru zerowego %%0 . macro_name [Par1, Par2, Par3, 'Par4', \"string1\", \"string2\" ...] Parametrem mo\u017ce by\u0107 warto\u015b\u0107, wyra\u017cenie lub ci\u0105g znak\u00f3w ograniczony apostrofem pojedy\u0144czym ' ' lub podw\u00f3jnym \" \" . apostrofy pojedy\u0144cze ' ' zostan\u0105 przekazane do makra razem ze znakami znajduj\u0105cymi si\u0119 pomi\u0119dzy nimi apostrofy podw\u00f3jne \" \" oznaczaj\u0105 ci\u0105g znak\u00f3w i tylko ci\u0105g znak\u00f3w znajduj\u0105cy si\u0119 pomi\u0119dzy apostrofami zostanie przekazany do makra Wszelkie definicje etykiet w obr\u0119bie makra maj\u0105 zasi\u0119g lokalny. Je\u015bli poszukiwana przez assembler etykieta nie wyst\u0105pi\u0142a w obszarze makra, w\u00f3wczas nast\u0105pi jej szukanie w obszarze lokalnym (je\u015bli wyst\u0105pi\u0142a dyrektywa .LOCAL ), nast\u0119pnie w procedurze (je\u015bli procedura jest aktualnie przetwarzana), na ko\u0144cu w g\u0142\u00f3wnym programie. Przyk\u0142ad wywo\u0142ania makra: macro_name 'a',a,>$a000,cmp ; dla domy\u015blnego separatora ',' macro_name 'a'_a_>$a000_cmp ; dla zadeklarowanego separatora '_' macro_name 'a' a >$a000 cmp ; dla domy\u015blnego separatora ' ' Mo\u017cliwe jest wywo\u0142ywanie makr z poziomu makra, oraz rekurencyjne wywo\u0142ywanie makr. W tym ostatnim przypadku nale\u017cy by\u0107 ostro\u017cnym bo mo\u017ce doj\u015b\u0107 do przepe\u0142nienia stosu MADS -a. MADS zabezpiecza si\u0119 przez rekurencj\u0105 makr bez ko\u0144ca i zatrzymuje asemblacje gdy liczba wywo\u0142a\u0144 makra przekroczy 4095 (b\u0142\u0105d Infinite recursion ). Przyk\u0142ad makra, kt\u00f3re spowoduje przepe\u0142nienie stosu MADS -a: jump .macro jump .endm Przyk\u0142ad programu, kt\u00f3ry przekazuje parametry do pseudo procedur ..\\EXAMPLES\\MACRO.ASM: org $2000 proc PutChar,'a'-64 ; wywo\u0142anie makra PROC, jako parametr proc PutChar,'a'-64 ; nazwa procedury kt\u00f3ra b\u0119dzie wywo\u0142ana przez JSR proc PutChar,'r'-64 ; oraz jeden argument (kod znaku INTERNAL) proc PutChar,'e'-64 proc PutChar,'a'-64 proc Kolor,$23 ; wywo\u0142anie innej procedurki zmieniaj\u0105cej kolor t\u0142a ;--- loop jmp loop ; p\u0119tla bez ko\u0144ca, aby zobaczy\u0107 efekt dzia\u0142ania ;--- proc .macro ; deklaracja makra PROC push =:1,:2,:3,:4 ; wywo\u0142anie makra PUSH odk\u0142adaj\u0105cego na stos argumenty ; =:1 wylicza bank pamieci jsr :1 ; skok do procedury (nazwa procedury w pierwszym parametrze) lmb #0 ; Load Memory Bank, ustawia bank na wartosc 0 .endm ; koniec makra PROC ;--- push .macro ; deklaracja makra PUSH lmb #:1 ; ustawia wirtualny bank pami\u0119ci .if :2<=$FFFF ; je\u015bli przekazany argument jest mniejszy r\u00f3wny $FFFF to lda <:2 ; od\u0142\u00f3\u017c go na stosie sta stack lda >:2 sta stack+1 .endif .if :3<=$FFFF lda <:3 sta stack+2 lda >:3 sta stack+3 .endif .if :4<=$FFFF lda <:4 sta stack+4 lda >:4 sta stack+5 .endif .endm * ------------ * ; procedura KOLOR * PROC Kolor * * ------------ * lmb #1 ; ustawienie numeru wirtualnego banku na 1 ; wszystkie definicje etykiet b\u0119d\u0105 teraz nale\u017ce\u0107 do tego banku stack org *+256 ; stos dla procedury KOLOR color equ stack Kolor ; kod procedury KOLOR lda color sta 712 rts * -------------- * ; procedura PUTCHAR * PROC PutChar * * -------------- * lmb #2 ; ustawienie numeru wirtualnego banku na 2 ; wszystkie definicje etykiet b\u0119d\u0105 teraz nale\u017ce\u0107 do tego banku stack org *+256 ; stos dla procedury PUTCHAR char equ stack PutChar ; kod procedury PUTCHAR lda char sta $bc40 scr equ *-2 inc scr rts Oczywi\u015bcie stos w tym przyk\u0142adowym programie jest programowy. W przypadku 65816 mo\u017cna by\u0142oby u\u017cy\u0107 stosu sprz\u0119towego. Dzi\u0119ki temu, \u017ce zdefiniowane zmienne przypisywane s\u0105 do konkretnego numeru banku, mo\u017cna stworzy\u0107 struktur\u0119 wywo\u0142ania procedury czy funkcji podobn\u0105 do tych z j\u0119zyk\u00f3w wy\u017cszego poziomu. Pro\u015bciej i efektywniej jednak skorzysta\u0107 z deklaracji procedury .PROC jak\u0105 umo\u017cliwia MADS . Wi\u0119cej o deklaracji procedury i operacjach jej dotycz\u0105cych w rozdziale [Procedury].","title":"Makra"},{"location":"makra/#makra","text":"Makra u\u0142atwiaj\u0105 nam wykonywanie powtarzaj\u0105cych si\u0119 czynno\u015bci, automatyzuj\u0105 je. Istniej\u0105 tylko w pami\u0119ci assemblera, dopiero w momencie wywo\u0142ania s\u0105 asemblowane. Przy ich pomocy MADS mo\u017ce odk\u0142ada\u0107 i zdejmowa\u0107 z programowego stosu parametry dla procedur zadeklarowanych dyrektyw\u0105 .PROC oraz prze\u0142\u0105cza\u0107 banki rozszerzonej pami\u0119ci w trybie BANK SENSITIVE ( OPT B+ ). Makra czytane s\u0105 tylko w pierwszym przebiegu assemblacji, dla n/w przyk\u0142adu makra znajduj\u0105ce si\u0119 w pliku do\u0142\u0105czanym przez ICL nie zostan\u0105 rozpoznane : .macro test icl 'dodatkowe_makra.mac' .endm","title":"Makra"},{"location":"makra/#deklaracja-makra","text":"Makr dotycz\u0105 n/w pseudo rozkazy i dyrektywy: name .MACRO [arg1, arg2 ...] ['separator'] [\"separator\"] .MACRO name [(arg1, arg2 ...)] ['separator'] [\"separator\"] .EXITM [.EXIT] .ENDM [.MEND] :[%%]parameter :[%%]label","title":"Deklaracja makra"},{"location":"makra/#name-macro-arg1-arg2-separator-separator","text":"Deklaracja makra o nazwie name za pomoc\u0105 dyrektywy .MACRO . Nazwa makra jest wymagana i konieczna, jej brak wygeneruje b\u0142\u0105d. Do nazw makr nie mo\u017cna u\u017cywa\u0107 nazw mnemonik\u00f3w i pseudo rozkaz\u00f3w (b\u0142\u0105d Reserved word ). Dopuszczalna jest lista z etykietami nazw argument\u00f3w jakie b\u0119d\u0105 przekazywane do makra, taka lista mo\u017ce by\u0107 ograniczona dodatkowo nawiasem okr\u0105g\u0142ym ( ) . Przedstawianie argument\u00f3w w postaci nazw etykiet ma na celu poprawienie przejrzysto\u015bci kodu makra. W samym ciele makra mo\u017cna u\u017cywa\u0107 zamiennie nazw etykiet argument\u00f3w lub ich numerycznych odpowiednik\u00f3w. .macro SetColor val,reg lda :val sta :reg .endm Na ko\u0144cu deklaracji makra mo\u017ce wyst\u0105pi\u0107 deklaracja separatora i zarazem trybu przekazywania parametr\u00f3w do makra (pojedy\u0144czy apostrof bez zmian, podw\u00f3jny apostrof z rozbijaniem parametr\u00f3w na tryb adresacji i argument). Domy\u015blnym separatorem, rozdzielaj\u0105cym parametry przekazywane do makra jest znak przecinka , oraz spacji ' ' . name .MACRO 'separator' Pomi\u0119dzy pojedy\u0144czymi apostrofami ' ' mo\u017cemy umie\u015bci\u0107 znak separatora, kt\u00f3ry b\u0119dzie u\u017cywany do oddzielenia parametr\u00f3w przy wywo\u0142aniu makra (tylko do tego mog\u0105 s\u0142u\u017cy\u0107 pojedy\u0144cze apostrofy). name .MACRO \"separator\" Pomi\u0119dzy podw\u00f3jnymi apostrofami \" \" mo\u017cemy tak\u017ce umie\u015bci\u0107 znak separatora, kt\u00f3ry b\u0119dzie u\u017cywany do oddzielenia parametr\u00f3w przy wywo\u0142aniu makra. Dodatkowo u\u017cycie podw\u00f3jnego apostrofu sygnalizuje MADS -owi aby rozk\u0142ada\u0142 przekazywane parametry na dwa elementy: tryb adresacji i argument, np.: test #12 200 <30 test .macro \" \" .endm Makro TEST ma zadeklarowany separator-spacj\u0119 przy u\u017cyciu apostrofu \" , czyli po wywo\u0142aniu makra parametry zostan\u0105 roz\u0142o\u017cone na dwa elementy: tryb adresacji i argument. #12 -> tryb adresacji '#' argument 12 200 -> tryb adresacji ' ' argument 200 <30 -> tryb adresacji '#' argument 0 (obliczona warto\u015b\u0107 wyra\u017cenia \"<30\") test '#' 12 ' ' 200 '#' 0 UAWAGA #1: Parametry ze znakiem operatora < , > zostaj\u0105 obliczone i dopiero ich wynik jest przekazywany do makra (podstawiany pod parametr). UAWAGA #2: Je\u015bli parametrem makra jest licznik p\u0119tli # , .R (!!! pojedy\u0144czy znak # lub dyrektywa .R a nie wyra\u017cenie z udzia\u0142em tego znaku, tej dyrektywy !!!) w\u00f3wczas do makra przekazywana jest warto\u015b\u0107 licznika p\u0119tli (podstawiana pod parametr). T\u0105 w\u0142a\u015bciwo\u015b\u0107 mo\u017cemy wykorzysta\u0107 do stworzenia \"samopisz\u0105cego\" si\u0119 kodu, kiedy potrzebujemy tworzy\u0107 nowe etykiety typu \"label0\", \"label1\", \"label2\", \"label3\" ... itd. , np.: :32 find # find .macro ift .def label:1 dta a(label:1) eif .endm W/w przyk\u0142ad zapisuje adres etykiety pod warunkiem \u017ce taka etykiety istnieje (zosta\u0142a zdefiniowana).","title":"name .MACRO [(arg1, arg2 ...)] ['separator'] [\"separator\"]"},{"location":"makra/#exitm-exit","text":"Zako\u0144czenie dzia\u0142ania makra. Powoduje bezwzgl\u0119dne zako\u0144czenie dzia\u0142ania makra.","title":".EXITM [.EXIT]"},{"location":"makra/#endm-mend","text":"Przy pomocy dyrektywy .ENDM lub .MEND ko\u0144czymy deklaracj\u0119 aktualnego makra. Nie ma mo\u017cliwo\u015bci u\u017cycia dyrektywy .END jak ma to miejsce dla innych obszar\u00f3w deklarowanych przez dyrektywy .LOCAL , .PROC , .ARRAY , .STRUCT , .REPT","title":".ENDM [.MEND]"},{"location":"makra/#parameter","text":"Parametr jest liczb\u0105 decymaln\u0105 dodatni\u0105 ( >=0 ), poprzedzon\u0105 znakiem dwukropka : lub dwoma znakami procentu %% . Je\u015bli w makrze chcemy aby znak : okre\u015bla\u0142 liczb\u0119 powt\u00f3rze\u0144 a nie numer parametru wystarczy \u017ce nast\u0119pny znak po dwukropku nie b\u0119dzie z przedzia\u0142u '0'..'9' , tylko np: :$2 nop :+2 nop :%10 nop Parametr :0 ( %%0 ) ma specjalne znaczenie, zawiera liczb\u0119 przekazanych parametr\u00f3w. Z jego pomoc\u0105 mo\u017cemy sprawdzi\u0107 czy wymagana liczba parametr\u00f3w zosta\u0142a przekazana do makra, np.: .IF :0<2 || :0>5 .ERROR \"Wrong number of arguments\" .ENDIF IFT %%0<2 .or :0>5 ERT \"Wrong number of arguments\" EIF Przyk\u0142ad makra: .macro load_word lda <:1 sta :2 lda >:1 sta :2+1 .endm test ne test eq .macro test b%%1 skip .endm","title":":[%%]parameter"},{"location":"makra/#wywoanie-makra","text":"Makro wywo\u0142ujemy poprzez jego nazw\u0119, po niej mog\u0105 wyst\u0105pi\u0107 parametry makra, rozdzielone separatorem kt\u00f3rym jest domy\u015blnie znak przecinka , lub spacji ' ' . Liczba parametr\u00f3w uzale\u017cniona jest od wolnej pami\u0119ci komputera PC . Je\u015bli przekazana liczba parametr\u00f3w jest mniejsza od liczby parametr\u00f3w u\u017cywanych w danym makrze, w\u00f3wczas pod brakuj\u0105ce parametry zostanie podstawiona warto\u015b\u0107 -1 ( $FFFFFFFF ). T\u0105 w\u0142a\u015bciwo\u015b\u0107 mo\u017cna wykorzysta\u0107 do sprawdzenia czy zosta\u0142 przekazany parametr czy te\u017c nie, \u0142atwiej jednak tego dokona\u0107 za pomoc\u0105 parametru zerowego %%0 . macro_name [Par1, Par2, Par3, 'Par4', \"string1\", \"string2\" ...] Parametrem mo\u017ce by\u0107 warto\u015b\u0107, wyra\u017cenie lub ci\u0105g znak\u00f3w ograniczony apostrofem pojedy\u0144czym ' ' lub podw\u00f3jnym \" \" . apostrofy pojedy\u0144cze ' ' zostan\u0105 przekazane do makra razem ze znakami znajduj\u0105cymi si\u0119 pomi\u0119dzy nimi apostrofy podw\u00f3jne \" \" oznaczaj\u0105 ci\u0105g znak\u00f3w i tylko ci\u0105g znak\u00f3w znajduj\u0105cy si\u0119 pomi\u0119dzy apostrofami zostanie przekazany do makra Wszelkie definicje etykiet w obr\u0119bie makra maj\u0105 zasi\u0119g lokalny. Je\u015bli poszukiwana przez assembler etykieta nie wyst\u0105pi\u0142a w obszarze makra, w\u00f3wczas nast\u0105pi jej szukanie w obszarze lokalnym (je\u015bli wyst\u0105pi\u0142a dyrektywa .LOCAL ), nast\u0119pnie w procedurze (je\u015bli procedura jest aktualnie przetwarzana), na ko\u0144cu w g\u0142\u00f3wnym programie. Przyk\u0142ad wywo\u0142ania makra: macro_name 'a',a,>$a000,cmp ; dla domy\u015blnego separatora ',' macro_name 'a'_a_>$a000_cmp ; dla zadeklarowanego separatora '_' macro_name 'a' a >$a000 cmp ; dla domy\u015blnego separatora ' ' Mo\u017cliwe jest wywo\u0142ywanie makr z poziomu makra, oraz rekurencyjne wywo\u0142ywanie makr. W tym ostatnim przypadku nale\u017cy by\u0107 ostro\u017cnym bo mo\u017ce doj\u015b\u0107 do przepe\u0142nienia stosu MADS -a. MADS zabezpiecza si\u0119 przez rekurencj\u0105 makr bez ko\u0144ca i zatrzymuje asemblacje gdy liczba wywo\u0142a\u0144 makra przekroczy 4095 (b\u0142\u0105d Infinite recursion ). Przyk\u0142ad makra, kt\u00f3re spowoduje przepe\u0142nienie stosu MADS -a: jump .macro jump .endm Przyk\u0142ad programu, kt\u00f3ry przekazuje parametry do pseudo procedur ..\\EXAMPLES\\MACRO.ASM: org $2000 proc PutChar,'a'-64 ; wywo\u0142anie makra PROC, jako parametr proc PutChar,'a'-64 ; nazwa procedury kt\u00f3ra b\u0119dzie wywo\u0142ana przez JSR proc PutChar,'r'-64 ; oraz jeden argument (kod znaku INTERNAL) proc PutChar,'e'-64 proc PutChar,'a'-64 proc Kolor,$23 ; wywo\u0142anie innej procedurki zmieniaj\u0105cej kolor t\u0142a ;--- loop jmp loop ; p\u0119tla bez ko\u0144ca, aby zobaczy\u0107 efekt dzia\u0142ania ;--- proc .macro ; deklaracja makra PROC push =:1,:2,:3,:4 ; wywo\u0142anie makra PUSH odk\u0142adaj\u0105cego na stos argumenty ; =:1 wylicza bank pamieci jsr :1 ; skok do procedury (nazwa procedury w pierwszym parametrze) lmb #0 ; Load Memory Bank, ustawia bank na wartosc 0 .endm ; koniec makra PROC ;--- push .macro ; deklaracja makra PUSH lmb #:1 ; ustawia wirtualny bank pami\u0119ci .if :2<=$FFFF ; je\u015bli przekazany argument jest mniejszy r\u00f3wny $FFFF to lda <:2 ; od\u0142\u00f3\u017c go na stosie sta stack lda >:2 sta stack+1 .endif .if :3<=$FFFF lda <:3 sta stack+2 lda >:3 sta stack+3 .endif .if :4<=$FFFF lda <:4 sta stack+4 lda >:4 sta stack+5 .endif .endm * ------------ * ; procedura KOLOR * PROC Kolor * * ------------ * lmb #1 ; ustawienie numeru wirtualnego banku na 1 ; wszystkie definicje etykiet b\u0119d\u0105 teraz nale\u017ce\u0107 do tego banku stack org *+256 ; stos dla procedury KOLOR color equ stack Kolor ; kod procedury KOLOR lda color sta 712 rts * -------------- * ; procedura PUTCHAR * PROC PutChar * * -------------- * lmb #2 ; ustawienie numeru wirtualnego banku na 2 ; wszystkie definicje etykiet b\u0119d\u0105 teraz nale\u017ce\u0107 do tego banku stack org *+256 ; stos dla procedury PUTCHAR char equ stack PutChar ; kod procedury PUTCHAR lda char sta $bc40 scr equ *-2 inc scr rts Oczywi\u015bcie stos w tym przyk\u0142adowym programie jest programowy. W przypadku 65816 mo\u017cna by\u0142oby u\u017cy\u0107 stosu sprz\u0119towego. Dzi\u0119ki temu, \u017ce zdefiniowane zmienne przypisywane s\u0105 do konkretnego numeru banku, mo\u017cna stworzy\u0107 struktur\u0119 wywo\u0142ania procedury czy funkcji podobn\u0105 do tych z j\u0119zyk\u00f3w wy\u017cszego poziomu. Pro\u015bciej i efektywniej jednak skorzysta\u0107 z deklaracji procedury .PROC jak\u0105 umo\u017cliwia MADS . Wi\u0119cej o deklaracji procedury i operacjach jej dotycz\u0105cych w rozdziale [Procedury].","title":"Wywo\u0142anie makra"},{"location":"makro-rozkazy/","text":"Makro rozkazy REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS JEQ, JNE, JPL, JMI, JCC, JCS, JVC, JVS ADD, SUB ADB, SBB ADW, SBW PHR, PLR INW, INL, IND, DEW, DEL, DED MVA, MVX, MVY MWA, MWX, MWY CPB, CPW, CPL, CPD Zadaniem makro rozkaz\u00f3w jest skr\u00f3cenie czasu pisania programu i samego listingu. Makro rozkazy zast\u0119puj\u0105 grupy cz\u0119sto powtarzaj\u0105cych si\u0119 mnemonik\u00f3w. REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS W/w makro rozkazy swoimi nazwami nawi\u0105zuj\u0105 do odpowiednich mnemonik\u00f3w 6502 , odpowiednio BEQ , BNE , BPL , BMI , BCC , BCS , BVC , BVS . Posiadaj\u0105 dodatkow\u0105 w\u0142a\u015bciwo\u015b\u0107 jak\u0105 jest skok do poprzednio asemblowanej instrukcji, np.: lda:cmp:req 20 -> lda 20 -> wait cmp 20 -> beq wait ldx #0 -> ldx #0 mva:rne $500,x $600,x+ -> loop lda $500,x -> sta $600,x -> inx -> bne loop SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS W/w makro rozkazy swoimi nazwami nawi\u0105zuj\u0105 do odpowiednich mnemonik\u00f3w 6502 , odpowiednio BEQ , BNE , BPL , BMI , BCC , BCS , BVC , BVS . Posiadaj\u0105 dodatkow\u0105 w\u0142a\u015bciwo\u015b\u0107 jak\u0105 jest skok do nast\u0119pnej asemblowanej instrukcji, np.: lda #40 -> lda #40 add:sta $80 -> clc scc:inc $81 -> adc $80 -> sta $80 -> bcc skip -> inc $81 -> skip JEQ, JNE, JPL, JMI, JCC, JCS, JVC, JVS W/w makro rozkazy swoimi nazwami nawi\u0105zuj\u0105 do odpowiednich mnemonik\u00f3w 6502 , odpowiednio BEQ , BNE , BPL , BMI , BCC , BCS , BVC , BVS . Posiadaj\u0105 dodatkow\u0105 w\u0142a\u015bciwo\u015b\u0107 jak\u0105 jest skok warunkowy pod wskazany adres, z ich pomoc\u0105 mo\u017cemy skaka\u0107 nie tylko w zakresie -128..+127 bajt\u00f3w ale w ca\u0142ym zakresie 64kB np.: jne dest -> beq *+4 -> jmp dest Je\u015bli skok jest kr\u00f3tki (zakres -128..+127) w\u00f3wczas MADS u\u017cyje kr\u00f3tkiego skoku, odpowiednio BEQ , BNE , BPL , BMI , BCC , BCS , BVC , BVS . ADD, SUB W/w makro rozkazy realizuj\u0105 odpowiednio zwi\u0119kszenie/zmniejszenie bajtu pami\u0119ci bez zapisywania wyniku (wynik w akumulatorze CPU ). ADD -> CLC SUB -> SEC -> ADC ... -> SBC ... ADB, SBB W/w makro rozkazy realizuj\u0105 odpowiednio zwi\u0119kszenie/zmniejszenie bajtu pami\u0119ci z zapisaniem wyniku. ADB SRC #$40 -> LDA SRC ADB A B C -> LDA A -> CLC -> CLC -> ADC #$40 -> ADC B -> STA SRC -> STA C SBB SRC #$80 -> LDA SRC SBB A B C -> LDA A -> SEC -> SEC -> SBC #$80 -> SBC B -> STA SRC -> STA C ADW, SBW W/w makro rozkazy realizuj\u0105 odpowiednio zwi\u0119kszenie/zmniejszenie s\u0142owa pami\u0119ci z zapisaniem wyniku. ADW SRC #$40 -> CLC ADW A B C -> CLC -> LDA SRC -> LDA A -> ADC #$40 -> ADC B -> STA SRC -> STA C -> SCC -> LDA A+1 -> INC SRC+1 -> ADC B+1 -> STA C+1 ADW SRC #$40 SRC -> CLC -> LDA SRC -> ADC #$40 -> STA SRC -> LDA SRC+1 -> ADC #$00 -> STA SRC+1 SBW SRC #$4080 -> SEC SBW A B C -> SEC -> LDA SRC -> LDA A -> SBC <$4080 -> SBC B -> STA SRC -> STA C -> LDA SRC+1 -> LDA A+1 -> SBC >$4080 -> SBC B+1 -> STA SRC+1 -> STA C+1 PHR, PLR W/w makro rozkazy swoimi nazwami nawi\u0105zuj\u0105 do odpowiednich mnemonik\u00f3w 6502 , odpowiednio PHA , PLA , realizuj\u0105 odk\u0142adanie na stosie i zdejmowanie ze stosu rejestr\u00f3w A , X , Y . PHR -> PHA PLR -> PLA -> TXA -> TAY -> PHA -> PLA -> TYA -> TAX -> PHA -> PLA INW, INL, IND, DEW, DEL, DED Makro rozkazy INW , INL , IND realizuj\u0105 zwi\u0119kszenie odpowiednio s\u0142owa pami\u0119ci ( .WORD ), d\u0142ugiego s\u0142owa pami\u0119ci ( .LONG ), podw\u00f3jnego s\u0142owa pami\u0119ci ( .DWORD ). Makro rozkazy DEW , DEL , DED realizuj\u0105 zmniejszenie odpowiednio s\u0142owa pami\u0119ci ( .WORD ), d\u0142ugiego s\u0142owa pami\u0119ci ( .LONG ), podw\u00f3jnego s\u0142owa pami\u0119ci ( .DWORD ) i wykorzystuj\u0105 w tym celu akumulator CPU (zawarto\u015b\u0107 akumulatora ulega zmianie po wykonaniu makro rozkaz\u00f3w DEW , DEL , DED ). inw dest -> inc dest -> inc dest -> bne skip -> sne -> inc dest+1 -> inc dest+1 -> skip -> dew dest -> lda dest -> lda dest -> bne skip -> sne -> dec dest+1 -> dec dest+1 -> skip dec dest -> dec dest MVA, MVX, MVY Makro rozkazy MVA , MVX , MVY s\u0142u\u017c\u0105 do przenoszenia bajt\u00f3w ( .BYTE ) pami\u0119ci przy pomocy rejestr\u00f3w CPU odpowiednio A , X , Y . U\u017cycie opcji OPT R+ pozwala na potencjalne skr\u00f3cenie kodu wynikowego dla nast\u0119puj\u0105cych po sobie makro rozkaz\u00f3w MVA , MVX , MVY . lda src -> mva src dst sta dst -> ldy $10,x -> mvy $10,x $a0,x sty $a0,x -> ldx #$10 -> mvx #$10 dst stx dst -> MWA, MWX, MWY Makro rozkazy MWA , MWX , MWY s\u0142u\u017c\u0105 do przenoszenia s\u0142\u00f3w ( .WORD ) pami\u0119ci przy pomocy rejestr\u00f3w CPU odpowiednio A , X , Y . U\u017cycie opcji OPT R+ pozwala na potencjalne skr\u00f3cenie kodu wynikowego dla nast\u0119puj\u0105cych po sobie makro rozkaz\u00f3w MWA , MWX , MWY . ldx <adr -> mwx #adr dst stx dst -> ldx >adr -> stx dst+1 -> mwa #0 $80 -> lda #0 mwy #$3040 $80 -> ldy <$3040 -> sta $80 -> sty $80 -> sta $81 -> ldy >$3040 -> sty $81 mwa ($80),y $a000,x -> lda ($80),y -> sta $a000,x -> iny -> lda ($80),y -> sta $a001,x CPB, CPW, CPL, CPD Makro rozkazy CPB , CPW , CPL , CPD realizuj\u0105 por\u00f3wnanie warto\u015bci odpowiednich typ\u00f3w, odpowiednio .BYTE , .WORD , .LONG , .DWORD . cpw temp #$4080 bcc skip cpd v0 v1 beq skip","title":"Makro rozkazy"},{"location":"makro-rozkazy/#makro-rozkazy","text":"REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS JEQ, JNE, JPL, JMI, JCC, JCS, JVC, JVS ADD, SUB ADB, SBB ADW, SBW PHR, PLR INW, INL, IND, DEW, DEL, DED MVA, MVX, MVY MWA, MWX, MWY CPB, CPW, CPL, CPD Zadaniem makro rozkaz\u00f3w jest skr\u00f3cenie czasu pisania programu i samego listingu. Makro rozkazy zast\u0119puj\u0105 grupy cz\u0119sto powtarzaj\u0105cych si\u0119 mnemonik\u00f3w.","title":"Makro rozkazy"},{"location":"makro-rozkazy/#req-rne-rpl-rmi-rcc-rcs-rvc-rvs","text":"W/w makro rozkazy swoimi nazwami nawi\u0105zuj\u0105 do odpowiednich mnemonik\u00f3w 6502 , odpowiednio BEQ , BNE , BPL , BMI , BCC , BCS , BVC , BVS . Posiadaj\u0105 dodatkow\u0105 w\u0142a\u015bciwo\u015b\u0107 jak\u0105 jest skok do poprzednio asemblowanej instrukcji, np.: lda:cmp:req 20 -> lda 20 -> wait cmp 20 -> beq wait ldx #0 -> ldx #0 mva:rne $500,x $600,x+ -> loop lda $500,x -> sta $600,x -> inx -> bne loop","title":"REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS"},{"location":"makro-rozkazy/#seq-sne-spl-smi-scc-scs-svc-svs","text":"W/w makro rozkazy swoimi nazwami nawi\u0105zuj\u0105 do odpowiednich mnemonik\u00f3w 6502 , odpowiednio BEQ , BNE , BPL , BMI , BCC , BCS , BVC , BVS . Posiadaj\u0105 dodatkow\u0105 w\u0142a\u015bciwo\u015b\u0107 jak\u0105 jest skok do nast\u0119pnej asemblowanej instrukcji, np.: lda #40 -> lda #40 add:sta $80 -> clc scc:inc $81 -> adc $80 -> sta $80 -> bcc skip -> inc $81 -> skip","title":"SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS"},{"location":"makro-rozkazy/#jeq-jne-jpl-jmi-jcc-jcs-jvc-jvs","text":"W/w makro rozkazy swoimi nazwami nawi\u0105zuj\u0105 do odpowiednich mnemonik\u00f3w 6502 , odpowiednio BEQ , BNE , BPL , BMI , BCC , BCS , BVC , BVS . Posiadaj\u0105 dodatkow\u0105 w\u0142a\u015bciwo\u015b\u0107 jak\u0105 jest skok warunkowy pod wskazany adres, z ich pomoc\u0105 mo\u017cemy skaka\u0107 nie tylko w zakresie -128..+127 bajt\u00f3w ale w ca\u0142ym zakresie 64kB np.: jne dest -> beq *+4 -> jmp dest Je\u015bli skok jest kr\u00f3tki (zakres -128..+127) w\u00f3wczas MADS u\u017cyje kr\u00f3tkiego skoku, odpowiednio BEQ , BNE , BPL , BMI , BCC , BCS , BVC , BVS .","title":"JEQ, JNE, JPL, JMI, JCC, JCS, JVC, JVS"},{"location":"makro-rozkazy/#add-sub","text":"W/w makro rozkazy realizuj\u0105 odpowiednio zwi\u0119kszenie/zmniejszenie bajtu pami\u0119ci bez zapisywania wyniku (wynik w akumulatorze CPU ). ADD -> CLC SUB -> SEC -> ADC ... -> SBC ...","title":"ADD, SUB"},{"location":"makro-rozkazy/#adb-sbb","text":"W/w makro rozkazy realizuj\u0105 odpowiednio zwi\u0119kszenie/zmniejszenie bajtu pami\u0119ci z zapisaniem wyniku. ADB SRC #$40 -> LDA SRC ADB A B C -> LDA A -> CLC -> CLC -> ADC #$40 -> ADC B -> STA SRC -> STA C SBB SRC #$80 -> LDA SRC SBB A B C -> LDA A -> SEC -> SEC -> SBC #$80 -> SBC B -> STA SRC -> STA C","title":"ADB, SBB"},{"location":"makro-rozkazy/#adw-sbw","text":"W/w makro rozkazy realizuj\u0105 odpowiednio zwi\u0119kszenie/zmniejszenie s\u0142owa pami\u0119ci z zapisaniem wyniku. ADW SRC #$40 -> CLC ADW A B C -> CLC -> LDA SRC -> LDA A -> ADC #$40 -> ADC B -> STA SRC -> STA C -> SCC -> LDA A+1 -> INC SRC+1 -> ADC B+1 -> STA C+1 ADW SRC #$40 SRC -> CLC -> LDA SRC -> ADC #$40 -> STA SRC -> LDA SRC+1 -> ADC #$00 -> STA SRC+1 SBW SRC #$4080 -> SEC SBW A B C -> SEC -> LDA SRC -> LDA A -> SBC <$4080 -> SBC B -> STA SRC -> STA C -> LDA SRC+1 -> LDA A+1 -> SBC >$4080 -> SBC B+1 -> STA SRC+1 -> STA C+1","title":"ADW, SBW"},{"location":"makro-rozkazy/#phr-plr","text":"W/w makro rozkazy swoimi nazwami nawi\u0105zuj\u0105 do odpowiednich mnemonik\u00f3w 6502 , odpowiednio PHA , PLA , realizuj\u0105 odk\u0142adanie na stosie i zdejmowanie ze stosu rejestr\u00f3w A , X , Y . PHR -> PHA PLR -> PLA -> TXA -> TAY -> PHA -> PLA -> TYA -> TAX -> PHA -> PLA","title":"PHR, PLR"},{"location":"makro-rozkazy/#inw-inl-ind-dew-del-ded","text":"Makro rozkazy INW , INL , IND realizuj\u0105 zwi\u0119kszenie odpowiednio s\u0142owa pami\u0119ci ( .WORD ), d\u0142ugiego s\u0142owa pami\u0119ci ( .LONG ), podw\u00f3jnego s\u0142owa pami\u0119ci ( .DWORD ). Makro rozkazy DEW , DEL , DED realizuj\u0105 zmniejszenie odpowiednio s\u0142owa pami\u0119ci ( .WORD ), d\u0142ugiego s\u0142owa pami\u0119ci ( .LONG ), podw\u00f3jnego s\u0142owa pami\u0119ci ( .DWORD ) i wykorzystuj\u0105 w tym celu akumulator CPU (zawarto\u015b\u0107 akumulatora ulega zmianie po wykonaniu makro rozkaz\u00f3w DEW , DEL , DED ). inw dest -> inc dest -> inc dest -> bne skip -> sne -> inc dest+1 -> inc dest+1 -> skip -> dew dest -> lda dest -> lda dest -> bne skip -> sne -> dec dest+1 -> dec dest+1 -> skip dec dest -> dec dest","title":"INW, INL, IND, DEW, DEL, DED"},{"location":"makro-rozkazy/#mva-mvx-mvy","text":"Makro rozkazy MVA , MVX , MVY s\u0142u\u017c\u0105 do przenoszenia bajt\u00f3w ( .BYTE ) pami\u0119ci przy pomocy rejestr\u00f3w CPU odpowiednio A , X , Y . U\u017cycie opcji OPT R+ pozwala na potencjalne skr\u00f3cenie kodu wynikowego dla nast\u0119puj\u0105cych po sobie makro rozkaz\u00f3w MVA , MVX , MVY . lda src -> mva src dst sta dst -> ldy $10,x -> mvy $10,x $a0,x sty $a0,x -> ldx #$10 -> mvx #$10 dst stx dst ->","title":"MVA, MVX, MVY"},{"location":"makro-rozkazy/#mwa-mwx-mwy","text":"Makro rozkazy MWA , MWX , MWY s\u0142u\u017c\u0105 do przenoszenia s\u0142\u00f3w ( .WORD ) pami\u0119ci przy pomocy rejestr\u00f3w CPU odpowiednio A , X , Y . U\u017cycie opcji OPT R+ pozwala na potencjalne skr\u00f3cenie kodu wynikowego dla nast\u0119puj\u0105cych po sobie makro rozkaz\u00f3w MWA , MWX , MWY . ldx <adr -> mwx #adr dst stx dst -> ldx >adr -> stx dst+1 -> mwa #0 $80 -> lda #0 mwy #$3040 $80 -> ldy <$3040 -> sta $80 -> sty $80 -> sta $81 -> ldy >$3040 -> sty $81 mwa ($80),y $a000,x -> lda ($80),y -> sta $a000,x -> iny -> lda ($80),y -> sta $a001,x","title":"MWA, MWX, MWY"},{"location":"makro-rozkazy/#cpb-cpw-cpl-cpd","text":"Makro rozkazy CPB , CPW , CPL , CPD realizuj\u0105 por\u00f3wnanie warto\u015bci odpowiednich typ\u00f3w, odpowiednio .BYTE , .WORD , .LONG , .DWORD . cpw temp #$4080 bcc skip cpd v0 v1 beq skip","title":"CPB, CPW, CPL, CPD"},{"location":"mnemoniki/","text":"Dost\u0119pne rozkazy 6502 LDA LDX LDY STA STX STY ADC AND ASL SBC JSR JMP LSR ORA CMP CPY CPX DEC INC EOR ROL ROR BRK CLC CLI CLV CLD PHP PLP PHA PLA RTI RTS SEC SEI SED INY INX DEY DEX TXA TYA TXS TAY TAX TSX NOP BPL BMI BNE BCC BCS BEQ BVC BVS BIT Dost\u0119pne nielegalne rozkazy 6502 ASO RLN LSE RRD SAX LAX DCP ISB ANC ALR ARR ANE ANX SBX LAS SHA SHS SHX SHY NPO CIM Dost\u0119pne rozkazy 65816 Oczywi\u015bcie dost\u0119pne s\u0105 rozkazy 6502 , a opr\u00f3cz nich: STZ SEP REP TRB TSB BRA COP MVN MVP PEA PHB PHD PHK PHX PHY PLB PLD PLX PLY RTL STP TCD TCS TDC TSC TXY TYX WAI WDM XBA XCE INA DEA BRL JSL JML Rozszerzanie mnemonika Mo\u017cliwe jest u\u017cycie rozszerzenia mnemonika w stylu XASM a: z: r: np.: XASM MADS lda a:0 lda.a 0 ldx z:0 lda.z 0 org r:$40 org $40,* Mo\u017cliwe jest u\u017cycie rozszerzenia mnemonika po znaku kropki . dla rozkaz\u00f3w typu LDA LDX LDY STA STX STY : .b lub .z BYTE .a lub .w lub .q WORD .t lub .l TRIPLE, LONG (24bit) np. lda.w #$00 ; A9 00 00 lda #$80 ; A9 80 stx.w $f2 ; 8E F2 00 Wyj\u0105tki stanowi\u0105 rozkazy n/w, kt\u00f3rym nie mo\u017cna zmieni\u0107 rozmiaru rejestru w adresowaniu absolutnym (niekt\u00f3re assemblery nie wymagaj\u0105 dla tych rozkaz\u00f3w podania znaku # , jednak MADS wymaga tego): #$xx dla SEP REP COP #$xxxx dla PEA Innym wyj\u0105tkiem jest tryb adresowania po\u015bredni d\u0142ugi, kt\u00f3ry reprezentowany jest przez nawiasy kwadratowe [] . Jak wiemy tego typu nawiasy wykorzystywane s\u0105 te\u017c do obliczania wyra\u017ce\u0144, jednak je\u015bli asembler napotka pierwszy znak [ uzna to za tryb adresowania po\u015bredni d\u0142ugi i je\u015bli nie zasygnalizowali\u015bmy ch\u0119ci u\u017cywania 65816 wyst\u0105pi b\u0142\u0105d z komunikatem Illegal adressing mode . Aby oszuka\u0107 assembler wystarczy da\u0107 przed kwadratowym nawiasem otwieraj\u0105cym [ znak + . lda [2+4] ; lda [6] lda +[2+4] ; lda 6","title":"Mnemoniki"},{"location":"mnemoniki/#_1","text":"","title":""},{"location":"mnemoniki/#dostepne-rozkazy-6502","text":"LDA LDX LDY STA STX STY ADC AND ASL SBC JSR JMP LSR ORA CMP CPY CPX DEC INC EOR ROL ROR BRK CLC CLI CLV CLD PHP PLP PHA PLA RTI RTS SEC SEI SED INY INX DEY DEX TXA TYA TXS TAY TAX TSX NOP BPL BMI BNE BCC BCS BEQ BVC BVS BIT","title":"Dost\u0119pne rozkazy 6502"},{"location":"mnemoniki/#dostepne-nielegalne-rozkazy-6502","text":"ASO RLN LSE RRD SAX LAX DCP ISB ANC ALR ARR ANE ANX SBX LAS SHA SHS SHX SHY NPO CIM","title":"Dost\u0119pne nielegalne rozkazy 6502"},{"location":"mnemoniki/#dostepne-rozkazy-65816","text":"Oczywi\u015bcie dost\u0119pne s\u0105 rozkazy 6502 , a opr\u00f3cz nich: STZ SEP REP TRB TSB BRA COP MVN MVP PEA PHB PHD PHK PHX PHY PLB PLD PLX PLY RTL STP TCD TCS TDC TSC TXY TYX WAI WDM XBA XCE INA DEA BRL JSL JML","title":"Dost\u0119pne rozkazy 65816"},{"location":"mnemoniki/#rozszerzanie-mnemonika","text":"Mo\u017cliwe jest u\u017cycie rozszerzenia mnemonika w stylu XASM a: z: r: np.: XASM MADS lda a:0 lda.a 0 ldx z:0 lda.z 0 org r:$40 org $40,* Mo\u017cliwe jest u\u017cycie rozszerzenia mnemonika po znaku kropki . dla rozkaz\u00f3w typu LDA LDX LDY STA STX STY : .b lub .z BYTE .a lub .w lub .q WORD .t lub .l TRIPLE, LONG (24bit) np. lda.w #$00 ; A9 00 00 lda #$80 ; A9 80 stx.w $f2 ; 8E F2 00 Wyj\u0105tki stanowi\u0105 rozkazy n/w, kt\u00f3rym nie mo\u017cna zmieni\u0107 rozmiaru rejestru w adresowaniu absolutnym (niekt\u00f3re assemblery nie wymagaj\u0105 dla tych rozkaz\u00f3w podania znaku # , jednak MADS wymaga tego): #$xx dla SEP REP COP #$xxxx dla PEA Innym wyj\u0105tkiem jest tryb adresowania po\u015bredni d\u0142ugi, kt\u00f3ry reprezentowany jest przez nawiasy kwadratowe [] . Jak wiemy tego typu nawiasy wykorzystywane s\u0105 te\u017c do obliczania wyra\u017ce\u0144, jednak je\u015bli asembler napotka pierwszy znak [ uzna to za tryb adresowania po\u015bredni d\u0142ugi i je\u015bli nie zasygnalizowali\u015bmy ch\u0119ci u\u017cywania 65816 wyst\u0105pi b\u0142\u0105d z komunikatem Illegal adressing mode . Aby oszuka\u0107 assembler wystarczy da\u0107 przed kwadratowym nawiasem otwieraj\u0105cym [ znak + . lda [2+4] ; lda [6] lda +[2+4] ; lda 6","title":"Rozszerzanie mnemonika"},{"location":"procedury/","text":"Procedury MADS wprowadza nowe mo\u017cliwo\u015bci w obs\u0142udze procedur z parametrami. Nowe mo\u017cliwo\u015bci upodabniaj\u0105 ten mechanizm do tych znanych z j\u0119zyk\u00f3w wysokiego poziomu i s\u0105 tak samo \u0142atwe w u\u017cyciu dla programisty. Aktualnie do\u0142\u0105czone do MADS -a deklaracje makr ( @CALL.MAC , @PULL.MAC , @EXIT.MAC ) umo\u017cliwiaj\u0105 obs\u0142ug\u0119 stosu programowego o wielko\u015bci 256 bajt\u00f3w, czyli tej samej wielko\u015bci jak stos sprz\u0119towy, udost\u0119pniaj\u0105 mechanizm zdejmowania ze stosu programowego i odk\u0142adania na stos programowy parametr\u00f3w potrzebnych podczas wywo\u0142ywania procedur, jak i wychodzenia z takich procedur. MADS uwzgl\u0119dnia mo\u017cliwo\u015b\u0107 rekurencji takich procedur. Programista nie jest zaanga\u017cowany w ten mechanizm, mo\u017ce skupi\u0107 uwag\u0119 na swoim programie. Musi tylko pami\u0119ta\u0107 o potrzebie zdefiniowania odpowiednich etykiet i do\u0142\u0105czeniu odpowiednich makr podczas asemblacji programu. Dodatkowo istnieje mo\u017cliwo\u015b\u0107 pomini\u0119cia \"mechanizmu\" stosu programowego MADS -a i skorzystanie z klasycznego sposobu ich przekazywania, za pomoc\u0105 rejestr\u00f3w CPU (dyrektywa .REG ) lub przez zmienne (dyrektywa .VAR ). Inn\u0105 w\u0142a\u015bciwo\u015bci\u0105 procedur .PROC jest mo\u017cliwo\u015b\u0107 pomini\u0119cia ich podczas asemblacji je\u015bli nie wyst\u0105pi\u0142o \u017cadne odwo\u0142anie do nich, czyli zosta\u0142y zdefiniowane ale nie s\u0105 wykorzystane. Wyst\u0105pi w\u00f3wczas komunikat ostrze\u017cenia Unreferenced procedure ???? . Pomini\u0119cie takiej procedury podczas asemblacji mo\u017cliwe jest poprzez podanie parametru do MADS -a w linii polece\u0144 -x 'Exclude unreferenced procedures' . Wszelkie etykiety zdefiniowane w obszarze procedury .PROC s\u0105 zasi\u0119gu lokalnego, mo\u017cna je te\u017c okre\u015bli\u0107 jako etykiety globalne zdefiniowane lokalnie o dost\u0119pie swobodnym, poniewa\u017c mo\u017cna si\u0119 do nich odwo\u0142ywa\u0107 co nie jest normalne w innych j\u0119zykach programowania. W obszarze procedury .PROC istnieje mo\u017cliwo\u015b\u0107 zdefiniowania etykiet o zasi\u0119gu globalnym (patrz rozdzia\u0142 Etykiety globalne ). Je\u015bli chcemy dosta\u0107 si\u0119 do etykiet zdefiniowanych w procedurze spoza obszaru procedury, w\u00f3wczas adresujemy z u\u017cyciem znaku kropki . , np.: lda test.pole .proc test pole nop .endp Je\u015bli poszukiwana przez assembler etykieta nie wyst\u0105pi\u0142a w obszarze procedury .PROC , w\u00f3wczas MADS b\u0119dzie poszukiwa\u0142 j\u0105 w obszarze ni\u017cszym a\u017c dojdzie do obszaru globalnego. Aby odczyta\u0107 natychmiastowo warto\u015b\u0107 etykiety globalnej z poziomu procedury .PROC (czy te\u017c innego obszaru lokalnego) poprzedzamy nazw\u0119 etykiety znakiem dwukropka : . MADS wymaga dla procedur wykorzystuj\u0105cych stos programowy, trzech globalnych definicji etykiet o konkretnych nazwach (adres stosu, wska\u017anik stosu, adres parametr\u00f3w procedury): @PROC_VARS_ADR @STACK_ADDRESS @STACK_POINTER Brak definicji w/w etykiet i pr\u00f3ba u\u017cycia bloku .PROC wykorzystuj\u0105cego stos programowy spowoduje \u017ce MADS przyjmie swoje domy\u015blne warto\u015bci tych etykiet: @PROC_VARS_ADR = $0500 , @STACK_ADDRESS = $0600 , @STACK_POINTER = $FE MADS dla procedur wykorzystuj\u0105cych stos programowy wymaga tak\u017ce deklaracji makr o konkretnych nazwach. Do\u0142\u0105czone do MADS -a deklaracje tych makr znajduj\u0105 si\u0119 w plikach: @CALL ..\\EXAMPLES\\MACROS\\@CALL.MAC @PUSH ..\\EXAMPLES\\MACROS\\@CALL.MAC @PULL ..\\EXAMPLES\\MACROS\\@PULL.MAC @EXIT ..\\EXAMPLES\\MACROS\\@EXIT.MAC W/w makra realizuj\u0105 przekazywanie i odk\u0142adanie na programowy stos parametr\u00f3w, oraz zdejmowanie i odk\u0142adanie parametr\u00f3w dla procedur wykorzystuj\u0105cych stos programowy i wywo\u0142ywanych z poziomu innych procedur wykorzystuj\u0105cych stos programowy. Deklaracja procedury Procedur dotycz\u0105 n/w dyrektywy: name .PROC [(.TYPE PAR1 .TYPE PAR2 ...)] [.REG] [.VAR] .PROC name [,address] [(.TYPE PAR1 .TYPE PAR2 ...)] [.REG] [.VAR] .ENDP [.PEND] [.END] name .PROC [(.TYPE Par1,Par2 .TYPE Par3 ...)] [.REG] [.VAR] Deklaracja procedury name przy u\u017cyciu dyrektywy .PROC . Nazwa procedury jest wymagana i konieczna, jej brak wygeneruje b\u0142\u0105d. Do nazw procedur nie mo\u017cna u\u017cywa\u0107 nazw mnemonik\u00f3w i pseudo rozkaz\u00f3w. Je\u015bli nazwa jest zarezerwowana wyst\u0105pi b\u0142\u0105d z komunikatem Reserved word . Je\u015bli chcemy wykorzysta\u0107 jeden z mechanizm\u00f3w MADS -a do przekazywania parametr\u00f3w do procedur, musimy je wcze\u015bniej zadeklarowa\u0107. Deklaracja parametr\u00f3w procedury mie\u015bci si\u0119 pomi\u0119dzy nawiasami okr\u0105g\u0142ymi ( ) . Dost\u0119pne s\u0105 cztery typy parametr\u00f3w: .BYTE (8-bit) relokowalne .WORD (16-bit) relokowalne .LONG (24-bit) nierelokowalne .DWORD (32-bit) nierelokowalne W obecnej wersji MADS -a nie ma mo\u017cliwo\u015bci przekazywania parametr\u00f3w za pomoc\u0105 struktur .STRUCT . Bezpo\u015brednio po deklaracji typu, oddzielona minimum jedn\u0105 spacj\u0105, nast\u0119puje nazwa parametru. Je\u015bli deklarujemy wi\u0119cej parametr\u00f3w tego samego typu mo\u017cemy rozdzieli\u0107 ich nazwy znakiem przecinka ','. Przyk\u0142ad deklaracji procedury wykorzystuj\u0105cej stos programowy: name .PROC ( .WORD par1 .BYTE par2 ) name .PROC ( .BYTE par1,par2 .LONG par3 ) name .PROC ( .DWORD p1,p2,p3,p4,p5,p6,p7,p8 ) Dodatkowo u\u017cywaj\u0105c dyrektyw .REG lub .VAR mamy mo\u017cliwo\u015b\u0107 okre\u015blenia sposobu i metody przekazywania parametr\u00f3w do procedur MADS -a. Przez rejestry CPU ( .REG ) lub przez zmienne ( .VAR ). Dyrektywy okre\u015blaj\u0105ce spos\u00f3b przekazywania parametr\u00f3w umieszczamy na ko\u0144cu naszej deklaracji procedury .PROC Przyk\u0142ad deklaracji procedury wykorzystuj\u0105cej rejestry CPU : name .PROC ( .BYTE x,y,a ) .REG name .PROC ( .WORD xa .BYTE y ) .REG name .PROC ( .LONG axy ) .REG Dyrektywa .REG wymaga aby nazwy parametr\u00f3w sk\u0142ada\u0142y si\u0119 z liter A , X , Y lub ich kombinacji. Litery te odpowiadaj\u0105 nazwom rejestr\u00f3w CPU i wp\u0142ywaj\u0105 na kolejno\u015b\u0107 u\u017cycia rejestr\u00f3w. Ograniczeniem w liczbie przekazywanych parametr\u00f3w jest ilo\u015b\u0107 rejestr\u00f3w CPU , przez co mo\u017cemy przekaza\u0107 do procedury w sumie maksimum 3 bajty. Zalet\u0105 takiego sposobu jest natomiast szybko\u015b\u0107 i ma\u0142e zu\u017cycie pami\u0119ci RAM . Przyk\u0142ad deklaracji procedury wykorzystuj\u0105cej zmienne: name .PROC ( .BYTE x1,x2,y1,y2 ) .VAR name .PROC ( .WORD inputPointer, outputPointer ) .VAR name .PROC ( .WORD src+1, dst+1 ) .VAR Dla .VAR nazwy parametr\u00f3w wskazuj\u0105 nazwy zmiennych do kt\u00f3rych b\u0119d\u0105 \u0142adowane przekazywane parametry. Metoda ta jest wolniejsza od .REG jednak nadal szybsza od metody ze stosem programowym. Procedur\u0119 opuszczamy w standardowy spos\u00f3b, czyli przy pomocy rozkazu RTS . Dodanie rozkazu RTS w ciele procedury przy wyj\u015bciu z ka\u017cdej \u015bcie\u017cki jest obowi\u0105zkiem programuj\u0105cego, a nie assemblera. Podobnie jak w przypadku bloku .LOCAL mamy mo\u017cliwo\u015b\u0107 okre\u015blenia nowego adresu asemblacji dla bloku .PROC , np.: .PROC label,$8000 .ENDP .PROC label2,$a000 (.word ax) .reg .ENDP W przypadku procedur wykorzystuj\u0105cych stos programowy po zako\u0144czeniu procedury przez .ENDP MADS wywo\u0142uje makro @EXIT , kt\u00f3rego zadaniem jest modyfikacja wska\u017anika stosu programowego @STACK_POINTER , jest to konieczne dla prawid\u0142owego dzia\u0142ania stosu programowego. U\u017cytkownik mo\u017ce sam zaprojektowa\u0107 swoje makro @EXIT , albo skorzysta\u0107 z do\u0142\u0105czonego do MADS -a (plik ..\\EXAMPLES\\MACROS\\@EXIT.MAC), ma ono obecnie nast\u0119puj\u0105c\u0105 posta\u0107: .macro @EXIT ift :1<>0 ift :1=1 dec @stack_pointer eli :1=2 dec @stack_pointer dec @stack_pointer els pha lda @stack_pointer sub #:1 sta @stack_pointer pla eif eif .endm Makro @EXIT nie powinno zmienia\u0107 zawarto\u015bci rejestr\u00f3w CPU je\u015bli chcemy zachowa\u0107 mo\u017cliwo\u015b\u0107 zwr\u00f3cenie wyniku dzia\u0142ania procedury .PROC poprzez rejestry CPU . .ENDP Dyrektywa .ENDP ko\u0144czy deklaracj\u0119 bloku procedury. Wywo\u0142anie procedury Procedur\u0119 wywo\u0142ujemy poprzez jej nazw\u0119 (identycznie jak makro), po niej mog\u0105 wyst\u0105pi\u0107 parametry, rozdzielone separatorem w postaci znaku przecinka , lub spacji ' ' (nie ma mo\u017cliwo\u015bci zadeklarowania innych separator\u00f3w). Je\u015bli typ parametru nie b\u0119dzie zgadza\u0142 si\u0119 z typem zadeklarowanym w deklaracji procedury wyst\u0105pi komunikat b\u0142\u0119du Incompatible types . Je\u015bli przekazana liczba parametr\u00f3w r\u00f3\u017cni si\u0119 od liczby zadeklarowanych parametr\u00f3w w deklaracji procedury to wyst\u0105pi komunikat b\u0142\u0119du Improper number of actual parameters . Wyj\u0105tkiem jest procedura do kt\u00f3rej parametry przekazywane s\u0105 przez rejestry CPU ( .REG ) lub zmienne ( .VAR ), w takich przypadkach mo\u017cemy pomin\u0105\u0107 parametry, w domy\u015ble s\u0105 one ju\u017c za\u0142adowane do odpowiednich rejestr\u00f3w czy te\u017c zmiennych. Mo\u017cliwe s\u0105 trzy sposoby przekazania parametru: '#' przez warto\u015b\u0107 ' ' przez warto\u015b\u0107 spod adresu (bez znaku poprzedzaj\u0105cego) '@' przez akumulator (parametry typu .BYTE) \"string\" przez ci\u0105g znakowy, np. \"label,x\" Przyk\u0142ad wywo\u0142ania procedury: name @ , #$166 , $A400 ; dla stosu programowego name , @ , #$3f ; dla .REG lub .VAR name \"(hlp),y\" \"tab,y\" ; dla .VAR lub dla stosu programowego (stos programowy korzysta z regX) MADS po napotkaniu wywo\u0142ania procedury, kt\u00f3ra korzysta ze stosu programowego wymusza wykonanie makra @CALL . Je\u015bli jednak procedura nie korzysta ze stosu programowego, zamiast makra @CALL zostanie wygenerowany zwyk\u0142y rozkaz JSR PROCEDURE . Do makra @CALL MADS przekazuje parametry wyliczone na podstawie deklaracji procedury (rozbija ka\u017cdy parametr na trzy sk\u0142adowe: tryb adresacji, typ parametru, warto\u015b\u0107 parametru). @CALL_INIT 3\\ @PUSH_INIT 3\\ @CALL '@','B',0\\ @CALL '#','W',358\\ @CALL ' ',W,\"$A400\"\\ @CALL_END PROC_NAME Makro @CALL od\u0142o\u017cy na stos zawarto\u015b\u0107 akumulatora, nast\u0119pnie warto\u015b\u0107 $166 (358 dec), nast\u0119pnie warto\u015b\u0107 spod adresu $A400. Wi\u0119cej informacji na temat sposobu przekazywania parametr\u00f3w do makr (znaczenia apostrof\u00f3w ' ' i \" \" ) w rozdziale Wywo\u0142anie makra . Parametr przekazywany przez akumulator @ powinien by\u0107 zawsze pierwszym parametrem przekazywanym do procedury, je\u015bli wyst\u0105pi w innym miejscu zawarto\u015b\u0107 akumulatora zostanie zmodyfikowana (domy\u015blne makro @CALL nak\u0142ada takie ograniczenie). Oczywi\u015bcie u\u017cytkownik mo\u017ce to zmieni\u0107 pisz\u0105c swoj\u0105 wersj\u0119 makra @CALL . W przypadku procedur .REG lub .VAR kolejno\u015b\u0107 wyst\u0105pienia parametru @ nie ma znaczenia. Wyj\u015bcie z procedury .PROC nast\u0119puje poprzez rozkaz RTS . Po powrocie z procedury MADS wywo\u0142uje makro @EXIT kt\u00f3re zawiera program modyfikuj\u0105cy warto\u015b\u0107 wska\u017anika stosu @STACK_POINTER , jest to niezb\u0119dne w celu prawid\u0142owego dzia\u0142ania stosu programowego. Od wska\u017anika stosu odejmowana jest liczba bajt\u00f3w kt\u00f3re zosta\u0142y przekazane do procedury, liczba bajt\u00f3w przekazywana jest do makra jako parametr. Dodanie rozkazu RTS w ciele procedury przy wyj\u015bciu z ka\u017cdej \u015bcie\u017cki jest obowi\u0105zkiem programuj\u0105cego, a nie assemblera. Parametry procedury Odwo\u0142ania do parametr\u00f3w procedury z poziomu procedury nie wymagaj\u0105 dodatkowych operacji ze strony programisty, np.: @stack_address equ $400 @stack_pointer equ $ff @proc_vars_adr equ $80 name .PROC (.WORD par1,par2) lda par1 clc adc par2 sta par1 lda par1+1 adc par2+1 sta par1+1 .endp icl '@call.mac' icl '@pull.mac' icl '@exit.mac' MADS w momencie napotkania deklaracji .PROC z parametrami, dokonuje automatycznej definicji tych parametr\u00f3w przypisuj\u0105c im warto\u015bci na podstawie @PROC_VARS_ADR . W w/w przyk\u0142adzie MADS dokona automatycznej definicji parametr\u00f3w PAR1 = @PROC_VARS_ADR , PAR2 = @PROC_VARS_ADR + 2 . Programista odwo\u0142uje si\u0119 do tych parametr\u00f3w po nazwie jaka zosta\u0142a im nadana w deklaracji procedury, czyli podobnie jak ma to miejsce w j\u0119zykach wy\u017cszego poziomu. W MADS istnieje mo\u017cliwo\u015b\u0107 dost\u0119pu do parametr\u00f3w procedury spoza procedury co nie jest ju\u017c normalne w j\u0119zykach wy\u017cszego poziomu. Mo\u017cemy odczyta\u0107 z w/w przyk\u0142adu zawarto\u015b\u0107 PAR1 , np.: lda name.par1 sta $a000 lda name.par1+1 sta $a000+1 Warto\u015b\u0107 PAR1 zosta\u0142a przepisane pod adres $A000, warto\u015b\u0107 PAR1+1 pod adres $A000+1. Oczywi\u015bcie mo\u017cemy tego dokona\u0107 tylko bezpo\u015brednio po zako\u0144czeniu tej konkretnej procedury. Trzeba pami\u0119ta\u0107 \u017ce parametry takich procedur odk\u0142adane s\u0105 pod wsp\u00f3lnym adresem @PROC_VARS_ADR , wi\u0119c z ka\u017cdym nowym wywo\u0142aniem procedury wykorzystuj\u0105cej stos programowy zawarto\u015b\u0107 obszaru <@PROC_VARS_ADR .. @PROC_VARS_ADR + $FF> ulega zmianom. Je\u015bli procedura ma zadeklarowane parametry typu .REG programista powinien zatroszczy\u0107 si\u0119 o to aby je zapami\u0119ta\u0107 czy te\u017c w\u0142a\u015bciwie wykorzysta\u0107 zanim zostan\u0105 zmodyfikowane przez kod procedury. W przypadku parametr\u00f3w typu .VAR nie trzeba si\u0119 o nic martwi\u0107 poniewa\u017c parametry zosta\u0142y zapisane do konkretnych kom\u00f3rek pami\u0119ci sk\u0105d zawsze mo\u017cemy je odczyta\u0107.","title":"Procedury"},{"location":"procedury/#procedury","text":"MADS wprowadza nowe mo\u017cliwo\u015bci w obs\u0142udze procedur z parametrami. Nowe mo\u017cliwo\u015bci upodabniaj\u0105 ten mechanizm do tych znanych z j\u0119zyk\u00f3w wysokiego poziomu i s\u0105 tak samo \u0142atwe w u\u017cyciu dla programisty. Aktualnie do\u0142\u0105czone do MADS -a deklaracje makr ( @CALL.MAC , @PULL.MAC , @EXIT.MAC ) umo\u017cliwiaj\u0105 obs\u0142ug\u0119 stosu programowego o wielko\u015bci 256 bajt\u00f3w, czyli tej samej wielko\u015bci jak stos sprz\u0119towy, udost\u0119pniaj\u0105 mechanizm zdejmowania ze stosu programowego i odk\u0142adania na stos programowy parametr\u00f3w potrzebnych podczas wywo\u0142ywania procedur, jak i wychodzenia z takich procedur. MADS uwzgl\u0119dnia mo\u017cliwo\u015b\u0107 rekurencji takich procedur. Programista nie jest zaanga\u017cowany w ten mechanizm, mo\u017ce skupi\u0107 uwag\u0119 na swoim programie. Musi tylko pami\u0119ta\u0107 o potrzebie zdefiniowania odpowiednich etykiet i do\u0142\u0105czeniu odpowiednich makr podczas asemblacji programu. Dodatkowo istnieje mo\u017cliwo\u015b\u0107 pomini\u0119cia \"mechanizmu\" stosu programowego MADS -a i skorzystanie z klasycznego sposobu ich przekazywania, za pomoc\u0105 rejestr\u00f3w CPU (dyrektywa .REG ) lub przez zmienne (dyrektywa .VAR ). Inn\u0105 w\u0142a\u015bciwo\u015bci\u0105 procedur .PROC jest mo\u017cliwo\u015b\u0107 pomini\u0119cia ich podczas asemblacji je\u015bli nie wyst\u0105pi\u0142o \u017cadne odwo\u0142anie do nich, czyli zosta\u0142y zdefiniowane ale nie s\u0105 wykorzystane. Wyst\u0105pi w\u00f3wczas komunikat ostrze\u017cenia Unreferenced procedure ???? . Pomini\u0119cie takiej procedury podczas asemblacji mo\u017cliwe jest poprzez podanie parametru do MADS -a w linii polece\u0144 -x 'Exclude unreferenced procedures' . Wszelkie etykiety zdefiniowane w obszarze procedury .PROC s\u0105 zasi\u0119gu lokalnego, mo\u017cna je te\u017c okre\u015bli\u0107 jako etykiety globalne zdefiniowane lokalnie o dost\u0119pie swobodnym, poniewa\u017c mo\u017cna si\u0119 do nich odwo\u0142ywa\u0107 co nie jest normalne w innych j\u0119zykach programowania. W obszarze procedury .PROC istnieje mo\u017cliwo\u015b\u0107 zdefiniowania etykiet o zasi\u0119gu globalnym (patrz rozdzia\u0142 Etykiety globalne ). Je\u015bli chcemy dosta\u0107 si\u0119 do etykiet zdefiniowanych w procedurze spoza obszaru procedury, w\u00f3wczas adresujemy z u\u017cyciem znaku kropki . , np.: lda test.pole .proc test pole nop .endp Je\u015bli poszukiwana przez assembler etykieta nie wyst\u0105pi\u0142a w obszarze procedury .PROC , w\u00f3wczas MADS b\u0119dzie poszukiwa\u0142 j\u0105 w obszarze ni\u017cszym a\u017c dojdzie do obszaru globalnego. Aby odczyta\u0107 natychmiastowo warto\u015b\u0107 etykiety globalnej z poziomu procedury .PROC (czy te\u017c innego obszaru lokalnego) poprzedzamy nazw\u0119 etykiety znakiem dwukropka : . MADS wymaga dla procedur wykorzystuj\u0105cych stos programowy, trzech globalnych definicji etykiet o konkretnych nazwach (adres stosu, wska\u017anik stosu, adres parametr\u00f3w procedury): @PROC_VARS_ADR @STACK_ADDRESS @STACK_POINTER Brak definicji w/w etykiet i pr\u00f3ba u\u017cycia bloku .PROC wykorzystuj\u0105cego stos programowy spowoduje \u017ce MADS przyjmie swoje domy\u015blne warto\u015bci tych etykiet: @PROC_VARS_ADR = $0500 , @STACK_ADDRESS = $0600 , @STACK_POINTER = $FE MADS dla procedur wykorzystuj\u0105cych stos programowy wymaga tak\u017ce deklaracji makr o konkretnych nazwach. Do\u0142\u0105czone do MADS -a deklaracje tych makr znajduj\u0105 si\u0119 w plikach: @CALL ..\\EXAMPLES\\MACROS\\@CALL.MAC @PUSH ..\\EXAMPLES\\MACROS\\@CALL.MAC @PULL ..\\EXAMPLES\\MACROS\\@PULL.MAC @EXIT ..\\EXAMPLES\\MACROS\\@EXIT.MAC W/w makra realizuj\u0105 przekazywanie i odk\u0142adanie na programowy stos parametr\u00f3w, oraz zdejmowanie i odk\u0142adanie parametr\u00f3w dla procedur wykorzystuj\u0105cych stos programowy i wywo\u0142ywanych z poziomu innych procedur wykorzystuj\u0105cych stos programowy.","title":"Procedury"},{"location":"procedury/#deklaracja-procedury","text":"Procedur dotycz\u0105 n/w dyrektywy: name .PROC [(.TYPE PAR1 .TYPE PAR2 ...)] [.REG] [.VAR] .PROC name [,address] [(.TYPE PAR1 .TYPE PAR2 ...)] [.REG] [.VAR] .ENDP [.PEND] [.END]","title":"Deklaracja procedury"},{"location":"procedury/#name-proc-type-par1par2-type-par3-reg-var","text":"Deklaracja procedury name przy u\u017cyciu dyrektywy .PROC . Nazwa procedury jest wymagana i konieczna, jej brak wygeneruje b\u0142\u0105d. Do nazw procedur nie mo\u017cna u\u017cywa\u0107 nazw mnemonik\u00f3w i pseudo rozkaz\u00f3w. Je\u015bli nazwa jest zarezerwowana wyst\u0105pi b\u0142\u0105d z komunikatem Reserved word . Je\u015bli chcemy wykorzysta\u0107 jeden z mechanizm\u00f3w MADS -a do przekazywania parametr\u00f3w do procedur, musimy je wcze\u015bniej zadeklarowa\u0107. Deklaracja parametr\u00f3w procedury mie\u015bci si\u0119 pomi\u0119dzy nawiasami okr\u0105g\u0142ymi ( ) . Dost\u0119pne s\u0105 cztery typy parametr\u00f3w: .BYTE (8-bit) relokowalne .WORD (16-bit) relokowalne .LONG (24-bit) nierelokowalne .DWORD (32-bit) nierelokowalne W obecnej wersji MADS -a nie ma mo\u017cliwo\u015bci przekazywania parametr\u00f3w za pomoc\u0105 struktur .STRUCT . Bezpo\u015brednio po deklaracji typu, oddzielona minimum jedn\u0105 spacj\u0105, nast\u0119puje nazwa parametru. Je\u015bli deklarujemy wi\u0119cej parametr\u00f3w tego samego typu mo\u017cemy rozdzieli\u0107 ich nazwy znakiem przecinka ','. Przyk\u0142ad deklaracji procedury wykorzystuj\u0105cej stos programowy: name .PROC ( .WORD par1 .BYTE par2 ) name .PROC ( .BYTE par1,par2 .LONG par3 ) name .PROC ( .DWORD p1,p2,p3,p4,p5,p6,p7,p8 ) Dodatkowo u\u017cywaj\u0105c dyrektyw .REG lub .VAR mamy mo\u017cliwo\u015b\u0107 okre\u015blenia sposobu i metody przekazywania parametr\u00f3w do procedur MADS -a. Przez rejestry CPU ( .REG ) lub przez zmienne ( .VAR ). Dyrektywy okre\u015blaj\u0105ce spos\u00f3b przekazywania parametr\u00f3w umieszczamy na ko\u0144cu naszej deklaracji procedury .PROC Przyk\u0142ad deklaracji procedury wykorzystuj\u0105cej rejestry CPU : name .PROC ( .BYTE x,y,a ) .REG name .PROC ( .WORD xa .BYTE y ) .REG name .PROC ( .LONG axy ) .REG Dyrektywa .REG wymaga aby nazwy parametr\u00f3w sk\u0142ada\u0142y si\u0119 z liter A , X , Y lub ich kombinacji. Litery te odpowiadaj\u0105 nazwom rejestr\u00f3w CPU i wp\u0142ywaj\u0105 na kolejno\u015b\u0107 u\u017cycia rejestr\u00f3w. Ograniczeniem w liczbie przekazywanych parametr\u00f3w jest ilo\u015b\u0107 rejestr\u00f3w CPU , przez co mo\u017cemy przekaza\u0107 do procedury w sumie maksimum 3 bajty. Zalet\u0105 takiego sposobu jest natomiast szybko\u015b\u0107 i ma\u0142e zu\u017cycie pami\u0119ci RAM . Przyk\u0142ad deklaracji procedury wykorzystuj\u0105cej zmienne: name .PROC ( .BYTE x1,x2,y1,y2 ) .VAR name .PROC ( .WORD inputPointer, outputPointer ) .VAR name .PROC ( .WORD src+1, dst+1 ) .VAR Dla .VAR nazwy parametr\u00f3w wskazuj\u0105 nazwy zmiennych do kt\u00f3rych b\u0119d\u0105 \u0142adowane przekazywane parametry. Metoda ta jest wolniejsza od .REG jednak nadal szybsza od metody ze stosem programowym. Procedur\u0119 opuszczamy w standardowy spos\u00f3b, czyli przy pomocy rozkazu RTS . Dodanie rozkazu RTS w ciele procedury przy wyj\u015bciu z ka\u017cdej \u015bcie\u017cki jest obowi\u0105zkiem programuj\u0105cego, a nie assemblera. Podobnie jak w przypadku bloku .LOCAL mamy mo\u017cliwo\u015b\u0107 okre\u015blenia nowego adresu asemblacji dla bloku .PROC , np.: .PROC label,$8000 .ENDP .PROC label2,$a000 (.word ax) .reg .ENDP W przypadku procedur wykorzystuj\u0105cych stos programowy po zako\u0144czeniu procedury przez .ENDP MADS wywo\u0142uje makro @EXIT , kt\u00f3rego zadaniem jest modyfikacja wska\u017anika stosu programowego @STACK_POINTER , jest to konieczne dla prawid\u0142owego dzia\u0142ania stosu programowego. U\u017cytkownik mo\u017ce sam zaprojektowa\u0107 swoje makro @EXIT , albo skorzysta\u0107 z do\u0142\u0105czonego do MADS -a (plik ..\\EXAMPLES\\MACROS\\@EXIT.MAC), ma ono obecnie nast\u0119puj\u0105c\u0105 posta\u0107: .macro @EXIT ift :1<>0 ift :1=1 dec @stack_pointer eli :1=2 dec @stack_pointer dec @stack_pointer els pha lda @stack_pointer sub #:1 sta @stack_pointer pla eif eif .endm Makro @EXIT nie powinno zmienia\u0107 zawarto\u015bci rejestr\u00f3w CPU je\u015bli chcemy zachowa\u0107 mo\u017cliwo\u015b\u0107 zwr\u00f3cenie wyniku dzia\u0142ania procedury .PROC poprzez rejestry CPU .","title":"name .PROC [(.TYPE Par1,Par2 .TYPE Par3 ...)] [.REG] [.VAR]"},{"location":"procedury/#endp","text":"Dyrektywa .ENDP ko\u0144czy deklaracj\u0119 bloku procedury.","title":".ENDP"},{"location":"procedury/#wywoanie-procedury","text":"Procedur\u0119 wywo\u0142ujemy poprzez jej nazw\u0119 (identycznie jak makro), po niej mog\u0105 wyst\u0105pi\u0107 parametry, rozdzielone separatorem w postaci znaku przecinka , lub spacji ' ' (nie ma mo\u017cliwo\u015bci zadeklarowania innych separator\u00f3w). Je\u015bli typ parametru nie b\u0119dzie zgadza\u0142 si\u0119 z typem zadeklarowanym w deklaracji procedury wyst\u0105pi komunikat b\u0142\u0119du Incompatible types . Je\u015bli przekazana liczba parametr\u00f3w r\u00f3\u017cni si\u0119 od liczby zadeklarowanych parametr\u00f3w w deklaracji procedury to wyst\u0105pi komunikat b\u0142\u0119du Improper number of actual parameters . Wyj\u0105tkiem jest procedura do kt\u00f3rej parametry przekazywane s\u0105 przez rejestry CPU ( .REG ) lub zmienne ( .VAR ), w takich przypadkach mo\u017cemy pomin\u0105\u0107 parametry, w domy\u015ble s\u0105 one ju\u017c za\u0142adowane do odpowiednich rejestr\u00f3w czy te\u017c zmiennych. Mo\u017cliwe s\u0105 trzy sposoby przekazania parametru: '#' przez warto\u015b\u0107 ' ' przez warto\u015b\u0107 spod adresu (bez znaku poprzedzaj\u0105cego) '@' przez akumulator (parametry typu .BYTE) \"string\" przez ci\u0105g znakowy, np. \"label,x\" Przyk\u0142ad wywo\u0142ania procedury: name @ , #$166 , $A400 ; dla stosu programowego name , @ , #$3f ; dla .REG lub .VAR name \"(hlp),y\" \"tab,y\" ; dla .VAR lub dla stosu programowego (stos programowy korzysta z regX) MADS po napotkaniu wywo\u0142ania procedury, kt\u00f3ra korzysta ze stosu programowego wymusza wykonanie makra @CALL . Je\u015bli jednak procedura nie korzysta ze stosu programowego, zamiast makra @CALL zostanie wygenerowany zwyk\u0142y rozkaz JSR PROCEDURE . Do makra @CALL MADS przekazuje parametry wyliczone na podstawie deklaracji procedury (rozbija ka\u017cdy parametr na trzy sk\u0142adowe: tryb adresacji, typ parametru, warto\u015b\u0107 parametru). @CALL_INIT 3\\ @PUSH_INIT 3\\ @CALL '@','B',0\\ @CALL '#','W',358\\ @CALL ' ',W,\"$A400\"\\ @CALL_END PROC_NAME Makro @CALL od\u0142o\u017cy na stos zawarto\u015b\u0107 akumulatora, nast\u0119pnie warto\u015b\u0107 $166 (358 dec), nast\u0119pnie warto\u015b\u0107 spod adresu $A400. Wi\u0119cej informacji na temat sposobu przekazywania parametr\u00f3w do makr (znaczenia apostrof\u00f3w ' ' i \" \" ) w rozdziale Wywo\u0142anie makra . Parametr przekazywany przez akumulator @ powinien by\u0107 zawsze pierwszym parametrem przekazywanym do procedury, je\u015bli wyst\u0105pi w innym miejscu zawarto\u015b\u0107 akumulatora zostanie zmodyfikowana (domy\u015blne makro @CALL nak\u0142ada takie ograniczenie). Oczywi\u015bcie u\u017cytkownik mo\u017ce to zmieni\u0107 pisz\u0105c swoj\u0105 wersj\u0119 makra @CALL . W przypadku procedur .REG lub .VAR kolejno\u015b\u0107 wyst\u0105pienia parametru @ nie ma znaczenia. Wyj\u015bcie z procedury .PROC nast\u0119puje poprzez rozkaz RTS . Po powrocie z procedury MADS wywo\u0142uje makro @EXIT kt\u00f3re zawiera program modyfikuj\u0105cy warto\u015b\u0107 wska\u017anika stosu @STACK_POINTER , jest to niezb\u0119dne w celu prawid\u0142owego dzia\u0142ania stosu programowego. Od wska\u017anika stosu odejmowana jest liczba bajt\u00f3w kt\u00f3re zosta\u0142y przekazane do procedury, liczba bajt\u00f3w przekazywana jest do makra jako parametr. Dodanie rozkazu RTS w ciele procedury przy wyj\u015bciu z ka\u017cdej \u015bcie\u017cki jest obowi\u0105zkiem programuj\u0105cego, a nie assemblera.","title":"Wywo\u0142anie procedury"},{"location":"procedury/#parametry-procedury","text":"Odwo\u0142ania do parametr\u00f3w procedury z poziomu procedury nie wymagaj\u0105 dodatkowych operacji ze strony programisty, np.: @stack_address equ $400 @stack_pointer equ $ff @proc_vars_adr equ $80 name .PROC (.WORD par1,par2) lda par1 clc adc par2 sta par1 lda par1+1 adc par2+1 sta par1+1 .endp icl '@call.mac' icl '@pull.mac' icl '@exit.mac' MADS w momencie napotkania deklaracji .PROC z parametrami, dokonuje automatycznej definicji tych parametr\u00f3w przypisuj\u0105c im warto\u015bci na podstawie @PROC_VARS_ADR . W w/w przyk\u0142adzie MADS dokona automatycznej definicji parametr\u00f3w PAR1 = @PROC_VARS_ADR , PAR2 = @PROC_VARS_ADR + 2 . Programista odwo\u0142uje si\u0119 do tych parametr\u00f3w po nazwie jaka zosta\u0142a im nadana w deklaracji procedury, czyli podobnie jak ma to miejsce w j\u0119zykach wy\u017cszego poziomu. W MADS istnieje mo\u017cliwo\u015b\u0107 dost\u0119pu do parametr\u00f3w procedury spoza procedury co nie jest ju\u017c normalne w j\u0119zykach wy\u017cszego poziomu. Mo\u017cemy odczyta\u0107 z w/w przyk\u0142adu zawarto\u015b\u0107 PAR1 , np.: lda name.par1 sta $a000 lda name.par1+1 sta $a000+1 Warto\u015b\u0107 PAR1 zosta\u0142a przepisane pod adres $A000, warto\u015b\u0107 PAR1+1 pod adres $A000+1. Oczywi\u015bcie mo\u017cemy tego dokona\u0107 tylko bezpo\u015brednio po zako\u0144czeniu tej konkretnej procedury. Trzeba pami\u0119ta\u0107 \u017ce parametry takich procedur odk\u0142adane s\u0105 pod wsp\u00f3lnym adresem @PROC_VARS_ADR , wi\u0119c z ka\u017cdym nowym wywo\u0142aniem procedury wykorzystuj\u0105cej stos programowy zawarto\u015b\u0107 obszaru <@PROC_VARS_ADR .. @PROC_VARS_ADR + $FF> ulega zmianom. Je\u015bli procedura ma zadeklarowane parametry typu .REG programista powinien zatroszczy\u0107 si\u0119 o to aby je zapami\u0119ta\u0107 czy te\u017c w\u0142a\u015bciwie wykorzysta\u0107 zanim zostan\u0105 zmodyfikowane przez kod procedury. W przypadku parametr\u00f3w typu .VAR nie trzeba si\u0119 o nic martwi\u0107 poniewa\u017c parametry zosta\u0142y zapisane do konkretnych kom\u00f3rek pami\u0119ci sk\u0105d zawsze mo\u017cemy je odczyta\u0107.","title":"Parametry procedury"},{"location":"projekty/","text":"TODO","title":"Projekty"},{"location":"projekty/#_1","text":"","title":""},{"location":"projekty/#todo","text":"","title":"TODO"},{"location":"przyklady/","text":"TODO","title":"Przyk\u0142ady"},{"location":"przyklady/#_1","text":"","title":""},{"location":"przyklady/#todo","text":"","title":"TODO"},{"location":"pseudo-rozkazy/","text":"Pseudo rozkazy IFT .IF expression ELS .ELSE ELI .ELSEIF expression EIF .ENDIF ERT ERT 'string' | ERT expression label SET expression label EXT type label EQU expression label = expression OPT [bcfhlmorst][+-] ORG [[expression]]address[,address2] INS 'filename'[\"filename\"][*][+-value][,+-ofset[,length]] ICL 'filename'[\"filename\"] DTA [abfghltvmer](value1,value2...)[(value1,value2...)] DTA [cd]'string'[\"string\"] RUN expression INI expression END .EN SIN (centre,amp,size[,first,last]) COS (centre,amp,size[,first,last]) RND (min,max,length) :repeat BLK N one X BLK D os X BLK S parta X BLK R eloc M ain |E xtended BLK E mpty X M ain |E xtended BLK U pdate S ymbols BLK U pdate E xternal BLK U pdate A dress BLK U pdate N ew X 'string' label SMB 'string' NMB RMB LMB #expression Czyli w wi\u0119kszo\u015bci po staremu, chocia\u017c par\u0119 zmian zasz\u0142o. W przypadku cudzys\u0142ow\u00f3w mo\u017cna u\u017cywa\u0107 ' ' lub \" \". Oba rodzaje cudzys\u0142ow\u00f3w traktowane s\u0105 jednakowo z wyj\u0105tkiem adresowania (dla ' ' zostanie wyliczona warto\u015b\u0107 ATASCII znaku, dla \" \" zostanie wyliczona warto\u015b\u0107 INTERNAL znaku). BLK BLK N[one] X - blok bez nag\u0142\u00f3wk\u00f3w, licznik programu ustawiany na X BLK D[os] X - blok DOS-a z nag\u0142\u00f3wkiem $FFFF lub bez nag\u0142\u00f3wka gdy poprzedni taki sam, licznik programu ustawiany na X BLK S[parta] X - blok o sta\u0142ych adresach \u0142adowania z nag\u0142\u00f3wkiem $FFFA, licznik programu ustawiany na X BLK R[eloc] M[ain]|E[xtended] - blok relokowalny umieszczany w pami\u0119ci MAIN lub EXTENDED BLK E[mpty] X M[ain]|E[xtended] - blok relokowalny rezerwuj\u0105cy X bajt\u00f3w w pami\u0119ci MAIN lub EXTENDED UWAGA: licznik programu jest natychmiastowo zwi\u0119kszany o X bajt\u00f3w BLK U[pdate] S[ymbols] - blok aktualizuj\u0105cy w poprzednich blokach SPARTA lub RELOC adresy symboli SDX BLK U[pdate] E[xternal] - blok aktualizuj\u0105cy adresy etykiet external (nag\u0142\u00f3wek $FFEE) UWAGA: nie dotyczy Sparta DOS X, jest to rozszerzenie MADS-a BLK U[pdate] A[dress] - blok aktualizacji adres\u00f3w w blokach RELOC BLK U[pdate] N[ew] X 'string' - blok deklaruj\u0105cy nowy symbol 'string' w bloku RELOC o adresie X. Gdy nazwa symbolu poprzedzona jest znakiem @, a adres jest z pami\u0119ci podstawowej to taki symbol mo\u017ce by\u0107 wywo\u0142ywany z command.com Wi\u0119cej informacji na temat blok\u00f3w w plikach Sparta DOS X w rozdziale Budowa plik\u00f3w SPARTA DOS X oraz Programowanie SPARTA DOS X . label SET expression Pseudorozkaz SET pozwala redefiniowa\u0107 etykiet\u0119, ma podobne dzia\u0142anie jak etykiety tymczasowe zaczynaj\u0105ce si\u0119 znakiem ? , np.: temp set 12 lda #temp temp set 23 lda #temp label SMB 'string' Deklaracja etykiety jako symbolu SDX . Symbol mo\u017ce mie\u0107 maksymalnie d\u0142ugo\u015b\u0107 8-iu znak\u00f3w. Dzi\u0119ki temu po u\u017cyciu BLK UPDATE SYMBOLS asembler wygeneruje poprawny blok aktualizacji symboli. Np: pf smb 'PRINTF' jsr pf ... sprawi \u017ce po instrukcji JSR system SDX wstawi adres symbolu. UWAGA: Deklaracja ta nie jest przechodnia, to znaczy \u017ce poni\u017cszy przyk\u0142ad spowoduje b\u0142\u0119dy w czasie kompilacji: cm smb 'COMTAB' wp equ cm-1 (b\u0142\u0105d !) sta wp Zamiast tego nale\u017cy u\u017cy\u0107: cm smb 'COMTAB' sta cm-1 (ok !) UWAGA: Wszystkie deklaracje symboli nale\u017cy u\u017cy\u0107 przed deklaracjami etykiet, jak i programem w\u0142a\u015bciwym ! :repeat :4 asl @ :2 dta a(*) :256 dta #/8 ladr :4 dta l(line:1) hadr :4 dta h(line:1) Znak : okre\u015bla liczb\u0119 powt\u00f3rze\u0144 linii (w przypadku makr okre\u015bla numer parametru pod warunkiem \u017ce warto\u015b\u0107 liczbowa zapisana zosta\u0142a w systemie decymalnym). Liczba powt\u00f3rze\u0144 powinna by\u0107 z zakresu <0..2147483647> . W powtarzanej linii :repeat mo\u017cliwe jest skorzystanie z licznika p\u0119tli - znaku hash # lub z parametru :1 . Je\u015bli u\u017cyjemy znaku : w makrze w znaczeniu liczby powt\u00f3rze\u0144 linii, np.: .macro test :2 lsr @ .endm W\u00f3wczas dla w/w przyk\u0142adu znak : zostanie zinterpretowany jako drugi parametr makra. Aby zapobiec takiej interpretacji przez MADS , nale\u017cy po znaku dwukropka : umie\u015bci\u0107 znak kt\u00f3ry nic nie robi, np. znak plusa '+'. .macro test :+2 lsr @ .endm Teraz znak dwukropka : zostanie prawid\u0142owo zinterpretowany jako :repeat OPT Pseudo rozkaz OPT pozwala w\u0142\u0105cza\u0107/wy\u0142\u0105cza\u0107 dodatkowe opcje podczas asemblacji. b+ bank sensitive on b- bank sensitive off (default) c+ w\u0142\u0105cza obs\u0142ug\u0119 CPU 65816 (16bit) c- w\u0142\u0105cza obs\u0142ug\u0119 CPU 6502 (8bit) (default) f+ plik wynikowy w postaci jednego bloku (przydatne dla carta) f- plik wynikowy w postaci blokowej (default) h+ zapisuje nag\u0142\u00f3wek pliku dla DOS (default) h- nie zapisuje nag\u0142\u00f3wka pliku dla DOS l+ zapisuje listing do pliku (LST) l- nie zapisuje listingu (LST) (default) m+ zapisuje ca\u0142e makra w listingu m- zapisuje w listingu tylko t\u0105 cz\u0119\u015b\u0107 makra kt\u00f3ra zostaje wykonana (default) o+ zapisuje wynik asemblacji do pliku wynikowego (OBX) (default) o- nie zapisuje wyniku asemblacji do pliku wynikowego (OBX) r+ optymalizacja d\u0142ugo\u015bci kodu dla MVA, MVX, MVY, MWA, MWX, MWY r- bez optymalizacji d\u0142ugo\u015bci kodu dla MVA, MVX, MVY, MWA, MWX, MWY (default) s+ drukuje listing na ekranie s- nie drukuje listingu na ekranie (default) t+ track SEP REP on (CPU 65816) t- track SEP REP off (CPU 65816) (default) ?+ etykiety ze znakiem '?' na pocz\u0105tku s\u0105 lokalne (styl MAE) ?- etykiety ze znakiem '?' na pocz\u0105tku s\u0105 tymczasowe (default) OPT c+ c - l + s + OPT h- OPT o + Wszystkie opcje OPT mo\u017cemy u\u017cywa\u0107 w dowolnym miejscu listingu, czyli np. mo\u017cemy w\u0142\u0105czy\u0107 zapis listingu w linii 12, a w linii 20 wy\u0142\u0105czy\u0107 itd., w\u00f3wczas plik z listingiem b\u0119dzie zawiera\u0142 tylko linie 12..20. Je\u015bli chcemy u\u017cy\u0107 tryb\u00f3w adresowania 65816 , musimy o tym poinformowa\u0107 asembler przez OPT C+ . Je\u015bli u\u017cywamy CodeGenie lub NotePad++ mo\u017cemy u\u017cy\u0107 OPT S+ , dzi\u0119ki temu nie musimy przechodzi\u0107 do pliku z listingiem, bo listing wydrukowany zosta\u0142 w dolnym okienku (Output Bar). ORG Pseudo rozkaz ORG ustawia nowy adres asemblacji, a wi\u0119c i lokalizacj\u0119 zasemblowanych danych w pami\u0119ci RAM . adr asembluj od adresu ADR, ustaw adres w nag\u0142\u00f3wku pliku na ADR adr,adr2 asembluj od adresu ADR, ustaw adres w nag\u0142\u00f3wku pliku na ADR2 [b($ff,$fe)] zmie\u0144 nag\u0142\u00f3wek na $FFFE (zostan\u0105 wygenerowane 2 bajty) [$ff,$fe],adr zmie\u0144 nag\u0142\u00f3wek na $FFFE, ustaw adres w nag\u0142\u00f3wku pliku na ADR [$d0,$fe],adr,adr2 zmie\u0144 nag\u0142\u00f3wek na $D0FE, asembluj od adresu ADR, ustaw adres w nag\u0142\u00f3wku pliku na ADR2 [a($FFFA)],adr nag\u0142\u00f3wek SpartaDOS $FAFF, ustaw adres w nag\u0142\u00f3wku pliku na ADR opt h- ORG [a($ffff),d'atari',c'ble',20,30,40],adr,adr2 Nawiasy kwadratowe [ ] s\u0142u\u017c\u0105 okre\u015bleniu nowego nag\u0142\u00f3wka, kt\u00f3ry mo\u017ce by\u0107 dowolnej d\u0142ugo\u015bci. Pozosta\u0142e warto\u015bci za zamykaj\u0105cym nawiasem kwadratowym ] , rozdzielone znakiem przecinka , oznaczaj\u0105 odpowiednio: adres asemblacji, adres w nag\u0142\u00f3wku pliku. Przyk\u0142ad nag\u0142\u00f3wka dla pliku w postaci jednego bloku, asemblowanego od adresu $2000, w nag\u0142\u00f3wku podany adres pocz\u0105tkowy i adres ko\u0144cowy bloku. opt h-f+ ORG [a(start), a(over-1)],$2000 start nop .ds 128 nop over INS 'filename'[\"filename\"][*][+-value][,+-ofset[,length]] Pseudo rozkaz INS pozwala na do\u0142\u0105czenie dodatkowego pliku binarnego. Do\u0142\u0105czany plik nie musi znajdowa\u0107 si\u0119 w tym samym katalogu co g\u0142\u00f3wny asemblowany plik. Wystarczy, \u017ce odpowiednio wskazali\u015bmy MADS -owi \u015bcie\u017cki poszukiwa\u0144 za pomoc\u0105 prze\u0142\u0105cznika /i (patrz Prze\u0142\u0105czniki assemblera ). Dodatkowo mo\u017cna przeprowadzi\u0107 na do\u0142\u0105czanym pliku binarnym operacje: * invers bajt\u00f3w pliku binarnego +-VALUE zwi\u0119kszenie/zmniejszenie warto\u015bci bajt\u00f3w pliku binarnego o warto\u015b\u0107 wyra\u017cenia VALUE +OFSET omini\u0119cie OFSET bajt\u00f3w z pocz\u0105tku pliku binarnego (SEEK OFSET) -OFSET odczyt pliku binarnego od jego ko\u0144ca (SEEK FileLength-OFSET) LENGTH odczyt LENGTH bajt\u00f3w pliku binarnego Je\u015bli warto\u015b\u0107 LENGTH nie zosta\u0142a okre\u015blona, domy\u015blnie plik binarny zostanie odczytany a\u017c do ko\u0144ca. ICL 'filename'[\"filename\"] Pseudo rozkaz ICL pozwala na do\u0142\u0105czenie dodatkowego pliku \u017ar\u00f3d\u0142owego i jego asemblacj\u0119. Do\u0142\u0105czany plik nie musi znajdowa\u0107 si\u0119 w tym samym katalogu co g\u0142\u00f3wny asemblowany plik. Wystarczy, \u017ce odpowiednio wskazali\u015bmy MADS -owi \u015bcie\u017cki poszukiwa\u0144 za pomoc\u0105 prze\u0142\u0105cznika /i (patrz Prze\u0142\u0105czniki assemblera ). DTA Pseudo rozkaz DTA s\u0142u\u017cy do definicji danych okre\u015blonego typu. Je\u015bli typ nie zosta\u0142 okre\u015blony w\u00f3wczas domy\u015blnie zostanie ustawiony typ BYTE (b). b warto\u015b\u0107 typu BYTE a warto\u015b\u0107 typu WORD v warto\u015b\u0107 typu WORD, relokowalna l m\u0142odszy bajt warto\u015bci (BYTE) h starszy bajt warto\u015bci (BYTE) m najstarszy bajt warto\u015bci LONG (24bit) g najstarszy bajt warto\u015bci DWORD (32bit) t warto\u015b\u0107 typu LONG (24bit) e warto\u015b\u0107 typu LONG (24bit) f warto\u015b\u0107 typu DWORD (32bit) r warto\u015b\u0107 typu DWORD w odr\u00f3conej kolejno\u015bci (32 bit) c ci\u0105g znak\u00f3w ATASCII ograniczony apostrofami '' lub \"\", znak * na ko\u0144cu spowoduje invers warto\u015bci ci\u0105gu, np. dta c'abecadlo'* d ci\u0105g znak\u00f3w INTERNAL ograniczony apostrofami '' lub \"\", znak * na ko\u0144cu spowoduje invers warto\u015bci ci\u0105gu, np. dta d'abecadlo'* dta 1 , 2, 4 dta a ($2320 ,$4444) dta d'sasasa', 4,a ( 200 ), h($4000) dta c 'file' , $9b dta c'invers'* SIN (centre,amp,size[,first,last]) centre is a number which is added to every sine value amp is the sine amplitude size is the sine period first,last define range of values in the table. They are optional. Default are 0,size-1. dta a(sin(0,1000,256,0,63)) defines table of 64 words representing a quarter of sine with amplitude of 1000. COS (centre,amp,size[,first,last]) centre is a number which is added to every cosine value amp is the cosine amplitude size is the cosine period first,last define range of values in the table. They are optional. Default are 0,size-1. dta a(cos(0,1000,256,0,63)) defines table of 64 words representing a quarter of cosine with amplitude of 1000. RND (min,max,length) Ten pseudo rozkaz umo\u017cliwia wygenerowanie LENGTH losowych warto\u015bci z przedzia\u0142u . dta b(rnd(0,33,256)) IFT, ELS, ELI, EIF IFT .IF expression ELS .ELSE ELI .ELSEIF expression EIF .ENDIF W/w pseudo rozkazy i dyrektywy wp\u0142ywaj\u0105 na przebieg asemblacji (mo\u017cna ich u\u017cywa\u0107 zamiennie).","title":"Pseudo rozkazy"},{"location":"pseudo-rozkazy/#pseudo-rozkazy","text":"IFT .IF expression ELS .ELSE ELI .ELSEIF expression EIF .ENDIF ERT ERT 'string' | ERT expression label SET expression label EXT type label EQU expression label = expression OPT [bcfhlmorst][+-] ORG [[expression]]address[,address2] INS 'filename'[\"filename\"][*][+-value][,+-ofset[,length]] ICL 'filename'[\"filename\"] DTA [abfghltvmer](value1,value2...)[(value1,value2...)] DTA [cd]'string'[\"string\"] RUN expression INI expression END .EN SIN (centre,amp,size[,first,last]) COS (centre,amp,size[,first,last]) RND (min,max,length) :repeat BLK N one X BLK D os X BLK S parta X BLK R eloc M ain |E xtended BLK E mpty X M ain |E xtended BLK U pdate S ymbols BLK U pdate E xternal BLK U pdate A dress BLK U pdate N ew X 'string' label SMB 'string' NMB RMB LMB #expression Czyli w wi\u0119kszo\u015bci po staremu, chocia\u017c par\u0119 zmian zasz\u0142o. W przypadku cudzys\u0142ow\u00f3w mo\u017cna u\u017cywa\u0107 ' ' lub \" \". Oba rodzaje cudzys\u0142ow\u00f3w traktowane s\u0105 jednakowo z wyj\u0105tkiem adresowania (dla ' ' zostanie wyliczona warto\u015b\u0107 ATASCII znaku, dla \" \" zostanie wyliczona warto\u015b\u0107 INTERNAL znaku).","title":"Pseudo rozkazy"},{"location":"pseudo-rozkazy/#blk","text":"BLK N[one] X - blok bez nag\u0142\u00f3wk\u00f3w, licznik programu ustawiany na X BLK D[os] X - blok DOS-a z nag\u0142\u00f3wkiem $FFFF lub bez nag\u0142\u00f3wka gdy poprzedni taki sam, licznik programu ustawiany na X BLK S[parta] X - blok o sta\u0142ych adresach \u0142adowania z nag\u0142\u00f3wkiem $FFFA, licznik programu ustawiany na X BLK R[eloc] M[ain]|E[xtended] - blok relokowalny umieszczany w pami\u0119ci MAIN lub EXTENDED BLK E[mpty] X M[ain]|E[xtended] - blok relokowalny rezerwuj\u0105cy X bajt\u00f3w w pami\u0119ci MAIN lub EXTENDED UWAGA: licznik programu jest natychmiastowo zwi\u0119kszany o X bajt\u00f3w BLK U[pdate] S[ymbols] - blok aktualizuj\u0105cy w poprzednich blokach SPARTA lub RELOC adresy symboli SDX BLK U[pdate] E[xternal] - blok aktualizuj\u0105cy adresy etykiet external (nag\u0142\u00f3wek $FFEE) UWAGA: nie dotyczy Sparta DOS X, jest to rozszerzenie MADS-a BLK U[pdate] A[dress] - blok aktualizacji adres\u00f3w w blokach RELOC BLK U[pdate] N[ew] X 'string' - blok deklaruj\u0105cy nowy symbol 'string' w bloku RELOC o adresie X. Gdy nazwa symbolu poprzedzona jest znakiem @, a adres jest z pami\u0119ci podstawowej to taki symbol mo\u017ce by\u0107 wywo\u0142ywany z command.com Wi\u0119cej informacji na temat blok\u00f3w w plikach Sparta DOS X w rozdziale Budowa plik\u00f3w SPARTA DOS X oraz Programowanie SPARTA DOS X .","title":"BLK"},{"location":"pseudo-rozkazy/#label-set-expression","text":"Pseudorozkaz SET pozwala redefiniowa\u0107 etykiet\u0119, ma podobne dzia\u0142anie jak etykiety tymczasowe zaczynaj\u0105ce si\u0119 znakiem ? , np.: temp set 12 lda #temp temp set 23 lda #temp","title":"label SET expression"},{"location":"pseudo-rozkazy/#label-smb-string","text":"Deklaracja etykiety jako symbolu SDX . Symbol mo\u017ce mie\u0107 maksymalnie d\u0142ugo\u015b\u0107 8-iu znak\u00f3w. Dzi\u0119ki temu po u\u017cyciu BLK UPDATE SYMBOLS asembler wygeneruje poprawny blok aktualizacji symboli. Np: pf smb 'PRINTF' jsr pf ... sprawi \u017ce po instrukcji JSR system SDX wstawi adres symbolu. UWAGA: Deklaracja ta nie jest przechodnia, to znaczy \u017ce poni\u017cszy przyk\u0142ad spowoduje b\u0142\u0119dy w czasie kompilacji: cm smb 'COMTAB' wp equ cm-1 (b\u0142\u0105d !) sta wp Zamiast tego nale\u017cy u\u017cy\u0107: cm smb 'COMTAB' sta cm-1 (ok !) UWAGA: Wszystkie deklaracje symboli nale\u017cy u\u017cy\u0107 przed deklaracjami etykiet, jak i programem w\u0142a\u015bciwym !","title":"label SMB 'string'"},{"location":"pseudo-rozkazy/#repeat","text":":4 asl @ :2 dta a(*) :256 dta #/8 ladr :4 dta l(line:1) hadr :4 dta h(line:1) Znak : okre\u015bla liczb\u0119 powt\u00f3rze\u0144 linii (w przypadku makr okre\u015bla numer parametru pod warunkiem \u017ce warto\u015b\u0107 liczbowa zapisana zosta\u0142a w systemie decymalnym). Liczba powt\u00f3rze\u0144 powinna by\u0107 z zakresu <0..2147483647> . W powtarzanej linii :repeat mo\u017cliwe jest skorzystanie z licznika p\u0119tli - znaku hash # lub z parametru :1 . Je\u015bli u\u017cyjemy znaku : w makrze w znaczeniu liczby powt\u00f3rze\u0144 linii, np.: .macro test :2 lsr @ .endm W\u00f3wczas dla w/w przyk\u0142adu znak : zostanie zinterpretowany jako drugi parametr makra. Aby zapobiec takiej interpretacji przez MADS , nale\u017cy po znaku dwukropka : umie\u015bci\u0107 znak kt\u00f3ry nic nie robi, np. znak plusa '+'. .macro test :+2 lsr @ .endm Teraz znak dwukropka : zostanie prawid\u0142owo zinterpretowany jako :repeat","title":":repeat"},{"location":"pseudo-rozkazy/#opt","text":"Pseudo rozkaz OPT pozwala w\u0142\u0105cza\u0107/wy\u0142\u0105cza\u0107 dodatkowe opcje podczas asemblacji. b+ bank sensitive on b- bank sensitive off (default) c+ w\u0142\u0105cza obs\u0142ug\u0119 CPU 65816 (16bit) c- w\u0142\u0105cza obs\u0142ug\u0119 CPU 6502 (8bit) (default) f+ plik wynikowy w postaci jednego bloku (przydatne dla carta) f- plik wynikowy w postaci blokowej (default) h+ zapisuje nag\u0142\u00f3wek pliku dla DOS (default) h- nie zapisuje nag\u0142\u00f3wka pliku dla DOS l+ zapisuje listing do pliku (LST) l- nie zapisuje listingu (LST) (default) m+ zapisuje ca\u0142e makra w listingu m- zapisuje w listingu tylko t\u0105 cz\u0119\u015b\u0107 makra kt\u00f3ra zostaje wykonana (default) o+ zapisuje wynik asemblacji do pliku wynikowego (OBX) (default) o- nie zapisuje wyniku asemblacji do pliku wynikowego (OBX) r+ optymalizacja d\u0142ugo\u015bci kodu dla MVA, MVX, MVY, MWA, MWX, MWY r- bez optymalizacji d\u0142ugo\u015bci kodu dla MVA, MVX, MVY, MWA, MWX, MWY (default) s+ drukuje listing na ekranie s- nie drukuje listingu na ekranie (default) t+ track SEP REP on (CPU 65816) t- track SEP REP off (CPU 65816) (default) ?+ etykiety ze znakiem '?' na pocz\u0105tku s\u0105 lokalne (styl MAE) ?- etykiety ze znakiem '?' na pocz\u0105tku s\u0105 tymczasowe (default) OPT c+ c - l + s + OPT h- OPT o + Wszystkie opcje OPT mo\u017cemy u\u017cywa\u0107 w dowolnym miejscu listingu, czyli np. mo\u017cemy w\u0142\u0105czy\u0107 zapis listingu w linii 12, a w linii 20 wy\u0142\u0105czy\u0107 itd., w\u00f3wczas plik z listingiem b\u0119dzie zawiera\u0142 tylko linie 12..20. Je\u015bli chcemy u\u017cy\u0107 tryb\u00f3w adresowania 65816 , musimy o tym poinformowa\u0107 asembler przez OPT C+ . Je\u015bli u\u017cywamy CodeGenie lub NotePad++ mo\u017cemy u\u017cy\u0107 OPT S+ , dzi\u0119ki temu nie musimy przechodzi\u0107 do pliku z listingiem, bo listing wydrukowany zosta\u0142 w dolnym okienku (Output Bar).","title":"OPT"},{"location":"pseudo-rozkazy/#org","text":"Pseudo rozkaz ORG ustawia nowy adres asemblacji, a wi\u0119c i lokalizacj\u0119 zasemblowanych danych w pami\u0119ci RAM . adr asembluj od adresu ADR, ustaw adres w nag\u0142\u00f3wku pliku na ADR adr,adr2 asembluj od adresu ADR, ustaw adres w nag\u0142\u00f3wku pliku na ADR2 [b($ff,$fe)] zmie\u0144 nag\u0142\u00f3wek na $FFFE (zostan\u0105 wygenerowane 2 bajty) [$ff,$fe],adr zmie\u0144 nag\u0142\u00f3wek na $FFFE, ustaw adres w nag\u0142\u00f3wku pliku na ADR [$d0,$fe],adr,adr2 zmie\u0144 nag\u0142\u00f3wek na $D0FE, asembluj od adresu ADR, ustaw adres w nag\u0142\u00f3wku pliku na ADR2 [a($FFFA)],adr nag\u0142\u00f3wek SpartaDOS $FAFF, ustaw adres w nag\u0142\u00f3wku pliku na ADR opt h- ORG [a($ffff),d'atari',c'ble',20,30,40],adr,adr2 Nawiasy kwadratowe [ ] s\u0142u\u017c\u0105 okre\u015bleniu nowego nag\u0142\u00f3wka, kt\u00f3ry mo\u017ce by\u0107 dowolnej d\u0142ugo\u015bci. Pozosta\u0142e warto\u015bci za zamykaj\u0105cym nawiasem kwadratowym ] , rozdzielone znakiem przecinka , oznaczaj\u0105 odpowiednio: adres asemblacji, adres w nag\u0142\u00f3wku pliku. Przyk\u0142ad nag\u0142\u00f3wka dla pliku w postaci jednego bloku, asemblowanego od adresu $2000, w nag\u0142\u00f3wku podany adres pocz\u0105tkowy i adres ko\u0144cowy bloku. opt h-f+ ORG [a(start), a(over-1)],$2000 start nop .ds 128 nop over","title":"ORG"},{"location":"pseudo-rozkazy/#ins-filenamefilename-value-ofsetlength","text":"Pseudo rozkaz INS pozwala na do\u0142\u0105czenie dodatkowego pliku binarnego. Do\u0142\u0105czany plik nie musi znajdowa\u0107 si\u0119 w tym samym katalogu co g\u0142\u00f3wny asemblowany plik. Wystarczy, \u017ce odpowiednio wskazali\u015bmy MADS -owi \u015bcie\u017cki poszukiwa\u0144 za pomoc\u0105 prze\u0142\u0105cznika /i (patrz Prze\u0142\u0105czniki assemblera ). Dodatkowo mo\u017cna przeprowadzi\u0107 na do\u0142\u0105czanym pliku binarnym operacje: * invers bajt\u00f3w pliku binarnego +-VALUE zwi\u0119kszenie/zmniejszenie warto\u015bci bajt\u00f3w pliku binarnego o warto\u015b\u0107 wyra\u017cenia VALUE +OFSET omini\u0119cie OFSET bajt\u00f3w z pocz\u0105tku pliku binarnego (SEEK OFSET) -OFSET odczyt pliku binarnego od jego ko\u0144ca (SEEK FileLength-OFSET) LENGTH odczyt LENGTH bajt\u00f3w pliku binarnego Je\u015bli warto\u015b\u0107 LENGTH nie zosta\u0142a okre\u015blona, domy\u015blnie plik binarny zostanie odczytany a\u017c do ko\u0144ca.","title":"INS 'filename'[\"filename\"][*][+-value][,+-ofset[,length]]"},{"location":"pseudo-rozkazy/#icl-filenamefilename","text":"Pseudo rozkaz ICL pozwala na do\u0142\u0105czenie dodatkowego pliku \u017ar\u00f3d\u0142owego i jego asemblacj\u0119. Do\u0142\u0105czany plik nie musi znajdowa\u0107 si\u0119 w tym samym katalogu co g\u0142\u00f3wny asemblowany plik. Wystarczy, \u017ce odpowiednio wskazali\u015bmy MADS -owi \u015bcie\u017cki poszukiwa\u0144 za pomoc\u0105 prze\u0142\u0105cznika /i (patrz Prze\u0142\u0105czniki assemblera ).","title":"ICL 'filename'[\"filename\"]"},{"location":"pseudo-rozkazy/#dta","text":"Pseudo rozkaz DTA s\u0142u\u017cy do definicji danych okre\u015blonego typu. Je\u015bli typ nie zosta\u0142 okre\u015blony w\u00f3wczas domy\u015blnie zostanie ustawiony typ BYTE (b). b warto\u015b\u0107 typu BYTE a warto\u015b\u0107 typu WORD v warto\u015b\u0107 typu WORD, relokowalna l m\u0142odszy bajt warto\u015bci (BYTE) h starszy bajt warto\u015bci (BYTE) m najstarszy bajt warto\u015bci LONG (24bit) g najstarszy bajt warto\u015bci DWORD (32bit) t warto\u015b\u0107 typu LONG (24bit) e warto\u015b\u0107 typu LONG (24bit) f warto\u015b\u0107 typu DWORD (32bit) r warto\u015b\u0107 typu DWORD w odr\u00f3conej kolejno\u015bci (32 bit) c ci\u0105g znak\u00f3w ATASCII ograniczony apostrofami '' lub \"\", znak * na ko\u0144cu spowoduje invers warto\u015bci ci\u0105gu, np. dta c'abecadlo'* d ci\u0105g znak\u00f3w INTERNAL ograniczony apostrofami '' lub \"\", znak * na ko\u0144cu spowoduje invers warto\u015bci ci\u0105gu, np. dta d'abecadlo'* dta 1 , 2, 4 dta a ($2320 ,$4444) dta d'sasasa', 4,a ( 200 ), h($4000) dta c 'file' , $9b dta c'invers'*","title":"DTA"},{"location":"pseudo-rozkazy/#sin-centreampsizefirstlast","text":"centre is a number which is added to every sine value amp is the sine amplitude size is the sine period first,last define range of values in the table. They are optional. Default are 0,size-1. dta a(sin(0,1000,256,0,63)) defines table of 64 words representing a quarter of sine with amplitude of 1000.","title":"SIN (centre,amp,size[,first,last])"},{"location":"pseudo-rozkazy/#cos-centreampsizefirstlast","text":"centre is a number which is added to every cosine value amp is the cosine amplitude size is the cosine period first,last define range of values in the table. They are optional. Default are 0,size-1. dta a(cos(0,1000,256,0,63)) defines table of 64 words representing a quarter of cosine with amplitude of 1000.","title":"COS (centre,amp,size[,first,last])"},{"location":"pseudo-rozkazy/#rnd-minmaxlength","text":"Ten pseudo rozkaz umo\u017cliwia wygenerowanie LENGTH losowych warto\u015bci z przedzia\u0142u . dta b(rnd(0,33,256))","title":"RND (min,max,length)"},{"location":"pseudo-rozkazy/#ift-els-eli-eif","text":"IFT .IF expression ELS .ELSE ELI .ELSEIF expression EIF .ENDIF W/w pseudo rozkazy i dyrektywy wp\u0142ywaj\u0105 na przebieg asemblacji (mo\u017cna ich u\u017cywa\u0107 zamiennie).","title":"IFT, ELS, ELI, EIF"},{"location":"skladnia/","text":"Komentarze Znaki komentarza jednoliniowego powinni\u015bmy poprzedza\u0107 znakiem ; lub * . Do oznaczania komentarza jednoliniowego najbezpieczniej jest jednak u\u017cywa\u0107 \u015brednika ; poniewa\u017c znak * ma te\u017c inne znaczenia, mo\u017ce oznacza\u0107 operacj\u0119 mno\u017cenia, czy te\u017c aktualny adres podczas asemblacji. \u015arednik natomiast dedykowany jest tylko i wy\u0142\u0105cznie do oznaczania komentarzy. Do oznaczenia komentarza jednoliniowego mo\u017cliwe jest te\u017c u\u017cycie znak\u00f3w // , a dla wieloliniowego znak\u00f3w /* */ . * to jest komentarz ; to jest komentarz lda #0 ; to jest komentarz dta 1 , 3 * B\u0141\u0118DNY KOMENTARZ, ZOSTANIE \u0179LE ZINTERPRETOWANY org $2000 + 1 B\u0141\u0118DNY KOMENTARZ, ZOSTANIE \u0179LE ZINTERPRETOWANY nop // to jest komentarz // to jest komentarz dta 1,2, /* komentarz */ 3,4 lda /* komentarz */ #0 /* ... to jest komentarz wieloliniowy ... */ /************************************* to tez jest komentarz wieloliniowy **************************************/ Znaki oznaczaj\u0105ce komentarz wieloliniowy /* */ i znaki oznaczaj\u0105ce komentarz jednoliniowy // mo\u017cna stosowa\u0107 bez ogranicze\u0144. \u0141\u0105czenie wierszy Dowoln\u0105 ilo\u015b\u0107 wierszy listingu mo\u017cemy po\u0142\u0105czy\u0107 (rozdzieli\u0107) w jeden wiersz u\u017cywaj\u0105c znaku \\ , np.: lda 20\\ cmp 20\\ beq *-2 lda 20 \\ cmp 20 \\ beq *-2 lda #0 \\lop sta $a000,y \\ iny \\ bne lop ; komentarz tylko na ko\u0144cu takiego wiersza Je\u015bli po znaku \\ nie umie\u015bcimy znaku spacji, w\u00f3wczas mnemonik czy inny ci\u0105g znakowy mo\u017ce zosta\u0107 zinterpretowany jako etykieta, nale\u017cy pami\u0119ta\u0107 \u017ce znak \\ oznacza pocz\u0105tek nowej linii. MADS ko\u0144czy przetwarza\u0107 taki wiersz, a\u017c do napotkania komentarza lub napotkania ko\u0144ca ci\u0105gu znakowego, dlatego komentarze mo\u017cemy umieszcza\u0107 tylko na ko\u0144cu takiego wielo-wiersza. UWAGA: Umieszczenie znaku \\ na ko\u0144cu wiersza oznacza dla MADS ch\u0119\u0107 kontynuowania aktualnego wiersza od nast\u0119pnego wiersza, np.: lda\\ #\\ 12 Dla w/w przyk\u0142adu otrzymamy rozkaz LDA #12 . \u0141\u0105czenie mnemonik\u00f3w Mo\u017cliwo\u015b\u0107 \u0142\u0105czenia dw\u00f3ch mnemonik\u00f3w za pomoc\u0105 znaku dwukropka : znana jest ju\u017c z XASM . W MADS ta mo\u017cliwo\u015b\u0107 zosta\u0142a rozszerzona o \u0142\u0105czenie dowolnej liczby znanych MADS mnemonik\u00f3w, np.: lda:cmp:req 20 lda:iny:sta:iny $600,y Wyra\u017cenia Termin wyra\u017cenie oznacza sekwencj\u0119 operator\u00f3w i operand\u00f3w (argument\u00f3w), kt\u00f3ra okre\u015bla operacje, tj. rodzaj i kolejno\u015b\u0107 oblicze\u0144. Wyra\u017ceniem z\u0142o\u017conym nazywa si\u0119 takie wyra\u017cenie, w kt\u00f3rym wyst\u0119puje dwa lub wi\u0119cej operator\u00f3w. Operatory, kt\u00f3re oddzia\u0142ywuj\u0105 tylko na jeden operand, nazywa si\u0119 jednoargumentowymi (unarnymi). Operatory dwuargumentowe nazywa si\u0119 binarnymi. Warto\u015bciowanie wyra\u017cenia przebiega w porz\u0105dku, okre\u015blonym pierwsze\u0144stwem operator\u00f3w i w kierunku, okre\u015blonym przez kierunek wi\u0105zania operator\u00f3w. Liczby MADS akceptuje zapis liczb w formacie decymalnym, hexadecymalnym, binarnym oraz w kodach ATASCII i INTERNAL . zapis decymalny -100 -2437325 1743 zapis hexadecymalny $100 $e430 $000001 0x12 0xa000 0xaabbccdd zapis binarny %0001001010 %000000001 %001000 zapis kodami ATASCII: 'a' 'fds' 'W'* zapis kodami INTERNAL: \"B\" \"FDSFSD\" \".\"* Tylko pierwszy znak ci\u0105gu ATASCII , INTERNAL jest znacz\u0105cy. Znak * za apostrofem zamykaj\u0105cym powoduje invers znaku. Dodatkowo mo\u017cliwe s\u0105 jeszcze dwie operacje + - dla ci\u0105g\u00f3w znakowych, kt\u00f3re powoduj\u0105 zwi\u0119kszenie/zmniejszenie kod\u00f3w znak\u00f3w ograniczonych apostrofami. \"FDttrteSFSD\"-12 'FDSFdsldksla'+2 Operatory binarne + Addition - Subtraction * Multiplication / Division % Remainder & Bitwise and | Bitwise or ^ Bitwise xor << Arithmetic shift left >> Arithmetic shift right = Equal == Equal (same as =) <> Not equal != Not equal (same as <>) < Less than > Greater than <= Less or equal >= Greater or equal && Logical and || Logical or jednoargumentowe + Plus (does nothing) - Minus (changes sign) ~ Bitwise not (complements all bits) ! Logical not (changes true to false and vice versa) < Low (extracts low byte) > High (extracts high byte) ^ High 24bit (extracts high byte) = Extracts memory bank : Extracts global variable value kolejno\u015b\u0107 wykonywania first [] (brackets) + - ~ < > (unary) * / % & << >> (binary) + - | ^ (binary) = == <> != < > <= >= (binary) ! (unary) && (binary) last || (binary)","title":"Sk\u0142adnia"},{"location":"skladnia/#_1","text":"","title":""},{"location":"skladnia/#komentarze","text":"Znaki komentarza jednoliniowego powinni\u015bmy poprzedza\u0107 znakiem ; lub * . Do oznaczania komentarza jednoliniowego najbezpieczniej jest jednak u\u017cywa\u0107 \u015brednika ; poniewa\u017c znak * ma te\u017c inne znaczenia, mo\u017ce oznacza\u0107 operacj\u0119 mno\u017cenia, czy te\u017c aktualny adres podczas asemblacji. \u015arednik natomiast dedykowany jest tylko i wy\u0142\u0105cznie do oznaczania komentarzy. Do oznaczenia komentarza jednoliniowego mo\u017cliwe jest te\u017c u\u017cycie znak\u00f3w // , a dla wieloliniowego znak\u00f3w /* */ . * to jest komentarz ; to jest komentarz lda #0 ; to jest komentarz dta 1 , 3 * B\u0141\u0118DNY KOMENTARZ, ZOSTANIE \u0179LE ZINTERPRETOWANY org $2000 + 1 B\u0141\u0118DNY KOMENTARZ, ZOSTANIE \u0179LE ZINTERPRETOWANY nop // to jest komentarz // to jest komentarz dta 1,2, /* komentarz */ 3,4 lda /* komentarz */ #0 /* ... to jest komentarz wieloliniowy ... */ /************************************* to tez jest komentarz wieloliniowy **************************************/ Znaki oznaczaj\u0105ce komentarz wieloliniowy /* */ i znaki oznaczaj\u0105ce komentarz jednoliniowy // mo\u017cna stosowa\u0107 bez ogranicze\u0144.","title":"Komentarze"},{"location":"skladnia/#aczenie-wierszy","text":"Dowoln\u0105 ilo\u015b\u0107 wierszy listingu mo\u017cemy po\u0142\u0105czy\u0107 (rozdzieli\u0107) w jeden wiersz u\u017cywaj\u0105c znaku \\ , np.: lda 20\\ cmp 20\\ beq *-2 lda 20 \\ cmp 20 \\ beq *-2 lda #0 \\lop sta $a000,y \\ iny \\ bne lop ; komentarz tylko na ko\u0144cu takiego wiersza Je\u015bli po znaku \\ nie umie\u015bcimy znaku spacji, w\u00f3wczas mnemonik czy inny ci\u0105g znakowy mo\u017ce zosta\u0107 zinterpretowany jako etykieta, nale\u017cy pami\u0119ta\u0107 \u017ce znak \\ oznacza pocz\u0105tek nowej linii. MADS ko\u0144czy przetwarza\u0107 taki wiersz, a\u017c do napotkania komentarza lub napotkania ko\u0144ca ci\u0105gu znakowego, dlatego komentarze mo\u017cemy umieszcza\u0107 tylko na ko\u0144cu takiego wielo-wiersza. UWAGA: Umieszczenie znaku \\ na ko\u0144cu wiersza oznacza dla MADS ch\u0119\u0107 kontynuowania aktualnego wiersza od nast\u0119pnego wiersza, np.: lda\\ #\\ 12 Dla w/w przyk\u0142adu otrzymamy rozkaz LDA #12 .","title":"\u0141\u0105czenie wierszy"},{"location":"skladnia/#aczenie-mnemonikow","text":"Mo\u017cliwo\u015b\u0107 \u0142\u0105czenia dw\u00f3ch mnemonik\u00f3w za pomoc\u0105 znaku dwukropka : znana jest ju\u017c z XASM . W MADS ta mo\u017cliwo\u015b\u0107 zosta\u0142a rozszerzona o \u0142\u0105czenie dowolnej liczby znanych MADS mnemonik\u00f3w, np.: lda:cmp:req 20 lda:iny:sta:iny $600,y","title":"\u0141\u0105czenie mnemonik\u00f3w"},{"location":"skladnia/#wyrazenia","text":"Termin wyra\u017cenie oznacza sekwencj\u0119 operator\u00f3w i operand\u00f3w (argument\u00f3w), kt\u00f3ra okre\u015bla operacje, tj. rodzaj i kolejno\u015b\u0107 oblicze\u0144. Wyra\u017ceniem z\u0142o\u017conym nazywa si\u0119 takie wyra\u017cenie, w kt\u00f3rym wyst\u0119puje dwa lub wi\u0119cej operator\u00f3w. Operatory, kt\u00f3re oddzia\u0142ywuj\u0105 tylko na jeden operand, nazywa si\u0119 jednoargumentowymi (unarnymi). Operatory dwuargumentowe nazywa si\u0119 binarnymi. Warto\u015bciowanie wyra\u017cenia przebiega w porz\u0105dku, okre\u015blonym pierwsze\u0144stwem operator\u00f3w i w kierunku, okre\u015blonym przez kierunek wi\u0105zania operator\u00f3w.","title":"Wyra\u017cenia"},{"location":"skladnia/#liczby","text":"MADS akceptuje zapis liczb w formacie decymalnym, hexadecymalnym, binarnym oraz w kodach ATASCII i INTERNAL .","title":"Liczby"},{"location":"skladnia/#zapis-decymalny","text":"-100 -2437325 1743","title":"zapis decymalny"},{"location":"skladnia/#zapis-hexadecymalny","text":"$100 $e430 $000001 0x12 0xa000 0xaabbccdd","title":"zapis hexadecymalny"},{"location":"skladnia/#zapis-binarny","text":"%0001001010 %000000001 %001000","title":"zapis binarny"},{"location":"skladnia/#zapis-kodami-atascii","text":"'a' 'fds' 'W'*","title":"zapis kodami ATASCII:"},{"location":"skladnia/#zapis-kodami-internal","text":"\"B\" \"FDSFSD\" \".\"* Tylko pierwszy znak ci\u0105gu ATASCII , INTERNAL jest znacz\u0105cy. Znak * za apostrofem zamykaj\u0105cym powoduje invers znaku. Dodatkowo mo\u017cliwe s\u0105 jeszcze dwie operacje + - dla ci\u0105g\u00f3w znakowych, kt\u00f3re powoduj\u0105 zwi\u0119kszenie/zmniejszenie kod\u00f3w znak\u00f3w ograniczonych apostrofami. \"FDttrteSFSD\"-12 'FDSFdsldksla'+2","title":"zapis kodami INTERNAL:"},{"location":"skladnia/#operatory","text":"","title":"Operatory"},{"location":"skladnia/#binarne","text":"+ Addition - Subtraction * Multiplication / Division % Remainder & Bitwise and | Bitwise or ^ Bitwise xor << Arithmetic shift left >> Arithmetic shift right = Equal == Equal (same as =) <> Not equal != Not equal (same as <>) < Less than > Greater than <= Less or equal >= Greater or equal && Logical and || Logical or","title":"binarne"},{"location":"skladnia/#jednoargumentowe","text":"+ Plus (does nothing) - Minus (changes sign) ~ Bitwise not (complements all bits) ! Logical not (changes true to false and vice versa) < Low (extracts low byte) > High (extracts high byte) ^ High 24bit (extracts high byte) = Extracts memory bank : Extracts global variable value","title":"jednoargumentowe"},{"location":"skladnia/#kolejnosc-wykonywania","text":"first [] (brackets) + - ~ < > (unary) * / % & << >> (binary) + - | ^ (binary) = == <> != < > <= >= (binary) ! (unary) && (binary) last || (binary)","title":"kolejno\u015b\u0107 wykonywania"},{"location":"sparta-dos/","text":"Budowa plik\u00f3w Przedruk z Serious Magazine , autor: Qcyk/Dial . Plik sam w sobie jest tylko niewiele wartym zbiorem bajt\u00f3w. Mn\u00f3stwo liczb, kt\u00f3re mog\u0105 oznacza\u0107 wszystko, a zarazem nic, je\u015bli nie wiadomo jak je zinterpretowa\u0107. Wi\u0119kszo\u015b\u0107 plik\u00f3w wyposa\u017ca si\u0119 z tego powodu w r\u00f3\u017cnorodne nag\u0142\u00f3wki, w kt\u00f3rych pami\u0119tane s\u0105 informacje o tym co plik zawiera, ew. jak go potem traktowa\u0107 przy odczycie. Do takich nale\u017c\u0105 r\u00f3wnie\u017c pliki wykonywalne, binarne, czy po prostu: przeznaczone do za\u0142adowania z poziomu DOS , wszak DOS to te\u017c program i jak ka\u017cdy inny ma prawo oczekiwa\u0107 danych o okre\u015blonej, znanej mu strukturze. Tradycyjne pliki binarne, rozpoznawane przez wszystkie DOS'y dla komputer\u00f3w Atari XL/XE , maj\u0105 budow\u0119 blokow\u0105, gdzie ka\u017cdy blok posiada sw\u00f3j nag\u0142\u00f3wek. Istniej\u0105 dwa rodzaje nag\u0142\u00f3wk\u00f3w: dta a($ffff),a(str_adr),a(end_adr) dta a(str_adr),a(end_adr) str_adr - adres, pod kt\u00f3ry zostanie za\u0142adowany pierwszy bajt danych end_adr - adres, pod kt\u00f3ry zostanie za\u0142adowany ostatni bajt Pierwszy blok w pliku musi mie\u0107 nag\u0142\u00f3wek typu $ffff , pozosta\u0142e bloki dowolnie. Za nag\u0142\u00f3wkiem oczywi\u015bcie powinny znale\u017a\u0107 si\u0119 dane w ilo\u015bci: (end_adr-str_adr)+1 Tyle tytu\u0142em przypomnienia. Tw\u00f3rcy systemu Sparta DOS X zachowali powy\u017cszy standard, dodaj\u0105c jednocze\u015bnie kilka nowych typ\u00f3w nag\u0142\u00f3wk\u00f3w. Ci\u0105gle wi\u0119c mamy do czynienia z plikiem podzielonym na bloki, z tym \u017ce rodzaj\u00f3w blok\u00f3w jest teraz du\u017co wi\u0119cej. Oto one: Blok nierelokowalny dta a($fffa),a(str_adr),a(end_adr) Blok nierelokowalny (\u0142adowany pod sta\u0142y adres w pami\u0119ci). Jest to to samo co blok $ffff - nie ma znaczenia, kt\u00f3ry zostanie u\u017cyty. $fffa b\u0119dzie jednak wyra\u017anie wskazywa\u0107, \u017ce program jest przeznaczony dla SDX - inny DOS takiego pliku nie odczyta. Blok relokowalny dta a($fffe),b(blk_num),b(blk_id) dta a(blk_off),a(blk_len) Blok relokowalny (\u0142adowany pod MEMLO we wskazany rodzaj pami\u0119ci). blk_num Numer bloku w pliku. Ka\u017cdy blok relokowalny powinien posiada\u0107 sw\u00f3j w\u0142asny numer. Poniewa\u017c adresy \u0142adowania blok\u00f3w nie s\u0105 znane, bloki identyfikowane s\u0105 w\u0142a\u015bnie poprzez swoje numery. Mog\u0105 one przyjmowa\u0107 warto\u015bci z zakresu 0-7 , z tym \u017ce w praktyce stosuje si\u0119 zwykle numeracj\u0119 od 1 w g\u00f3r\u0119. blk_id Bity 1-5 stanowi\u0105 indeks pami\u0119ci, do kt\u00f3rej blok ma zosta\u0107 za\u0142adowany. Spotka\u0142em si\u0119 z dwoma warto\u015bciami: $00 - pami\u0119\u0107 podstawowa $02 - pami\u0119\u0107 rozszerzona Ustawienie dodatkowo bitu 7 oznacza brak bloku danych. SDX nic wtedy nie \u0142aduje, ale rezerwuje pami\u0119\u0107. blk_off Tzw. przesuni\u0119cie adres\u00f3w w bloku, czyli po prostu adres, pod kt\u00f3ry by\u0142 assemblowany kod. Jest to potrzebne przy uaktualnianiu adres\u00f3w odwo\u0142uj\u0105cych si\u0119 do zawarto\u015bci bloku. blk_len D\u0142ugo\u015b\u0107 bloku. Tyle danych powinno by\u0107 za nag\u0142\u00f3wkiem chyba, \u017ce jest to blok rezerwuj\u0105cy pami\u0119\u0107 wtedy danych nie ma. Pisz\u0105c kod relokowalny trzeba mie\u0107 na uwadze kilka ogranicze\u0144 jakie narzuca idea przemieszczalnego kodu. Wszystkie adresy odwo\u0142uj\u0105ce si\u0119 do obszaru takiego programu musz\u0105 zosta\u0107 uaktualnione podczas \u0142adowania, w zwi\u0105zku z tym nie mo\u017cna u\u017cywa\u0107 sekwencji takich jak np.: lda co\u015b ... co\u015b equ * ... Zamiast tego, pozostaje np.: lda _co\u015b ldx _co\u015b+1 ... _co\u015b dta a(co\u015b) ... co\u015b equ * Blok aktualizacji (relokacja) dta a($fffd),b(blk_num),a(blk_len) Blok aktualizacji adres\u00f3w odnosz\u0105cych si\u0119 do bloku relokowalnego blk_num Numer bloku, do kt\u00f3rego odnosz\u0105 si\u0119 uaktualniane adresy. blk_len D\u0142ugo\u015b\u0107 bloku aktualizacji (bez nag\u0142\u00f3wka). Jest ona ignorowana. Adresy s\u0105 uaktualniane poprzez dodanie do adresu istniej\u0105cego r\u00f3\u017cnicy pomi\u0119dzy adresem, pod kt\u00f3ry zosta\u0142 za\u0142adowany wskazany blok relokowalny, a warto\u015bci\u0105 blk_off (adresem asemblacji) tego bloku. Mo\u017cna to przedstawi\u0107 wzorem: ADR=ADR+(blk_adr-blk_off) Cia\u0142o bloku aktualizacji stanowi\u0105 wska\u017aniki do poprawianych adres\u00f3w oraz rozkazy specjalne. Wska\u017anik jest liczb\u0105 z zakresu $00-$fb i oznacza przesuni\u0119cie wzgl\u0119dem miejsca poprzedniej aktualizacji. Miejsce to jest pami\u0119tane przez program \u0142aduj\u0105cy jako bezpo\u015bredni adres, nazwijmy go licznikiem aktualizacji. Licznik ten mo\u017cna zainicjowa\u0107 za pomoc\u0105 funkcji specjalnych, kt\u00f3rymi s\u0105 liczby wi\u0119ksze od $fb : $fc oznacza koniec bloku aktualizacji, $fd,a(ADDR) nast\u0119puje aktualizacja adresu wskazanego bezpo\u015brednio przez ADDR . Tym samym warto\u015b\u0107 ADDR jest wpisywana do licznika aktualizacji i od niej b\u0119d\u0105 liczone kolejne przesuni\u0119cia, $fe,b(blk_num) do licznika aktualizacji wstawiany jest adres bloku wskazanego przez blk_num , czyli kolejne aktualizacje b\u0119d\u0105 si\u0119 odnosi\u0142y do kodu zawartego w tym bloku, $ff licznik aktualizacji zwi\u0119kszany jest o $fa (bez aktualizacji adresu). Blok aktualizacji (symbole) dta a($fffb),c'SMB_NAME',a(blk_len) Blok aktualizacji adres\u00f3w procedur zdefiniowanych symbolami. MB_NAME Symboliczna nazwa procedury (lub tablicy, rejestru systemowego itp.) Osiem znak\u00f3w w kodzie ATASCII blk_len Jak w bloku $fffd . Po nag\u0142\u00f3wku wyst\u0119puje ci\u0105g wska\u017anik\u00f3w okre\u015blaj\u0105cych po\u0142o\u017cenie adres\u00f3w do zaktualizowania - identycznie jak w bloku $fffd . Adresy s\u0105 zmieniane poprzez dodanie do istniej\u0105cego adresu, adresu procedury okre\u015blonej symbolem. Pozwala to na wykorzystywanie w programach procedur, kt\u00f3rych adres\u00f3w nie znamy, np. procedur dodawanych przez inne programy uruchamiane w \u015brodowisku SDX. Tak\u017ce procedury systemowe powinny by\u0107 wykorzystywane w ten spos\u00f3b, przecie\u017c mog\u0105 one mie\u0107 r\u00f3\u017cne adresy w r\u00f3\u017cnych wersjach Sparty . Blok definicji dta a($fffc),b(blk_num),a(smb_off) dta c'SMB_NAME' Blok definicji nowych symboli. blk_num Numer bloku, w kt\u00f3rym znajduje si\u0119 definiowana procedura. Wynika z tego, \u017ce procedura musi by\u0107 za\u0142adowana jako blok relokowalny. smb_off Przesuni\u0119cie adresu procedury w bloku, czyli offset procedury wzgl\u0119dem pocz\u0105tku bloku (pierwszy bajt ma numer 0) powi\u0119kszony o warto\u015b\u0107 blk_off tego bloku. Inaczej jest to adres pod jaki procedura zosta\u0142a zassemblowana, SMB_NAME - symboliczna nazwa definiowanej procedury. Bloki typu $fffb $fffc $fffd nie s\u0105 na sta\u0142e zatrzymywane w pami\u0119ci. System wykorzystuje je tylko podczas \u0142adowania programu. Programowanie Sk\u0142adnia dotycz\u0105ca obs\u0142ugi Sparta DOS X , zaczerpni\u0119ta zosta\u0142a z FastAssembler autorstwa Marka Goderskiego , poni\u017cej cytat z instrukcji do\u0142\u0105czonej do FA . Pliki \u017ar\u00f3d\u0142owe *.FAS mo\u017cna obecnie bez wi\u0119kszych problem\u00f3w asemblowa\u0107 za pomoc\u0105 MADS . Rozkazy relokowalne maj\u0105 zawsze 2 bajtowy argument, nie ma mo\u017cliwo\u015bci relokowania 3 bajtowych argument\u00f3w ( 65816 ). Najwa\u017cniejsz\u0105 nowo\u015bci\u0105 w SDX dla programisty jest mo\u017cliwo\u015b\u0107 prostego pisania program\u00f3w relokowalnych. Poniewa\u017c procesor MOS 6502 nie posiada adresowania wzgl\u0119dnego, (pr\u00f3cz kr\u00f3tkich skok\u00f3w warunkowych) programi\u015bci z ICD zastosowali specjalne mechanizmy \u0142adowania blok\u00f3w programu. Ca\u0142y proces polega na za\u0142adowaniu bloku, a nast\u0119pnie specjalnego bloku aktualizacji adres\u00f3w. Wszystkie adresy w bloku programu s\u0105 liczone od zera. Wystarczy wi\u0119c doda\u0107 do nich warto\u015b\u0107 memlo aby otrzyma\u0107 adres w\u0142a\u015bciwy. Kt\u00f3re adresy zwi\u0119kszy\u0107, a kt\u00f3re pozostawi\u0107? W\u0142a\u015bnie po to jest specjalny blok aktualizacji kt\u00f3ry zawiera wska\u017aniki (specjalnie kodowane) do tych\u017ce adres\u00f3w. Tak wi\u0119c po bloku lub blokach RELOC obowi\u0105zkowe jest wykonanie UPDATE ADRESS dla poprawnego dzia\u0142ania programu. R\u00f3wnie\u017c po blokach SPARTA w kt\u00f3rych rozkazy (lub wektory) odwo\u0142uj\u0105 si\u0119 do blok\u00f3w RELOC lub EMPTY obowi\u0105zkowe jest wykonanie UPDATE ADRESS . Nast\u0119pn\u0105 innowacj\u0105 jest wprowadzenie symboli. Ot\u00f3\u017c niekt\u00f3re procedury us\u0142ugowe SDX zosta\u0142y zdefiniowane za pomoc\u0105 nazw! Nazwy te maja zawsze 8 liter (podobnie jak nazwy plik\u00f3w). Zamiast korzysta\u0107 z tablic wektor\u00f3w lub skok\u00f3w (jak w OS ) korzystamy z symboli definiowanych SMB . Po wczytaniu bloku lub blok\u00f3w programu SDX \u0142aduje blok aktualizacji symboli i w podobny spos\u00f3b jak przy blokach relokowalnych zamienia adresy w programie. Symbole mog\u0105 by\u0107 u\u017cywane dla blok\u00f3w RELOC i SPARTA . Programista mo\u017ce zdefiniowa\u0107 w\u0142asne symbole zast\u0119puj\u0105ce SDX lub zupe\u0142nie nowe dla wykorzystania przez inne programy. Robi si\u0119 to poprzez blok UPDATE NEW . Trzeba jednak wiedzie\u0107 \u017ce nowy symbol musi by\u0107 zawarty w bloku RELOC . Liczba blok\u00f3w RELOC i EMPTY jest ograniczona do 7 przez SDX . Bloki takie mo\u017cna \u0142\u0105czy\u0107 w \u0142a\u0144cuchy np: blk sparta $600 ... blk reloc main ... blk empty $100 main ... blk reloc extended ... blk empty $200 extended Oznacza to \u017ce rozkazy w tych blokach mog\u0105 odwo\u0142ywa\u0107 si\u0119 do wszystkich blok\u00f3w w \u0142a\u0144cuchu. \u0141a\u0144cuch taki nie jest przerywany przez aktualizacj\u0119 adres\u00f3w, lub symboli ale jest niszczony przez definicj\u0119 nowego symbolu, oraz inne bloki, np.: dos . UWAGI : \u0141a\u0144cuch taki ma sens tylko wtedy gdy wszystkie jego bloki \u0142aduj\u0105 si\u0119 do tej samej pami\u0119ci, lub gdy program przy odpowiednich odwo\u0142aniach prze\u0142\u0105cza pami\u0119\u0107. Rozkazy i wektory w blokach RELOC i EMPTY nie powinny odwo\u0142ywa\u0107 si\u0119 do blok\u00f3w SPARTA ! Mo\u017ce to spowodowa\u0107 b\u0142\u0105d gdy u\u017cytkownik za\u0142aduje program komend\u0105 LOAD , a u\u017cyje go po d\u0142u\u017cszym czasie. O ile bloki RELOC i EMPTY by\u0142y bezpieczne to nigdy nie wiadomo co jest w pami\u0119ci tam gdzie ostatnio by\u0142 blok SPARTA ! R\u00f3wnie niebezpieczne jest u\u017cywanie odwo\u0142a\u0144 do blok\u00f3w RELOC i EMPTY przez bloki SPARTA (pow\u00f3d jak wy\u017cej), jednak\u017ce podczas instalowania nak\u0142adek *.sys z u\u017cyciem INSTALL jest to czasem niezb\u0119dne, st\u0105d jest dopuszczalne. Mo\u017cna tak\u017ce inicjowa\u0107 blok SPARTA - porzez $2E2 - b\u0119dzie on wtedy zawsze uruchomiony, a potem ju\u017c zb\u0119dny. Pomi\u0119dzy blokami SPARTA , a RELOC i EMPTY mo\u017ce doj\u015b\u0107 do kolizji adres\u00f3w! FA rozpoznaje odwo\u0142ania do innych blok\u00f3w poprzez adresy, przyjmuj\u0105c PC dla RELOC i EMPTY od $1000 , tak wi\u0119c gdy mieszamy te bloki nale\u017cy mie\u0107 pewno\u015b\u0107 ze SPARTA le\u017cy poni\u017cej $1000 (np.: $600 ) lub powy\u017cej ostatniego bloku relokowalnego, zazwyczaj wystarcza $4000 . B\u0142\u0105d taki nie jest przez kompilator wykrywany!","title":"Sparta DOS X"},{"location":"sparta-dos/#_1","text":"","title":""},{"location":"sparta-dos/#budowa-plikow","text":"Przedruk z Serious Magazine , autor: Qcyk/Dial . Plik sam w sobie jest tylko niewiele wartym zbiorem bajt\u00f3w. Mn\u00f3stwo liczb, kt\u00f3re mog\u0105 oznacza\u0107 wszystko, a zarazem nic, je\u015bli nie wiadomo jak je zinterpretowa\u0107. Wi\u0119kszo\u015b\u0107 plik\u00f3w wyposa\u017ca si\u0119 z tego powodu w r\u00f3\u017cnorodne nag\u0142\u00f3wki, w kt\u00f3rych pami\u0119tane s\u0105 informacje o tym co plik zawiera, ew. jak go potem traktowa\u0107 przy odczycie. Do takich nale\u017c\u0105 r\u00f3wnie\u017c pliki wykonywalne, binarne, czy po prostu: przeznaczone do za\u0142adowania z poziomu DOS , wszak DOS to te\u017c program i jak ka\u017cdy inny ma prawo oczekiwa\u0107 danych o okre\u015blonej, znanej mu strukturze. Tradycyjne pliki binarne, rozpoznawane przez wszystkie DOS'y dla komputer\u00f3w Atari XL/XE , maj\u0105 budow\u0119 blokow\u0105, gdzie ka\u017cdy blok posiada sw\u00f3j nag\u0142\u00f3wek. Istniej\u0105 dwa rodzaje nag\u0142\u00f3wk\u00f3w: dta a($ffff),a(str_adr),a(end_adr) dta a(str_adr),a(end_adr) str_adr - adres, pod kt\u00f3ry zostanie za\u0142adowany pierwszy bajt danych end_adr - adres, pod kt\u00f3ry zostanie za\u0142adowany ostatni bajt Pierwszy blok w pliku musi mie\u0107 nag\u0142\u00f3wek typu $ffff , pozosta\u0142e bloki dowolnie. Za nag\u0142\u00f3wkiem oczywi\u015bcie powinny znale\u017a\u0107 si\u0119 dane w ilo\u015bci: (end_adr-str_adr)+1 Tyle tytu\u0142em przypomnienia. Tw\u00f3rcy systemu Sparta DOS X zachowali powy\u017cszy standard, dodaj\u0105c jednocze\u015bnie kilka nowych typ\u00f3w nag\u0142\u00f3wk\u00f3w. Ci\u0105gle wi\u0119c mamy do czynienia z plikiem podzielonym na bloki, z tym \u017ce rodzaj\u00f3w blok\u00f3w jest teraz du\u017co wi\u0119cej. Oto one:","title":"Budowa plik\u00f3w"},{"location":"sparta-dos/#blok-nierelokowalny","text":"dta a($fffa),a(str_adr),a(end_adr) Blok nierelokowalny (\u0142adowany pod sta\u0142y adres w pami\u0119ci). Jest to to samo co blok $ffff - nie ma znaczenia, kt\u00f3ry zostanie u\u017cyty. $fffa b\u0119dzie jednak wyra\u017anie wskazywa\u0107, \u017ce program jest przeznaczony dla SDX - inny DOS takiego pliku nie odczyta.","title":"Blok nierelokowalny"},{"location":"sparta-dos/#blok-relokowalny","text":"dta a($fffe),b(blk_num),b(blk_id) dta a(blk_off),a(blk_len) Blok relokowalny (\u0142adowany pod MEMLO we wskazany rodzaj pami\u0119ci).","title":"Blok relokowalny"},{"location":"sparta-dos/#blk_num","text":"Numer bloku w pliku. Ka\u017cdy blok relokowalny powinien posiada\u0107 sw\u00f3j w\u0142asny numer. Poniewa\u017c adresy \u0142adowania blok\u00f3w nie s\u0105 znane, bloki identyfikowane s\u0105 w\u0142a\u015bnie poprzez swoje numery. Mog\u0105 one przyjmowa\u0107 warto\u015bci z zakresu 0-7 , z tym \u017ce w praktyce stosuje si\u0119 zwykle numeracj\u0119 od 1 w g\u00f3r\u0119.","title":"blk_num"},{"location":"sparta-dos/#blk_id","text":"Bity 1-5 stanowi\u0105 indeks pami\u0119ci, do kt\u00f3rej blok ma zosta\u0107 za\u0142adowany. Spotka\u0142em si\u0119 z dwoma warto\u015bciami: $00 - pami\u0119\u0107 podstawowa $02 - pami\u0119\u0107 rozszerzona Ustawienie dodatkowo bitu 7 oznacza brak bloku danych. SDX nic wtedy nie \u0142aduje, ale rezerwuje pami\u0119\u0107.","title":"blk_id"},{"location":"sparta-dos/#blk_off","text":"Tzw. przesuni\u0119cie adres\u00f3w w bloku, czyli po prostu adres, pod kt\u00f3ry by\u0142 assemblowany kod. Jest to potrzebne przy uaktualnianiu adres\u00f3w odwo\u0142uj\u0105cych si\u0119 do zawarto\u015bci bloku.","title":"blk_off"},{"location":"sparta-dos/#blk_len","text":"D\u0142ugo\u015b\u0107 bloku. Tyle danych powinno by\u0107 za nag\u0142\u00f3wkiem chyba, \u017ce jest to blok rezerwuj\u0105cy pami\u0119\u0107 wtedy danych nie ma. Pisz\u0105c kod relokowalny trzeba mie\u0107 na uwadze kilka ogranicze\u0144 jakie narzuca idea przemieszczalnego kodu. Wszystkie adresy odwo\u0142uj\u0105ce si\u0119 do obszaru takiego programu musz\u0105 zosta\u0107 uaktualnione podczas \u0142adowania, w zwi\u0105zku z tym nie mo\u017cna u\u017cywa\u0107 sekwencji takich jak np.: lda co\u015b ... co\u015b equ * ... Zamiast tego, pozostaje np.: lda _co\u015b ldx _co\u015b+1 ... _co\u015b dta a(co\u015b) ... co\u015b equ *","title":"blk_len"},{"location":"sparta-dos/#blok-aktualizacji-relokacja","text":"dta a($fffd),b(blk_num),a(blk_len) Blok aktualizacji adres\u00f3w odnosz\u0105cych si\u0119 do bloku relokowalnego","title":"Blok aktualizacji (relokacja)"},{"location":"sparta-dos/#blk_num_1","text":"Numer bloku, do kt\u00f3rego odnosz\u0105 si\u0119 uaktualniane adresy.","title":"blk_num"},{"location":"sparta-dos/#blk_len_1","text":"D\u0142ugo\u015b\u0107 bloku aktualizacji (bez nag\u0142\u00f3wka). Jest ona ignorowana. Adresy s\u0105 uaktualniane poprzez dodanie do adresu istniej\u0105cego r\u00f3\u017cnicy pomi\u0119dzy adresem, pod kt\u00f3ry zosta\u0142 za\u0142adowany wskazany blok relokowalny, a warto\u015bci\u0105 blk_off (adresem asemblacji) tego bloku. Mo\u017cna to przedstawi\u0107 wzorem: ADR=ADR+(blk_adr-blk_off) Cia\u0142o bloku aktualizacji stanowi\u0105 wska\u017aniki do poprawianych adres\u00f3w oraz rozkazy specjalne. Wska\u017anik jest liczb\u0105 z zakresu $00-$fb i oznacza przesuni\u0119cie wzgl\u0119dem miejsca poprzedniej aktualizacji. Miejsce to jest pami\u0119tane przez program \u0142aduj\u0105cy jako bezpo\u015bredni adres, nazwijmy go licznikiem aktualizacji. Licznik ten mo\u017cna zainicjowa\u0107 za pomoc\u0105 funkcji specjalnych, kt\u00f3rymi s\u0105 liczby wi\u0119ksze od $fb : $fc oznacza koniec bloku aktualizacji, $fd,a(ADDR) nast\u0119puje aktualizacja adresu wskazanego bezpo\u015brednio przez ADDR . Tym samym warto\u015b\u0107 ADDR jest wpisywana do licznika aktualizacji i od niej b\u0119d\u0105 liczone kolejne przesuni\u0119cia, $fe,b(blk_num) do licznika aktualizacji wstawiany jest adres bloku wskazanego przez blk_num , czyli kolejne aktualizacje b\u0119d\u0105 si\u0119 odnosi\u0142y do kodu zawartego w tym bloku, $ff licznik aktualizacji zwi\u0119kszany jest o $fa (bez aktualizacji adresu).","title":"blk_len"},{"location":"sparta-dos/#blok-aktualizacji-symbole","text":"dta a($fffb),c'SMB_NAME',a(blk_len) Blok aktualizacji adres\u00f3w procedur zdefiniowanych symbolami.","title":"Blok aktualizacji (symbole)"},{"location":"sparta-dos/#mb_name","text":"Symboliczna nazwa procedury (lub tablicy, rejestru systemowego itp.) Osiem znak\u00f3w w kodzie ATASCII","title":"MB_NAME"},{"location":"sparta-dos/#blk_len_2","text":"Jak w bloku $fffd . Po nag\u0142\u00f3wku wyst\u0119puje ci\u0105g wska\u017anik\u00f3w okre\u015blaj\u0105cych po\u0142o\u017cenie adres\u00f3w do zaktualizowania - identycznie jak w bloku $fffd . Adresy s\u0105 zmieniane poprzez dodanie do istniej\u0105cego adresu, adresu procedury okre\u015blonej symbolem. Pozwala to na wykorzystywanie w programach procedur, kt\u00f3rych adres\u00f3w nie znamy, np. procedur dodawanych przez inne programy uruchamiane w \u015brodowisku SDX. Tak\u017ce procedury systemowe powinny by\u0107 wykorzystywane w ten spos\u00f3b, przecie\u017c mog\u0105 one mie\u0107 r\u00f3\u017cne adresy w r\u00f3\u017cnych wersjach Sparty .","title":"blk_len"},{"location":"sparta-dos/#blok-definicji","text":"dta a($fffc),b(blk_num),a(smb_off) dta c'SMB_NAME' Blok definicji nowych symboli.","title":"Blok definicji"},{"location":"sparta-dos/#blk_num_2","text":"Numer bloku, w kt\u00f3rym znajduje si\u0119 definiowana procedura. Wynika z tego, \u017ce procedura musi by\u0107 za\u0142adowana jako blok relokowalny.","title":"blk_num"},{"location":"sparta-dos/#smb_off","text":"Przesuni\u0119cie adresu procedury w bloku, czyli offset procedury wzgl\u0119dem pocz\u0105tku bloku (pierwszy bajt ma numer 0) powi\u0119kszony o warto\u015b\u0107 blk_off tego bloku. Inaczej jest to adres pod jaki procedura zosta\u0142a zassemblowana, SMB_NAME - symboliczna nazwa definiowanej procedury. Bloki typu $fffb $fffc $fffd nie s\u0105 na sta\u0142e zatrzymywane w pami\u0119ci. System wykorzystuje je tylko podczas \u0142adowania programu.","title":"smb_off"},{"location":"sparta-dos/#programowanie","text":"Sk\u0142adnia dotycz\u0105ca obs\u0142ugi Sparta DOS X , zaczerpni\u0119ta zosta\u0142a z FastAssembler autorstwa Marka Goderskiego , poni\u017cej cytat z instrukcji do\u0142\u0105czonej do FA . Pliki \u017ar\u00f3d\u0142owe *.FAS mo\u017cna obecnie bez wi\u0119kszych problem\u00f3w asemblowa\u0107 za pomoc\u0105 MADS . Rozkazy relokowalne maj\u0105 zawsze 2 bajtowy argument, nie ma mo\u017cliwo\u015bci relokowania 3 bajtowych argument\u00f3w ( 65816 ). Najwa\u017cniejsz\u0105 nowo\u015bci\u0105 w SDX dla programisty jest mo\u017cliwo\u015b\u0107 prostego pisania program\u00f3w relokowalnych. Poniewa\u017c procesor MOS 6502 nie posiada adresowania wzgl\u0119dnego, (pr\u00f3cz kr\u00f3tkich skok\u00f3w warunkowych) programi\u015bci z ICD zastosowali specjalne mechanizmy \u0142adowania blok\u00f3w programu. Ca\u0142y proces polega na za\u0142adowaniu bloku, a nast\u0119pnie specjalnego bloku aktualizacji adres\u00f3w. Wszystkie adresy w bloku programu s\u0105 liczone od zera. Wystarczy wi\u0119c doda\u0107 do nich warto\u015b\u0107 memlo aby otrzyma\u0107 adres w\u0142a\u015bciwy. Kt\u00f3re adresy zwi\u0119kszy\u0107, a kt\u00f3re pozostawi\u0107? W\u0142a\u015bnie po to jest specjalny blok aktualizacji kt\u00f3ry zawiera wska\u017aniki (specjalnie kodowane) do tych\u017ce adres\u00f3w. Tak wi\u0119c po bloku lub blokach RELOC obowi\u0105zkowe jest wykonanie UPDATE ADRESS dla poprawnego dzia\u0142ania programu. R\u00f3wnie\u017c po blokach SPARTA w kt\u00f3rych rozkazy (lub wektory) odwo\u0142uj\u0105 si\u0119 do blok\u00f3w RELOC lub EMPTY obowi\u0105zkowe jest wykonanie UPDATE ADRESS . Nast\u0119pn\u0105 innowacj\u0105 jest wprowadzenie symboli. Ot\u00f3\u017c niekt\u00f3re procedury us\u0142ugowe SDX zosta\u0142y zdefiniowane za pomoc\u0105 nazw! Nazwy te maja zawsze 8 liter (podobnie jak nazwy plik\u00f3w). Zamiast korzysta\u0107 z tablic wektor\u00f3w lub skok\u00f3w (jak w OS ) korzystamy z symboli definiowanych SMB . Po wczytaniu bloku lub blok\u00f3w programu SDX \u0142aduje blok aktualizacji symboli i w podobny spos\u00f3b jak przy blokach relokowalnych zamienia adresy w programie. Symbole mog\u0105 by\u0107 u\u017cywane dla blok\u00f3w RELOC i SPARTA . Programista mo\u017ce zdefiniowa\u0107 w\u0142asne symbole zast\u0119puj\u0105ce SDX lub zupe\u0142nie nowe dla wykorzystania przez inne programy. Robi si\u0119 to poprzez blok UPDATE NEW . Trzeba jednak wiedzie\u0107 \u017ce nowy symbol musi by\u0107 zawarty w bloku RELOC . Liczba blok\u00f3w RELOC i EMPTY jest ograniczona do 7 przez SDX . Bloki takie mo\u017cna \u0142\u0105czy\u0107 w \u0142a\u0144cuchy np: blk sparta $600 ... blk reloc main ... blk empty $100 main ... blk reloc extended ... blk empty $200 extended Oznacza to \u017ce rozkazy w tych blokach mog\u0105 odwo\u0142ywa\u0107 si\u0119 do wszystkich blok\u00f3w w \u0142a\u0144cuchu. \u0141a\u0144cuch taki nie jest przerywany przez aktualizacj\u0119 adres\u00f3w, lub symboli ale jest niszczony przez definicj\u0119 nowego symbolu, oraz inne bloki, np.: dos . UWAGI : \u0141a\u0144cuch taki ma sens tylko wtedy gdy wszystkie jego bloki \u0142aduj\u0105 si\u0119 do tej samej pami\u0119ci, lub gdy program przy odpowiednich odwo\u0142aniach prze\u0142\u0105cza pami\u0119\u0107. Rozkazy i wektory w blokach RELOC i EMPTY nie powinny odwo\u0142ywa\u0107 si\u0119 do blok\u00f3w SPARTA ! Mo\u017ce to spowodowa\u0107 b\u0142\u0105d gdy u\u017cytkownik za\u0142aduje program komend\u0105 LOAD , a u\u017cyje go po d\u0142u\u017cszym czasie. O ile bloki RELOC i EMPTY by\u0142y bezpieczne to nigdy nie wiadomo co jest w pami\u0119ci tam gdzie ostatnio by\u0142 blok SPARTA ! R\u00f3wnie niebezpieczne jest u\u017cywanie odwo\u0142a\u0144 do blok\u00f3w RELOC i EMPTY przez bloki SPARTA (pow\u00f3d jak wy\u017cej), jednak\u017ce podczas instalowania nak\u0142adek *.sys z u\u017cyciem INSTALL jest to czasem niezb\u0119dne, st\u0105d jest dopuszczalne. Mo\u017cna tak\u017ce inicjowa\u0107 blok SPARTA - porzez $2E2 - b\u0119dzie on wtedy zawsze uruchomiony, a potem ju\u017c zb\u0119dny. Pomi\u0119dzy blokami SPARTA , a RELOC i EMPTY mo\u017ce doj\u015b\u0107 do kolizji adres\u00f3w! FA rozpoznaje odwo\u0142ania do innych blok\u00f3w poprzez adresy, przyjmuj\u0105c PC dla RELOC i EMPTY od $1000 , tak wi\u0119c gdy mieszamy te bloki nale\u017cy mie\u0107 pewno\u015b\u0107 ze SPARTA le\u017cy poni\u017cej $1000 (np.: $600 ) lub powy\u017cej ostatniego bloku relokowalnego, zazwyczaj wystarcza $4000 . B\u0142\u0105d taki nie jest przez kompilator wykrywany!","title":"Programowanie"},{"location":"sposob-uzycia/","text":"Prze\u0142\u0105czniki assemblera Syntax: mads source [switches] -b:address Generate binary file at specific address -c Label case sensitivity -d:label=value Define a label -f CPU command at first column -fv:value Set raw binary fill byte to [value] -hc[:filename] Header file for CC65 -hm[:filename] Header file for MADS -i:path Additional include directories -l[:filename] Generate listing -m:filename File with macro definition -ml:value margin-left property -o:filename Set object file name -p Print fully qualified file names in listing and error messages -s Silent mode -t[:filename] List label table -u Warn of unused labels -vu Verify code inside unreferenced procedures -x Exclude unreferenced procedures Domy\u015blne nazwy plik\u00f3w to: source.lst source.obx source.lab source.h source.hea source.mac Je\u015bli nie podamy rozszerzenia dla pliku source, w\u00f3wczas MADS domy\u015blnie przyjmie rozszerzenie .ASM . Parametry mo\u017cemy podawa\u0107 w dowolnej kolejno\u015bci uprzednio poprzedzaj\u0105c je znakiem / lub - , wielko\u015b\u0107 liter nie ma znaczenia. Parametry mo\u017cemy \u0142\u0105czy\u0107 ze sob\u0105, np.: mads -lptd:label=value -d:label2=value source.asm mads -l -p -t source mads source.asm -lpt mads.exe \"%1\" -ltpi:\"d:\\!atari\\macro\\\" mads -i:\"c:\\atari\\macros\\\" -c source.asm -lpt Domy\u015blnie MADS po asemblacji zapisze plik z rozszerzeniem .OBX , mo\u017cemy to zmieni\u0107 z poziomu BAT : mads \"%1\" -o:%~n1.xex Wi\u0119cej na temat operator\u00f3w mo\u017cemy dowiedzie\u0107 si\u0119 wykonuj\u0105c CALL /? z poziomu Microsoft DOS . b:address U\u017cycie prze\u0142\u0105cznika -b pozwala nada\u0107 nowy adres asemblacji dla pliku w kt\u00f3rym nie okre\u015blono adresu asemblacji (adres asemblacji okre\u015blamy przy pomocy pseudo rozkazu ORG ). c U\u017cycie prze\u0142\u0105cznika -c spowoduje rozr\u00f3\u017cnianie wielko\u015bci liter w nazwach etykiet, zmiennych, sta\u0142ych. Dyrektywy assemblera i rozkazy CPU 6502 , 65816 s\u0105 zawsze rozpoznawane bez wzgl\u0119du na wielko\u015b\u0107 liter. d:label=value U\u017cycie prze\u0142\u0105cznika -d pozwala na wprowadzenie nowej etykiety do pami\u0119ci MADS z poziomu linii polece\u0144. Prze\u0142\u0105cznika mo\u017cna u\u017cy\u0107 wielokrotnie podczas jednego wywo\u0142ania MADS , mo\u017ce by\u0107 przydatny gdy asemblujemy z u\u017cyciem plik\u00f3w wsadowych BAT . f U\u017cycie prze\u0142\u0105cznika -f umo\u017cliwia umieszczanie rozkaz\u00f3w CPU od pierwszej kolumny wiersza i ich poprawne rozpoznawanie przez asembler jako rozkazy a nie tylko jako etykiety. fv:value U\u017cycie prze\u0142\u0105cznika -fv:value pozwala ustali\u0107 warto\u015b\u0107 wype\u0142nienia pami\u0119ci gdy u\u017cyjemy OPT F+ hc[:filename] Prze\u0142\u0105cznik -hc w\u0142\u0105cza zapis pliku z nag\u0142\u00f3wkami dla kompilatora CC65 . Pozwala tak\u017ce okre\u015bli\u0107 now\u0105 nazw\u0119 dla takiego pliku. Domy\u015blna nazwa pliku nag\u0142\u00f3wkowego dla CC65 to *.H hm[:filename] Prze\u0142\u0105cznik -hm w\u0142\u0105cza zapis pliku z nag\u0142\u00f3wkami dla MADS . Pozwala tak\u017ce okre\u015bli\u0107 now\u0105 nazw\u0119 dla takiego pliku. Domy\u015blna nazwa pliku nag\u0142\u00f3wkowego dla MADS to *.HEA . Plik taki zawiera informacje o bankach przypisanych etykietom i ich warto\u015bci. Dodatkowo etykiety posortowane zostaj\u0105 wg typu CONSTANS VARIABLES PROCEDURES . i:path Prze\u0142\u0105cznik -i s\u0142u\u017cy do okre\u015blenia \u015bcie\u017cek poszukiwa\u0144 dla operacji ICL oraz INS . Prze\u0142\u0105cznika mo\u017cna u\u017cy\u0107 wielokrotnie podczas jednego wywo\u0142ania MADS-a, np.: -i:\"c:\\program files\" -i:c:\\temp -i:\"d:\\atari project\" l:filename Prze\u0142\u0105cznik -l w\u0142\u0105cza zapis pliku z listingiem. Pozwala tak\u017ce okre\u015bli\u0107 now\u0105 nazw\u0119 dla takiego pliku. m:filename Prze\u0142\u0105cznik -m s\u0142u\u017cy do okre\u015blenia pliku z deklaracjami makr. W przypadku jego u\u017cycia MADS asembluje taki plik przed g\u0142\u00f3wnym plikiem .ASM o:filename Prze\u0142\u0105cznik -o pozwala okre\u015bli\u0107 now\u0105 nazw\u0119 pliku wykonywalnego Atari DOS lub Atari Sparta DOS X , kt\u00f3ry powstanie po procesie asemblacji. p Prze\u0142\u0105cznik -p pomocny jest w po\u0142\u0105czeniu z Code Genie . Gdy wyst\u0105pi b\u0142\u0105d podczas asemblacji, w oknie Output Bar edytora Code Genie pojawi si\u0119 stosowny komunikat wygenerowany przez MADS , np.: D:\\!Delphi\\Masm\\test.asm (29) ERROR: Missing .PROC Teraz wystarczy klikn\u0105\u0107 dwukrotnie lini\u0119 z tym komunikatem, a kursor edytora ustawi si\u0119 w linii z b\u0142\u0119dem. s U\u017cycie prze\u0142\u0105cznika -s spowoduje uaktywnienie tzw. trybu pracy Silent mode , czyli \u017cadne komunikaty nie zostan\u0105 wy\u015bwietlone, co najwy\u017cej komunikaty b\u0142\u0119d\u00f3w ERROR i ostrze\u017cenia WARNING . t[:filename] Prze\u0142\u0105cznik -t w\u0142\u0105cza zapis pliku z u\u017cytymi definicjami etykiet. Pozwala tak\u017ce okre\u015bli\u0107 now\u0105 nazw\u0119 dla takiego pliku. x Prze\u0142\u0105cznik -x pozwala na pomini\u0119cie w procesie asemblacji procedur zadeklarowanych dyrektyw\u0105 .PROC , do kt\u00f3rych nie nast\u0105pi\u0142o odwo\u0142anie w programie. vu Prze\u0142\u0105cznik -vu wymusza dodatkowy test kodu w blokach .PROC mimo tego \u017ce taki blok .PROC nie zostanie zapisany do pliku wynikowego, najcz\u0119\u015bciej przydaje si\u0119 gdy u\u017cywamy prze\u0142\u0105cznika -x u Prze\u0142\u0105cznik -u wy\u015bwietli etykiety kt\u00f3re nie zosta\u0142y u\u017cyte w programie. Kody wyj\u015bcia 3 = bad parameters, assembling not started 2 = error occured 0 = no errors Komunikaty ostrze\u017cenia nie powoduj\u0105 zmiany warto\u015bci kodu wyj\u015bcia. Struktura pliku LST Format listingu nie odbiega od tego znanego z XASM , jedyn\u0105 zmian\u0105 jest dodanie przed adresem, numeru wirtualnego banku pami\u0119ci (pod warunkiem \u017ce numer banku <> 0 ). 3 4 = 01,9033 obraz equ $9033 5 = 01,00A0 scr1 equ $a0 6 7 8 01,2000 EA main nop Struktura pliku LAB Podobnie jak w przypadku XASM , w pliku *.LAB przechowywane s\u0105 informacje na temat etykiet kt\u00f3re wyst\u0105pi\u0142y w programie. W sumie s\u0105 to trzy kolumny: Pierwsza kolumna to numer wirtualnego banku przypisany do etykiety (je\u015bli bank <> 0 ) Druga kolumna to warto\u015b\u0107 etykiety. Trzecia kolumna to nazwa etykiety. Numery wirtualnych bank\u00f3w przypisane do etykiety o warto\u015bciach >= $FFF9 maj\u0105 specjalne znaczenie: $FFF9 etykieta parametru procedury zdefiniowanej przez dyrektyw\u0119 .PROC $FFFA etykieta tablicy zdefiniowanej przez dyrektyw\u0119 .ARRAY $FFFB etykieta danych strukturalnych zdefiniowanej przez pseudo rozkaz DTA STRUCT_LABEL $FFFC etykieta symbolu Sparta DOS X - SMB $FFFD etykieta makra zdefiniowanego przez dyrektyw\u0119 .MACRO $FFFE etykieta struktury zdefiniowanej przez dyrektyw\u0119 .STRUCT $FFFF etykieta procedury zdefiniowanej przez dyrektyw\u0119 .PROC Specjalne znaczenie w nazwach etykiet maj\u0105 znaki: etykieta zdefiniowana w makrze (dwa dwukropki) :: znak kropki . rozdziela nazw\u0119 struktury .MACRO .PROC .LOCAL .STRUCT od nazwy pola w strukturze Warto\u015b\u0107 liczbowa, kt\u00f3ra wyst\u0119puje po :: oznacza numer wywo\u0142ania makra. Mad-Assembler v1.4.2beta by TeBe/Madteam Label table: 00 0400 @STACK_ADDRESS 00 00FF @STACK_POINTER 00 2000 MAIN 00 2019 LOOP 00 201C LOOP::1 00 201C LHEX 00 0080 LHEX.HLP 00 204C LHEX.THEX 00 205C HEX 00 205C HEX.@GETPAR0.LOOP 00 2079 HEX.@GETPAR1.LOOP Struktura pliku H Nie jestem pewien czy wszystko z tym plikiem jest OK, ale Eru chcia\u0142 \u017ceby co\u015b takiego by\u0142o wi\u0119c jest :) Ma on by\u0107 pomocny przy \u0142\u0105czeniu ASM z CC65 , czyli portem C dla ma\u0142ego Atari . Jego zawarto\u015b\u0107 mo\u017ce wygl\u0105da\u0107 tak, przyk\u0142adowy plik TEST.ASM : #ifndef _TEST_ASM_H_ #define _TEST_ASM_H_ #define TEST_CPU65816 0x200F #define TEST_CPU6502 0x2017 #define TEST_TEXT6502 0x201F #define TEST_TEXT65816 0x2024 #endif","title":"Spos\u00f3b u\u017cycia"},{"location":"sposob-uzycia/#_1","text":"","title":""},{"location":"sposob-uzycia/#przeaczniki-assemblera","text":"Syntax: mads source [switches] -b:address Generate binary file at specific address -c Label case sensitivity -d:label=value Define a label -f CPU command at first column -fv:value Set raw binary fill byte to [value] -hc[:filename] Header file for CC65 -hm[:filename] Header file for MADS -i:path Additional include directories -l[:filename] Generate listing -m:filename File with macro definition -ml:value margin-left property -o:filename Set object file name -p Print fully qualified file names in listing and error messages -s Silent mode -t[:filename] List label table -u Warn of unused labels -vu Verify code inside unreferenced procedures -x Exclude unreferenced procedures Domy\u015blne nazwy plik\u00f3w to: source.lst source.obx source.lab source.h source.hea source.mac Je\u015bli nie podamy rozszerzenia dla pliku source, w\u00f3wczas MADS domy\u015blnie przyjmie rozszerzenie .ASM . Parametry mo\u017cemy podawa\u0107 w dowolnej kolejno\u015bci uprzednio poprzedzaj\u0105c je znakiem / lub - , wielko\u015b\u0107 liter nie ma znaczenia. Parametry mo\u017cemy \u0142\u0105czy\u0107 ze sob\u0105, np.: mads -lptd:label=value -d:label2=value source.asm mads -l -p -t source mads source.asm -lpt mads.exe \"%1\" -ltpi:\"d:\\!atari\\macro\\\" mads -i:\"c:\\atari\\macros\\\" -c source.asm -lpt Domy\u015blnie MADS po asemblacji zapisze plik z rozszerzeniem .OBX , mo\u017cemy to zmieni\u0107 z poziomu BAT : mads \"%1\" -o:%~n1.xex Wi\u0119cej na temat operator\u00f3w mo\u017cemy dowiedzie\u0107 si\u0119 wykonuj\u0105c CALL /? z poziomu Microsoft DOS .","title":"Prze\u0142\u0105czniki assemblera"},{"location":"sposob-uzycia/#baddress","text":"U\u017cycie prze\u0142\u0105cznika -b pozwala nada\u0107 nowy adres asemblacji dla pliku w kt\u00f3rym nie okre\u015blono adresu asemblacji (adres asemblacji okre\u015blamy przy pomocy pseudo rozkazu ORG ).","title":"b:address"},{"location":"sposob-uzycia/#c","text":"U\u017cycie prze\u0142\u0105cznika -c spowoduje rozr\u00f3\u017cnianie wielko\u015bci liter w nazwach etykiet, zmiennych, sta\u0142ych. Dyrektywy assemblera i rozkazy CPU 6502 , 65816 s\u0105 zawsze rozpoznawane bez wzgl\u0119du na wielko\u015b\u0107 liter.","title":"c"},{"location":"sposob-uzycia/#dlabelvalue","text":"U\u017cycie prze\u0142\u0105cznika -d pozwala na wprowadzenie nowej etykiety do pami\u0119ci MADS z poziomu linii polece\u0144. Prze\u0142\u0105cznika mo\u017cna u\u017cy\u0107 wielokrotnie podczas jednego wywo\u0142ania MADS , mo\u017ce by\u0107 przydatny gdy asemblujemy z u\u017cyciem plik\u00f3w wsadowych BAT .","title":"d:label=value"},{"location":"sposob-uzycia/#f","text":"U\u017cycie prze\u0142\u0105cznika -f umo\u017cliwia umieszczanie rozkaz\u00f3w CPU od pierwszej kolumny wiersza i ich poprawne rozpoznawanie przez asembler jako rozkazy a nie tylko jako etykiety.","title":"f"},{"location":"sposob-uzycia/#fvvalue","text":"U\u017cycie prze\u0142\u0105cznika -fv:value pozwala ustali\u0107 warto\u015b\u0107 wype\u0142nienia pami\u0119ci gdy u\u017cyjemy OPT F+","title":"fv:value"},{"location":"sposob-uzycia/#hcfilename","text":"Prze\u0142\u0105cznik -hc w\u0142\u0105cza zapis pliku z nag\u0142\u00f3wkami dla kompilatora CC65 . Pozwala tak\u017ce okre\u015bli\u0107 now\u0105 nazw\u0119 dla takiego pliku. Domy\u015blna nazwa pliku nag\u0142\u00f3wkowego dla CC65 to *.H","title":"hc[:filename]"},{"location":"sposob-uzycia/#hmfilename","text":"Prze\u0142\u0105cznik -hm w\u0142\u0105cza zapis pliku z nag\u0142\u00f3wkami dla MADS . Pozwala tak\u017ce okre\u015bli\u0107 now\u0105 nazw\u0119 dla takiego pliku. Domy\u015blna nazwa pliku nag\u0142\u00f3wkowego dla MADS to *.HEA . Plik taki zawiera informacje o bankach przypisanych etykietom i ich warto\u015bci. Dodatkowo etykiety posortowane zostaj\u0105 wg typu CONSTANS VARIABLES PROCEDURES .","title":"hm[:filename]"},{"location":"sposob-uzycia/#ipath","text":"Prze\u0142\u0105cznik -i s\u0142u\u017cy do okre\u015blenia \u015bcie\u017cek poszukiwa\u0144 dla operacji ICL oraz INS . Prze\u0142\u0105cznika mo\u017cna u\u017cy\u0107 wielokrotnie podczas jednego wywo\u0142ania MADS-a, np.: -i:\"c:\\program files\" -i:c:\\temp -i:\"d:\\atari project\"","title":"i:path"},{"location":"sposob-uzycia/#lfilename","text":"Prze\u0142\u0105cznik -l w\u0142\u0105cza zapis pliku z listingiem. Pozwala tak\u017ce okre\u015bli\u0107 now\u0105 nazw\u0119 dla takiego pliku.","title":"l:filename"},{"location":"sposob-uzycia/#mfilename","text":"Prze\u0142\u0105cznik -m s\u0142u\u017cy do okre\u015blenia pliku z deklaracjami makr. W przypadku jego u\u017cycia MADS asembluje taki plik przed g\u0142\u00f3wnym plikiem .ASM","title":"m:filename"},{"location":"sposob-uzycia/#ofilename","text":"Prze\u0142\u0105cznik -o pozwala okre\u015bli\u0107 now\u0105 nazw\u0119 pliku wykonywalnego Atari DOS lub Atari Sparta DOS X , kt\u00f3ry powstanie po procesie asemblacji.","title":"o:filename"},{"location":"sposob-uzycia/#p","text":"Prze\u0142\u0105cznik -p pomocny jest w po\u0142\u0105czeniu z Code Genie . Gdy wyst\u0105pi b\u0142\u0105d podczas asemblacji, w oknie Output Bar edytora Code Genie pojawi si\u0119 stosowny komunikat wygenerowany przez MADS , np.: D:\\!Delphi\\Masm\\test.asm (29) ERROR: Missing .PROC Teraz wystarczy klikn\u0105\u0107 dwukrotnie lini\u0119 z tym komunikatem, a kursor edytora ustawi si\u0119 w linii z b\u0142\u0119dem.","title":"p"},{"location":"sposob-uzycia/#s","text":"U\u017cycie prze\u0142\u0105cznika -s spowoduje uaktywnienie tzw. trybu pracy Silent mode , czyli \u017cadne komunikaty nie zostan\u0105 wy\u015bwietlone, co najwy\u017cej komunikaty b\u0142\u0119d\u00f3w ERROR i ostrze\u017cenia WARNING .","title":"s"},{"location":"sposob-uzycia/#tfilename","text":"Prze\u0142\u0105cznik -t w\u0142\u0105cza zapis pliku z u\u017cytymi definicjami etykiet. Pozwala tak\u017ce okre\u015bli\u0107 now\u0105 nazw\u0119 dla takiego pliku.","title":"t[:filename]"},{"location":"sposob-uzycia/#x","text":"Prze\u0142\u0105cznik -x pozwala na pomini\u0119cie w procesie asemblacji procedur zadeklarowanych dyrektyw\u0105 .PROC , do kt\u00f3rych nie nast\u0105pi\u0142o odwo\u0142anie w programie.","title":"x"},{"location":"sposob-uzycia/#vu","text":"Prze\u0142\u0105cznik -vu wymusza dodatkowy test kodu w blokach .PROC mimo tego \u017ce taki blok .PROC nie zostanie zapisany do pliku wynikowego, najcz\u0119\u015bciej przydaje si\u0119 gdy u\u017cywamy prze\u0142\u0105cznika -x","title":"vu"},{"location":"sposob-uzycia/#u","text":"Prze\u0142\u0105cznik -u wy\u015bwietli etykiety kt\u00f3re nie zosta\u0142y u\u017cyte w programie.","title":"u"},{"location":"sposob-uzycia/#kody-wyjscia","text":"3 = bad parameters, assembling not started 2 = error occured 0 = no errors Komunikaty ostrze\u017cenia nie powoduj\u0105 zmiany warto\u015bci kodu wyj\u015bcia.","title":"Kody wyj\u015bcia"},{"location":"sposob-uzycia/#struktura-pliku-lst","text":"Format listingu nie odbiega od tego znanego z XASM , jedyn\u0105 zmian\u0105 jest dodanie przed adresem, numeru wirtualnego banku pami\u0119ci (pod warunkiem \u017ce numer banku <> 0 ). 3 4 = 01,9033 obraz equ $9033 5 = 01,00A0 scr1 equ $a0 6 7 8 01,2000 EA main nop","title":"Struktura pliku LST"},{"location":"sposob-uzycia/#struktura-pliku-lab","text":"Podobnie jak w przypadku XASM , w pliku *.LAB przechowywane s\u0105 informacje na temat etykiet kt\u00f3re wyst\u0105pi\u0142y w programie. W sumie s\u0105 to trzy kolumny: Pierwsza kolumna to numer wirtualnego banku przypisany do etykiety (je\u015bli bank <> 0 ) Druga kolumna to warto\u015b\u0107 etykiety. Trzecia kolumna to nazwa etykiety. Numery wirtualnych bank\u00f3w przypisane do etykiety o warto\u015bciach >= $FFF9 maj\u0105 specjalne znaczenie: $FFF9 etykieta parametru procedury zdefiniowanej przez dyrektyw\u0119 .PROC $FFFA etykieta tablicy zdefiniowanej przez dyrektyw\u0119 .ARRAY $FFFB etykieta danych strukturalnych zdefiniowanej przez pseudo rozkaz DTA STRUCT_LABEL $FFFC etykieta symbolu Sparta DOS X - SMB $FFFD etykieta makra zdefiniowanego przez dyrektyw\u0119 .MACRO $FFFE etykieta struktury zdefiniowanej przez dyrektyw\u0119 .STRUCT $FFFF etykieta procedury zdefiniowanej przez dyrektyw\u0119 .PROC Specjalne znaczenie w nazwach etykiet maj\u0105 znaki: etykieta zdefiniowana w makrze (dwa dwukropki) :: znak kropki . rozdziela nazw\u0119 struktury .MACRO .PROC .LOCAL .STRUCT od nazwy pola w strukturze Warto\u015b\u0107 liczbowa, kt\u00f3ra wyst\u0119puje po :: oznacza numer wywo\u0142ania makra. Mad-Assembler v1.4.2beta by TeBe/Madteam Label table: 00 0400 @STACK_ADDRESS 00 00FF @STACK_POINTER 00 2000 MAIN 00 2019 LOOP 00 201C LOOP::1 00 201C LHEX 00 0080 LHEX.HLP 00 204C LHEX.THEX 00 205C HEX 00 205C HEX.@GETPAR0.LOOP 00 2079 HEX.@GETPAR1.LOOP","title":"Struktura pliku LAB"},{"location":"sposob-uzycia/#struktura-pliku-h","text":"Nie jestem pewien czy wszystko z tym plikiem jest OK, ale Eru chcia\u0142 \u017ceby co\u015b takiego by\u0142o wi\u0119c jest :) Ma on by\u0107 pomocny przy \u0142\u0105czeniu ASM z CC65 , czyli portem C dla ma\u0142ego Atari . Jego zawarto\u015b\u0107 mo\u017ce wygl\u0105da\u0107 tak, przyk\u0142adowy plik TEST.ASM : #ifndef _TEST_ASM_H_ #define _TEST_ASM_H_ #define TEST_CPU65816 0x200F #define TEST_CPU6502 0x2017 #define TEST_TEXT6502 0x201F #define TEST_TEXT65816 0x2024 #endif","title":"Struktura pliku H"},{"location":"tablice/","text":"Tablice Deklaracja tablicy Tablic dotycz\u0105 n/w dyrektywy: label .ARRAY [elements0][elements1][...] [.type] [= init_value] .ARRAY label [elements0][elements1][...] [.type] [= init_value] .ENDA [.AEND] [.END] Dost\u0119pne typy danych to .BYTE , .WORD , .LONG , .DWORD . W przypadku braku podania typu domy\u015blnie przyjmowany jest typ .BYTE . Definicja tablicy lokalizuje j\u0105 in-place (w miejscu definicji). ELEMENTS okre\u015bla liczb\u0119 element\u00f3w tablicy, kt\u00f3re b\u0119d\u0105 indeksowane od <0..ELEMENTS-1> . Warto\u015b\u0107 ELEMENTS mo\u017ce by\u0107 sta\u0142\u0105 lub wyra\u017ceniem, powinna by\u0107 z przedzia\u0142u <0..65535> . W przypadku braku podania liczby element\u00f3w zostanie ona ustalona na podstawie liczby wprowadzonych danych. W obszarze ograniczonym dyrektywami .ARRAY i .ENDA nie ma mo\u017cliwo\u015bci u\u017cywania mnemonik\u00f3w CPU , je\u015bli je u\u017cyjemy lub u\u017cyjemy innych niedozwolonych znak\u00f3w w\u00f3wczas wyst\u0105pi b\u0142\u0105d z komunikatem Improper syntax . Dopuszczalne jest okre\u015blenie indeksu od jakiego b\u0119dziemy wpisywali warto\u015bci dla kolejnych p\u00f3l tablicy. Now\u0105 warto\u015b\u0107 takiego indeksu okre\u015blamy umieszczaj\u0105c na pocz\u0105tku nowego wiersza w nawiasach kwadratowych wyra\u017cenie [expression] . Mo\u017cliwe jest okre\u015blenie wi\u0119kszej ilo\u015bci indeks\u00f3w, w tym celu rozdzielamy kolejne indeksy znakiem dwukropka : . Nast\u0119pnie wprowadzamy warto\u015bci dla p\u00f3l tablicy po znaku r\u00f3wno\u015bci = , np.: .array tab .word ; tablica TAB o nieokre\u015blonej z g\u00f3ry liczbie p\u00f3l typu .WORD 1,3 ; [0]=1, [1]=3 5 ; [2]=5 [12] = 1 ; [12]=1 [3]:[7]:[11] = 9,11 ; [3]=9, [4]=11, [7]=9, [8]=11, [11]=9, [12]=11 .enda .array scr [24][40] ; tablica dwuwymiarowa SCR typu .BYTE [11][15] = \"ATARI\" .enda Przyk\u0142ad tablicy t\u0142umacz\u0105cej kod naci\u015bni\u0119tego klawisza na kod INTERNAL. .array TAB [255] .byte = $ff ; alokowanie 256 bajt\u00f3w [0..255] o warto\u015bci pocz\u0105tkowej $FF [63]:[127] = \"A\" ; przypisanie nowej warto\u015bci TAB[63]=\"A\", TAB[127]=\"A\" [21]:[85] = \"B\" [18]:[82] = \"C\" [58]:[122] = \"D\" [42]:[106] = \"E\" [56]:[120] = \"F\" [61]:[125] = \"G\" [57]:[121] = \"H\" [13]:[77] = \"I\" [1] :[65] = \"J\" [5] :[69] = \"K\" [0] :[64] = \"L\" [37]:[101] = \"M\" [35]:[99] = \"N\" [8] :[72] = \"O\" [10]:[74] = \"P\" [47]:[111] = \"Q\" [40]:[104] = \"R\" [62]:[126] = \"S\" [45]:[109] = \"T\" [11]:[75] = \"U\" [16]:[80] = \"V\" [46]:[110] = \"W\" [22]:[86] = \"X\" [43]:[107] = \"Y\" [23]:[87] = \"Z\" [33]:[97] = \" \" [52]:[180] = $7e [12]:[76] = $9b .enda W w/w przyk\u0142adzie stworzyli\u015bmy tablic\u0119 TAB o rozmiarze 256 bajt\u00f3w [0..255] , typie danych .BYTE i wype\u0142nili\u015bmy pola warto\u015bci\u0105 = $FF , dodatkowo zapisali\u015bmy warto\u015bci kod\u00f3w literowych INTERNAL na pozycjach (indeksach tablicy) r\u00f3wnych kodowi naci\u015bni\u0119cia klawisza (bez SHIFT-a i z SHIFT-em, czyli du\u017ce i ma\u0142e litery). Znak dwukropka : rozdziela poszczeg\u00f3lne indeksy tablicy. Przyk\u0142ad procedury detekcji ruchu joysticka, np.: .local HERO .pages lda $d300 and #$0f tay lda joy,y sta _jmp jmp null _jmp equ *-2 left right up down null rts .endpg _none = 15 _up = 14 _down = 13 _left = 11 _left_up = 10 _left_dw = 9 _right = 7 _right_up = 6 _right_dw = 5 .array joy [16] .byte = .lo(null) [_left] = .lo(left) [_left_up] = .lo(left) [_left_dw] = .lo(left) [_right = .lo(right) [_right_up] = .lo(right) [_right_dw] = .lo(right) [_up] = .lo(up) [_dw] = .lo(down) .enda .endl Innym przyk\u0142adem mo\u017ce by\u0107 umieszczenie wycentrowanego napisu, np.: org $bc40 .array txt 39 .byte [17] = \"ATARI\" .enda Do tak stworzonej tablicy odwo\u0142ujemy si\u0119 nast\u0119puj\u0105co: lda tab,y lda tab[23],x ldx tab[200] Je\u015bli w nawiasie kwadratowym podamy warto\u015b\u0107 indeksu przekraczaj\u0105c\u0105 zadeklarowan\u0105 dla danej tablicy, zostanie wygenerowany komunikat b\u0142\u0119du _ Constant expression violates subrange bounds +.","title":"Tablice"},{"location":"tablice/#tablice","text":"","title":"Tablice"},{"location":"tablice/#deklaracja-tablicy","text":"Tablic dotycz\u0105 n/w dyrektywy: label .ARRAY [elements0][elements1][...] [.type] [= init_value] .ARRAY label [elements0][elements1][...] [.type] [= init_value] .ENDA [.AEND] [.END] Dost\u0119pne typy danych to .BYTE , .WORD , .LONG , .DWORD . W przypadku braku podania typu domy\u015blnie przyjmowany jest typ .BYTE . Definicja tablicy lokalizuje j\u0105 in-place (w miejscu definicji). ELEMENTS okre\u015bla liczb\u0119 element\u00f3w tablicy, kt\u00f3re b\u0119d\u0105 indeksowane od <0..ELEMENTS-1> . Warto\u015b\u0107 ELEMENTS mo\u017ce by\u0107 sta\u0142\u0105 lub wyra\u017ceniem, powinna by\u0107 z przedzia\u0142u <0..65535> . W przypadku braku podania liczby element\u00f3w zostanie ona ustalona na podstawie liczby wprowadzonych danych. W obszarze ograniczonym dyrektywami .ARRAY i .ENDA nie ma mo\u017cliwo\u015bci u\u017cywania mnemonik\u00f3w CPU , je\u015bli je u\u017cyjemy lub u\u017cyjemy innych niedozwolonych znak\u00f3w w\u00f3wczas wyst\u0105pi b\u0142\u0105d z komunikatem Improper syntax . Dopuszczalne jest okre\u015blenie indeksu od jakiego b\u0119dziemy wpisywali warto\u015bci dla kolejnych p\u00f3l tablicy. Now\u0105 warto\u015b\u0107 takiego indeksu okre\u015blamy umieszczaj\u0105c na pocz\u0105tku nowego wiersza w nawiasach kwadratowych wyra\u017cenie [expression] . Mo\u017cliwe jest okre\u015blenie wi\u0119kszej ilo\u015bci indeks\u00f3w, w tym celu rozdzielamy kolejne indeksy znakiem dwukropka : . Nast\u0119pnie wprowadzamy warto\u015bci dla p\u00f3l tablicy po znaku r\u00f3wno\u015bci = , np.: .array tab .word ; tablica TAB o nieokre\u015blonej z g\u00f3ry liczbie p\u00f3l typu .WORD 1,3 ; [0]=1, [1]=3 5 ; [2]=5 [12] = 1 ; [12]=1 [3]:[7]:[11] = 9,11 ; [3]=9, [4]=11, [7]=9, [8]=11, [11]=9, [12]=11 .enda .array scr [24][40] ; tablica dwuwymiarowa SCR typu .BYTE [11][15] = \"ATARI\" .enda Przyk\u0142ad tablicy t\u0142umacz\u0105cej kod naci\u015bni\u0119tego klawisza na kod INTERNAL. .array TAB [255] .byte = $ff ; alokowanie 256 bajt\u00f3w [0..255] o warto\u015bci pocz\u0105tkowej $FF [63]:[127] = \"A\" ; przypisanie nowej warto\u015bci TAB[63]=\"A\", TAB[127]=\"A\" [21]:[85] = \"B\" [18]:[82] = \"C\" [58]:[122] = \"D\" [42]:[106] = \"E\" [56]:[120] = \"F\" [61]:[125] = \"G\" [57]:[121] = \"H\" [13]:[77] = \"I\" [1] :[65] = \"J\" [5] :[69] = \"K\" [0] :[64] = \"L\" [37]:[101] = \"M\" [35]:[99] = \"N\" [8] :[72] = \"O\" [10]:[74] = \"P\" [47]:[111] = \"Q\" [40]:[104] = \"R\" [62]:[126] = \"S\" [45]:[109] = \"T\" [11]:[75] = \"U\" [16]:[80] = \"V\" [46]:[110] = \"W\" [22]:[86] = \"X\" [43]:[107] = \"Y\" [23]:[87] = \"Z\" [33]:[97] = \" \" [52]:[180] = $7e [12]:[76] = $9b .enda W w/w przyk\u0142adzie stworzyli\u015bmy tablic\u0119 TAB o rozmiarze 256 bajt\u00f3w [0..255] , typie danych .BYTE i wype\u0142nili\u015bmy pola warto\u015bci\u0105 = $FF , dodatkowo zapisali\u015bmy warto\u015bci kod\u00f3w literowych INTERNAL na pozycjach (indeksach tablicy) r\u00f3wnych kodowi naci\u015bni\u0119cia klawisza (bez SHIFT-a i z SHIFT-em, czyli du\u017ce i ma\u0142e litery). Znak dwukropka : rozdziela poszczeg\u00f3lne indeksy tablicy. Przyk\u0142ad procedury detekcji ruchu joysticka, np.: .local HERO .pages lda $d300 and #$0f tay lda joy,y sta _jmp jmp null _jmp equ *-2 left right up down null rts .endpg _none = 15 _up = 14 _down = 13 _left = 11 _left_up = 10 _left_dw = 9 _right = 7 _right_up = 6 _right_dw = 5 .array joy [16] .byte = .lo(null) [_left] = .lo(left) [_left_up] = .lo(left) [_left_dw] = .lo(left) [_right = .lo(right) [_right_up] = .lo(right) [_right_dw] = .lo(right) [_up] = .lo(up) [_dw] = .lo(down) .enda .endl Innym przyk\u0142adem mo\u017ce by\u0107 umieszczenie wycentrowanego napisu, np.: org $bc40 .array txt 39 .byte [17] = \"ATARI\" .enda Do tak stworzonej tablicy odwo\u0142ujemy si\u0119 nast\u0119puj\u0105co: lda tab,y lda tab[23],x ldx tab[200] Je\u015bli w nawiasie kwadratowym podamy warto\u015b\u0107 indeksu przekraczaj\u0105c\u0105 zadeklarowan\u0105 dla danej tablicy, zostanie wygenerowany komunikat b\u0142\u0119du _ Constant expression violates subrange bounds +.","title":"Deklaracja tablicy"},{"location":"typy/","text":"MADS udost\u0119pnia mo\u017cliwo\u015b\u0107 deklaracji dw\u00f3ch typ\u00f3w danych: strukturalne .STRUCT i wyliczeniowe .ENUM . STRUKTURY Je\u015bli programowali\u015bcie w C , to pewnie spotkali\u015bcie si\u0119 ju\u017c ze strukturami. Og\u00f3lnie w MADS struktura definiuje tablic\u0119 wirtualn\u0105, jednowymiarow\u0105 o polach r\u00f3\u017cnego typu .BYTE .WORD .LONG .DWORD i ich wielokrotno\u015bci. Wirtualna poniewa\u017c istnieje ona jak na razie tylko w pami\u0119ci assemblera. Pola takiej struktury zawieraj\u0105 informacj\u0119 o ofsecie do pocz\u0105tku struktury. Deklaracja .STRUCT Struktur dotycz\u0105 n/w dyrektywy: name .STRUCT .STRUCT name .ENDS [.SEND] [.END] name .STRUCT Deklaracja struktury name przy u\u017cyciu dyrektywy .STRUCT . Nazwa struktury jest wymagana i konieczna, jej brak wygeneruje b\u0142\u0105d. Do nazw struktur nie mo\u017cna u\u017cywa\u0107 nazw mnemonik\u00f3w i pseudo rozkaz\u00f3w. Je\u015bli nazwa jest zarezerwowana wyst\u0105pi b\u0142\u0105d z komunikatem Reserved word . Przyk\u0142ad deklaracji struktury: .STRUCT name x .word ; lda #name.x = 0 y .word ; lda #name.y = 2 z .long ; lda #name.z = 4 v .dword ; lda #name.v = 7 q :3 .byte ; lda #name.q = 11 .ENDS ; lda #name = 14 (length) Pola struktury definiujemy przez podanie nazwy i typu pola .BYTE .WORD .LONG .DWORD . Nazwa pola mo\u017ce by\u0107 poprzedzona bia\u0142ymi spacjami . W obszarze ograniczonym dyrektywami .STRUCT i .ENDS nie ma mo\u017cliwo\u015bci u\u017cywania mnemonik\u00f3w CPU , je\u015bli je u\u017cyjemy lub u\u017cyjemy innych niedozwolonych znak\u00f3w wyst\u0105pi b\u0142\u0105d z komunikatem Improper syntax lub Illegal instruction . Podsumowuj\u0105c, etykieta name zawiera informacj\u0119 o ca\u0142kowitej d\u0142ugo\u015bci struktury (w bajtach). Pozosta\u0142e etykiety opisuj\u0105ce pola zawieraj\u0105 informacj\u0119 o ofsecie do pocz\u0105tku struktury. Deklaracji struktur nie mo\u017cna zagnie\u017cd\u017ca\u0107, mo\u017cna zagnie\u017cd\u017ca\u0107 wcze\u015bniej zadeklarowane struktury (kolejno\u015b\u0107 wyst\u0105pienia w programie nie ma znaczenia), np.: .STRUCT temp x .word y .word v .byte z .word .ENDS .STRUCT test tmp temp .ENDS lda #temp.v lda #test.tmp.x lda #test.tmp.z Do czego mo\u017ce przyda\u0107 si\u0119 struktura? Przypu\u015b\u0107my, \u017ce mamy jak\u0105\u015b tablic\u0119 z polami r\u00f3\u017cnego typu, mo\u017cemy odczytywa\u0107 pola takiej tablicy przy pomocy z g\u00f3ry okre\u015blonych warto\u015bci offset\u00f3w. Jednak gdy dodamy dodatkowe pole do tablicy, czy te\u017c zmodyfikujemy j\u0105 w inny spos\u00f3b, b\u0119dziemy zmuszeni poprawia\u0107 kod programu kt\u00f3ry pos\u0142ugiwa\u0142 si\u0119 z g\u00f3ry okre\u015blonymi warto\u015bciami offset\u00f3w. Gdy zdefiniujemy tak\u0105 tablic\u0119 przy pomocy struktury b\u0119dziemy mogli odczytywa\u0107 jej pola pos\u0142uguj\u0105c si\u0119 offsetami zapisanymi w deklaracji struktury, czyli zawsze odczytamy w\u0142a\u015bciwe pole niezale\u017cnie od zmian jakie zasz\u0142y w tablicy. Inny przyk\u0142ad zastosowania struktur zosta\u0142 opisany w rozdziale Symbole zewn\u0119trzne , przyk\u0142ad zastosowania symboli external i struktur .STRUCT . Definicja (odwo\u0142ania) Definiowanie danych strukturalnych polega na przypisaniu nowej etykiecie konkretnej struktury z u\u017cyciem pseudo rozkazu DTA lub bez tego pseudo rozkazu. Wynikiem takiego przypisania jest zarezerwowana pami\u0119\u0107, nie jest to ju\u017c tw\u00f3r wirtualny. label DTA struct_name [count] (data1,data2,data3...) (data1,data2,data3...) ... label struct_name COUNT okre\u015bla liczb\u0119 z przedzia\u0142u 0..COUNT , kt\u00f3ra definiuje maksymaln\u0105 warto\u015b\u0107 indeksu tablicy jednowymiarowej, a przez to tak\u017ce liczb\u0119 od\u0142o\u017conych w pami\u0119ci danych typu strukturalnego. Przyk\u0142ad deklaracji struktury i definicji danych strukturalnych: ;----------------------; ; deklaracja struktury ; ;----------------------; .STRUCT temp x .word y .word v .byte z .word .ENDS ;---------------------; ; definiowanie danych ; ;---------------------; data dta temp [12] (1,20,200,32000) (19,2,122,42700) data2 dta temp [0] data3 temp // kr\u00f3tszy odpowiednik DATA2 Po nazwie struktury w nawiasie kwadratowym musi znajdowa\u0107 si\u0119 warto\u015b\u0107 z przedzia\u0142u 0..2147483647 , kt\u00f3ra definiuje maksymaln\u0105 warto\u015b\u0107 indeksu tablicy jednowymiarowej, a jednocze\u015bnie liczb\u0119 od\u0142o\u017conych w pami\u0119ci danych typu strukturalnego. Po nawiasie kwadratowym mo\u017ce wyst\u0105pi\u0107 opcjonalnie lista warto\u015bci pocz\u0105tkowych (ograniczona nawiasami okr\u0105g\u0142ymi), je\u015bli nie wyst\u0105pi w\u00f3wczas domy\u015blnymi warto\u015bciami p\u00f3l struktury s\u0105 zera. Z kolei je\u015bli lista warto\u015bci pocz\u0105tkowych jest mniejsza od liczby p\u00f3l zadeklarowanych, w\u00f3wczas pozosta\u0142e pola inicjowane s\u0105 ostatnimi warto\u015bciami jakie zosta\u0142y podane, np. data dta temp [12] (1,20,200,32000) Taka deklaracja spowoduje, \u017ce wszystkie pola zostan\u0105 zaincjowane warto\u015bciami 1,20,200,32000 , a nie tylko pierwsze pole data[0] . Je\u015bli lista warto\u015bci pocz\u0105tkowych b\u0119dzie wi\u0119ksza lub mniejsza od liczby p\u00f3l struktury, w\u00f3wczas wyst\u0105pi b\u0142\u0105d z komunikatem Constant expression violates subrange bounds . Aby odwo\u0142a\u0107 si\u0119 do p\u00f3l tak nowo powsta\u0142ych danych nale\u017cy poda\u0107 ich nazw\u0119, koniecznie indeks w nawiasie kwadratowym i nazw\u0119 pola po kropce, np.: lda data[4].y ldx #data[0].v Brak nawiasu kwadratowego z indeksem label[index] zako\u0144czy si\u0119 komunikatem b\u0142\u0119du Undeclared label . WYLICZENIA Wylicze\u0144 dotycz\u0105 n/w dyrektywy: name .ENUM .ENDE [.EEND] [.END] Example: .enum portb rom_off = $fe rom_on = $ff .ende .enum test a ; a=0 b ; b=1 c = 5 ; c=5 d ; d=6 .ende Deklaracja wyliczenia odbywa si\u0119 przy u\u017cyciu dyrektyw .ENUM i .ENDE . Nazwa wyliczenia jest wymagana i konieczna, jej brak wygeneruje b\u0142\u0105d. Do nazw wylicze\u0144 nie mo\u017cna u\u017cywa\u0107 nazw mnemonik\u00f3w i pseudo rozkaz\u00f3w. Je\u015bli nazwa jest zarezerwowana wyst\u0105pi b\u0142\u0105d z komunikatem Reserved word . Warto\u015bci kolejnych etykiet s\u0105 zwi\u0119kszane automatycznie o 1 zaczynaj\u0105c od domy\u015blnej warto\u015bci 0 , warto\u015bci etykiet mo\u017cna definiowa\u0107 samodzielnie albo pozostawi\u0107 to automatowi. Do etykiet wyliczeniowych odwo\u0142ujemy si\u0119 przy pomocy sk\u0142adni: enum_name (field) lub bezpo\u015brednio podobnie jak w przypadku odwo\u0142a\u0144 do blok\u00f3w .LOCAL .PROC czyli po nazwie typu oddzielone znakiem kropki wyst\u0119puj\u0105 kolejne pola, np.: lda #portb(rom_off) dta portb.rom_on, portb.rom_off Wylicze\u0144 mo\u017cemy u\u017cy\u0107 do deklaracji p\u00f3l struktury .STRUCT , do alokacji zmiennych dyrektyw\u0105 .VAR , np.: bank portb // alokacja zmiennej BANK o rozmiarze 1 bajtu .var bank portb // alokacja zmiennej BANK o rozmiarze 1 bajtu .struct test a portb b portb .ends Rozmiar zmiennej typu wyliczeniowego zale\u017cny jest od maksymalnej warto\u015bci jakie przyjmuj\u0105 kolejne etykiety wyliczenia, np.: .enum EState DONE, DIRECTORY_SEARCH=$ff, INIT_LOADING, LOADING .ende Dla w/w przyk\u0142adu alokacja zmiennej typu EState b\u0119dzie mia\u0142a rozmiar dw\u00f3ch bajt\u00f3w WORD . Rozmiar mo\u017cemy sprawdzi\u0107 przy pomocy dyrektywy .LEN .SIZEOF , wynikiem b\u0119d\u0105 warto\u015bci 1..4 (1 BYTE , 2 WORD , 3 LONG , 4 DWORD ) np.: .print .len EState","title":"Typy danych"},{"location":"typy/#_1","text":"MADS udost\u0119pnia mo\u017cliwo\u015b\u0107 deklaracji dw\u00f3ch typ\u00f3w danych: strukturalne .STRUCT i wyliczeniowe .ENUM .","title":""},{"location":"typy/#struktury","text":"Je\u015bli programowali\u015bcie w C , to pewnie spotkali\u015bcie si\u0119 ju\u017c ze strukturami. Og\u00f3lnie w MADS struktura definiuje tablic\u0119 wirtualn\u0105, jednowymiarow\u0105 o polach r\u00f3\u017cnego typu .BYTE .WORD .LONG .DWORD i ich wielokrotno\u015bci. Wirtualna poniewa\u017c istnieje ona jak na razie tylko w pami\u0119ci assemblera. Pola takiej struktury zawieraj\u0105 informacj\u0119 o ofsecie do pocz\u0105tku struktury.","title":"STRUKTURY"},{"location":"typy/#deklaracja-struct","text":"Struktur dotycz\u0105 n/w dyrektywy: name .STRUCT .STRUCT name .ENDS [.SEND] [.END] name .STRUCT Deklaracja struktury name przy u\u017cyciu dyrektywy .STRUCT . Nazwa struktury jest wymagana i konieczna, jej brak wygeneruje b\u0142\u0105d. Do nazw struktur nie mo\u017cna u\u017cywa\u0107 nazw mnemonik\u00f3w i pseudo rozkaz\u00f3w. Je\u015bli nazwa jest zarezerwowana wyst\u0105pi b\u0142\u0105d z komunikatem Reserved word . Przyk\u0142ad deklaracji struktury: .STRUCT name x .word ; lda #name.x = 0 y .word ; lda #name.y = 2 z .long ; lda #name.z = 4 v .dword ; lda #name.v = 7 q :3 .byte ; lda #name.q = 11 .ENDS ; lda #name = 14 (length) Pola struktury definiujemy przez podanie nazwy i typu pola .BYTE .WORD .LONG .DWORD . Nazwa pola mo\u017ce by\u0107 poprzedzona bia\u0142ymi spacjami . W obszarze ograniczonym dyrektywami .STRUCT i .ENDS nie ma mo\u017cliwo\u015bci u\u017cywania mnemonik\u00f3w CPU , je\u015bli je u\u017cyjemy lub u\u017cyjemy innych niedozwolonych znak\u00f3w wyst\u0105pi b\u0142\u0105d z komunikatem Improper syntax lub Illegal instruction . Podsumowuj\u0105c, etykieta name zawiera informacj\u0119 o ca\u0142kowitej d\u0142ugo\u015bci struktury (w bajtach). Pozosta\u0142e etykiety opisuj\u0105ce pola zawieraj\u0105 informacj\u0119 o ofsecie do pocz\u0105tku struktury. Deklaracji struktur nie mo\u017cna zagnie\u017cd\u017ca\u0107, mo\u017cna zagnie\u017cd\u017ca\u0107 wcze\u015bniej zadeklarowane struktury (kolejno\u015b\u0107 wyst\u0105pienia w programie nie ma znaczenia), np.: .STRUCT temp x .word y .word v .byte z .word .ENDS .STRUCT test tmp temp .ENDS lda #temp.v lda #test.tmp.x lda #test.tmp.z Do czego mo\u017ce przyda\u0107 si\u0119 struktura? Przypu\u015b\u0107my, \u017ce mamy jak\u0105\u015b tablic\u0119 z polami r\u00f3\u017cnego typu, mo\u017cemy odczytywa\u0107 pola takiej tablicy przy pomocy z g\u00f3ry okre\u015blonych warto\u015bci offset\u00f3w. Jednak gdy dodamy dodatkowe pole do tablicy, czy te\u017c zmodyfikujemy j\u0105 w inny spos\u00f3b, b\u0119dziemy zmuszeni poprawia\u0107 kod programu kt\u00f3ry pos\u0142ugiwa\u0142 si\u0119 z g\u00f3ry okre\u015blonymi warto\u015bciami offset\u00f3w. Gdy zdefiniujemy tak\u0105 tablic\u0119 przy pomocy struktury b\u0119dziemy mogli odczytywa\u0107 jej pola pos\u0142uguj\u0105c si\u0119 offsetami zapisanymi w deklaracji struktury, czyli zawsze odczytamy w\u0142a\u015bciwe pole niezale\u017cnie od zmian jakie zasz\u0142y w tablicy. Inny przyk\u0142ad zastosowania struktur zosta\u0142 opisany w rozdziale Symbole zewn\u0119trzne , przyk\u0142ad zastosowania symboli external i struktur .STRUCT .","title":"Deklaracja .STRUCT"},{"location":"typy/#definicja-odwoania","text":"Definiowanie danych strukturalnych polega na przypisaniu nowej etykiecie konkretnej struktury z u\u017cyciem pseudo rozkazu DTA lub bez tego pseudo rozkazu. Wynikiem takiego przypisania jest zarezerwowana pami\u0119\u0107, nie jest to ju\u017c tw\u00f3r wirtualny. label DTA struct_name [count] (data1,data2,data3...) (data1,data2,data3...) ... label struct_name COUNT okre\u015bla liczb\u0119 z przedzia\u0142u 0..COUNT , kt\u00f3ra definiuje maksymaln\u0105 warto\u015b\u0107 indeksu tablicy jednowymiarowej, a przez to tak\u017ce liczb\u0119 od\u0142o\u017conych w pami\u0119ci danych typu strukturalnego. Przyk\u0142ad deklaracji struktury i definicji danych strukturalnych: ;----------------------; ; deklaracja struktury ; ;----------------------; .STRUCT temp x .word y .word v .byte z .word .ENDS ;---------------------; ; definiowanie danych ; ;---------------------; data dta temp [12] (1,20,200,32000) (19,2,122,42700) data2 dta temp [0] data3 temp // kr\u00f3tszy odpowiednik DATA2 Po nazwie struktury w nawiasie kwadratowym musi znajdowa\u0107 si\u0119 warto\u015b\u0107 z przedzia\u0142u 0..2147483647 , kt\u00f3ra definiuje maksymaln\u0105 warto\u015b\u0107 indeksu tablicy jednowymiarowej, a jednocze\u015bnie liczb\u0119 od\u0142o\u017conych w pami\u0119ci danych typu strukturalnego. Po nawiasie kwadratowym mo\u017ce wyst\u0105pi\u0107 opcjonalnie lista warto\u015bci pocz\u0105tkowych (ograniczona nawiasami okr\u0105g\u0142ymi), je\u015bli nie wyst\u0105pi w\u00f3wczas domy\u015blnymi warto\u015bciami p\u00f3l struktury s\u0105 zera. Z kolei je\u015bli lista warto\u015bci pocz\u0105tkowych jest mniejsza od liczby p\u00f3l zadeklarowanych, w\u00f3wczas pozosta\u0142e pola inicjowane s\u0105 ostatnimi warto\u015bciami jakie zosta\u0142y podane, np. data dta temp [12] (1,20,200,32000) Taka deklaracja spowoduje, \u017ce wszystkie pola zostan\u0105 zaincjowane warto\u015bciami 1,20,200,32000 , a nie tylko pierwsze pole data[0] . Je\u015bli lista warto\u015bci pocz\u0105tkowych b\u0119dzie wi\u0119ksza lub mniejsza od liczby p\u00f3l struktury, w\u00f3wczas wyst\u0105pi b\u0142\u0105d z komunikatem Constant expression violates subrange bounds . Aby odwo\u0142a\u0107 si\u0119 do p\u00f3l tak nowo powsta\u0142ych danych nale\u017cy poda\u0107 ich nazw\u0119, koniecznie indeks w nawiasie kwadratowym i nazw\u0119 pola po kropce, np.: lda data[4].y ldx #data[0].v Brak nawiasu kwadratowego z indeksem label[index] zako\u0144czy si\u0119 komunikatem b\u0142\u0119du Undeclared label .","title":"Definicja (odwo\u0142ania)"},{"location":"typy/#wyliczenia","text":"Wylicze\u0144 dotycz\u0105 n/w dyrektywy: name .ENUM .ENDE [.EEND] [.END] Example: .enum portb rom_off = $fe rom_on = $ff .ende .enum test a ; a=0 b ; b=1 c = 5 ; c=5 d ; d=6 .ende Deklaracja wyliczenia odbywa si\u0119 przy u\u017cyciu dyrektyw .ENUM i .ENDE . Nazwa wyliczenia jest wymagana i konieczna, jej brak wygeneruje b\u0142\u0105d. Do nazw wylicze\u0144 nie mo\u017cna u\u017cywa\u0107 nazw mnemonik\u00f3w i pseudo rozkaz\u00f3w. Je\u015bli nazwa jest zarezerwowana wyst\u0105pi b\u0142\u0105d z komunikatem Reserved word . Warto\u015bci kolejnych etykiet s\u0105 zwi\u0119kszane automatycznie o 1 zaczynaj\u0105c od domy\u015blnej warto\u015bci 0 , warto\u015bci etykiet mo\u017cna definiowa\u0107 samodzielnie albo pozostawi\u0107 to automatowi. Do etykiet wyliczeniowych odwo\u0142ujemy si\u0119 przy pomocy sk\u0142adni: enum_name (field) lub bezpo\u015brednio podobnie jak w przypadku odwo\u0142a\u0144 do blok\u00f3w .LOCAL .PROC czyli po nazwie typu oddzielone znakiem kropki wyst\u0119puj\u0105 kolejne pola, np.: lda #portb(rom_off) dta portb.rom_on, portb.rom_off Wylicze\u0144 mo\u017cemy u\u017cy\u0107 do deklaracji p\u00f3l struktury .STRUCT , do alokacji zmiennych dyrektyw\u0105 .VAR , np.: bank portb // alokacja zmiennej BANK o rozmiarze 1 bajtu .var bank portb // alokacja zmiennej BANK o rozmiarze 1 bajtu .struct test a portb b portb .ends Rozmiar zmiennej typu wyliczeniowego zale\u017cny jest od maksymalnej warto\u015bci jakie przyjmuj\u0105 kolejne etykiety wyliczenia, np.: .enum EState DONE, DIRECTORY_SEARCH=$ff, INIT_LOADING, LOADING .ende Dla w/w przyk\u0142adu alokacja zmiennej typu EState b\u0119dzie mia\u0142a rozmiar dw\u00f3ch bajt\u00f3w WORD . Rozmiar mo\u017cemy sprawdzi\u0107 przy pomocy dyrektywy .LEN .SIZEOF , wynikiem b\u0119d\u0105 warto\u015bci 1..4 (1 BYTE , 2 WORD , 3 LONG , 4 DWORD ) np.: .print .len EState","title":"WYLICZENIA"},{"location":"wprowadzenie/","text":"Wst\u0119p W za\u0142o\u017ceniu MADS skierowany jest do u\u017cytkownik\u00f3w QA , XASM , FA . Z QA zapo\u017cyczona zosta\u0142a sk\u0142adnia, z XASM niekt\u00f3re makro rozkazy i zmiany sk\u0142adni, z FA obs\u0142uga sk\u0142adni Sparta DOS X (SDX). Umo\u017cliwione zosta\u0142o u\u017cycie dodatkowych znak\u00f3w w nazwach etykiet. Poza tym dodana zosta\u0142a obs\u0142uga CPU WDC 65816 , makr, procedur, podzia\u0142u pami\u0119ci na wirtualne banki, wielowymiarowych nazw etykiet. Maksymalna liczba etykiet i makr ograniczona jest ilo\u015bci\u0105 pami\u0119ci komputera PC . Konkretnie mo\u017cna dokona\u0107 2147483647 INTEGER wpis\u00f3w do tablic dynamicznych. Jestem pewien \u017ce taka ilo\u015b\u0107 jest wystarczaj\u0105ca :-). Operacje arytmetyczne dokonywane s\u0105 na warto\u015bciach typu INT64 (signed 64 bit), wynik reprezentowany jest na warto\u015bciach typu CARDINAL (unsigned 32 bit). Jeden wiersz mo\u017ce mie\u0107 d\u0142ugo\u015b\u0107 65535 bajt\u00f3w, takiej d\u0142ugo\u015bci mo\u017ce by\u0107 te\u017c nazwa etykiety. Nie mia\u0142em jednak okazji sprawdzi\u0107 tak d\u0142ugich etykiet i wierszy :-). Kompilacja Mad-Assembler (MADS) jest aplikacj\u0105 Windows 32 bitow\u0105, napisan\u0105 w Delphi . Wi\u0119kszo\u015b\u0107 asembler\u00f3w napisano w C , wi\u0119c \u017ceby si\u0119 nie powtarza\u0107 u\u017cy\u0142em Delphi 7.0 ;-). Najnowsze \u017ar\u00f3d\u0142a s\u0105 dost\u0119pne na GitHub . Aby je skompilowa\u0107, mo\u017cna u\u017cy\u0107 kompilatora Delphi , je\u015bli mamy zainstalowane Delphi 7.0 lub nowsze. Dzi\u0119ki darmowemu kompilatorowi Free Pascal Compiler (FPC) mo\u017cliwa jest kompilacja MADS dla innych platform systemowych, np. Linux , macOS itp. Pobierz pakiet Free Pascal Compiler (FPC) z witryny Free Pascal i uruchom instalator. Uruchamiamy instalator, wybieramy katalog w kt\u00f3rym zostanie zainstalowany FPC . Wa\u017cne jest aby nie u\u017cywa\u0107 w nazwie katalogu znaku wykrzyknika ! czy innych nie standardowych znak\u00f3w. Je\u015bli nie uda nam si\u0119 skompilowa\u0107 \u017cadnego pliku, najpewniej winna jest nie standardowa nazwa \u015bcie\u017cki. Linia komend uruchamiaj\u0105ca kompilacj\u0119 mo\u017ce wygl\u0105da\u0107 nast\u0119puj\u0105co (wielko\u015b\u0107 liter w nazwach parametr\u00f3w ma znaczenie): fpc -Mdelphi -v mads.pas -Mdelphi pozwala kompilowa\u0107 plik w formacie Delphi -v wy\u015bwietla wszystkie komunikaty b\u0142\u0119d\u00f3w i ostrze\u017ce\u0144 -O3 dokonuje optymalizacji kodu W por\u00f3wnaniu z kompilatorem Delphi , kod wygenerowany przez FPC jest d\u0142u\u017cszy, za to pr\u0119dko\u015b\u0107 dzia\u0142ania skompilowanego nim MADS znacznie wi\u0119ksza, nawet o kilka sekund. Za\u0142\u0105czony plik mads.exe jest kompilowany przy u\u017cyciu FPC . MADS / XASM Podobie\u0144stwa ta sama sk\u0142adnia te same kody wyj\u015bcia te same makro rozkazy R\u00f3\u017cnice i nowe mo\u017cliwo\u015bci ma\u0142a r\u00f3\u017cnica w ORG , np.: ORG [[expression]]adres[,adres2] MADS nie akceptuje ORG a:adres ORG f:adres XASM nie lubi bia\u0142ych spacji , MADS toleruje je i akceptuje dla wyra\u017ce\u0144 logicznych, arytmetycznych, definicji sta\u0142ych i zmiennych MADS pozwala na umieszczanie wyra\u017ce\u0144 pomi\u0119dzy nawiasami () [] , XASM tylko pomi\u0119dzy [] MADS udost\u0119pnia definicje sta\u0142ych i zmiennych lokalne, globalne, tymczasowe, XASM tylko globalne MADS udost\u0119pnia zapis liczb rzeczywistych poprzez dyrektyw\u0119 .FL .FL real , XASM poprzez pseudo rozkaz DTA R , DTA R(real) MADS oferuje bardziej rozbudowan\u0105 obs\u0142ug\u0119 pseudo rozkazu INS MADS nie akceptuje sk\u0142adni typu lda (203),0 MADS umo\u017cliwia pisanie program\u00f3w dla Sparta DOS X MADS umo\u017cliwia generowanie kodu relokowalnego w swoim w\u0142asnym formacie MADS rozr\u00f3\u017cnia pojedyncze cudzys\u0142owy lda #' ' (kodowanie ATASCII) i podw\u00f3jne cudzys\u0142owy lda #\" ' (kodowanie INTERNAL) dla znak\u00f3w i \u0142a\u0144cuch\u00f3w. XASM traktuje obie formy tak samo (kodowanie ATASCII). Oczywi\u015bcie, dla danych DTA , cudzys\u0142owy nie s\u0105 rozr\u00f3\u017cniane przez MADS . MADS obs\u0142uguje dodatek + do zwi\u0119kszenia i dodatek - do zmniejszenia rejestru indeksowego w indeksowanych trybach adresowania, np: lda $2000,x+ -> lda $2000,x inx MADS obs\u0142uguje dodatek +<offset> do zwi\u0119kszania i dodatek -<offset> do zmniejszania adresu g\u0142\u00f3wnego operandu w trybach adresowania z indeksem bezwzgl\u0119dnym, np: lda $2000,x+2 -> lda $2002,x Linki MADS W\u0105tek Atari Age W\u0105tek W\u0105tek Atari Area Kolorowanie XASM * Strona domowa","title":"Wprowadzenie"},{"location":"wprowadzenie/#wstep","text":"W za\u0142o\u017ceniu MADS skierowany jest do u\u017cytkownik\u00f3w QA , XASM , FA . Z QA zapo\u017cyczona zosta\u0142a sk\u0142adnia, z XASM niekt\u00f3re makro rozkazy i zmiany sk\u0142adni, z FA obs\u0142uga sk\u0142adni Sparta DOS X (SDX). Umo\u017cliwione zosta\u0142o u\u017cycie dodatkowych znak\u00f3w w nazwach etykiet. Poza tym dodana zosta\u0142a obs\u0142uga CPU WDC 65816 , makr, procedur, podzia\u0142u pami\u0119ci na wirtualne banki, wielowymiarowych nazw etykiet. Maksymalna liczba etykiet i makr ograniczona jest ilo\u015bci\u0105 pami\u0119ci komputera PC . Konkretnie mo\u017cna dokona\u0107 2147483647 INTEGER wpis\u00f3w do tablic dynamicznych. Jestem pewien \u017ce taka ilo\u015b\u0107 jest wystarczaj\u0105ca :-). Operacje arytmetyczne dokonywane s\u0105 na warto\u015bciach typu INT64 (signed 64 bit), wynik reprezentowany jest na warto\u015bciach typu CARDINAL (unsigned 32 bit). Jeden wiersz mo\u017ce mie\u0107 d\u0142ugo\u015b\u0107 65535 bajt\u00f3w, takiej d\u0142ugo\u015bci mo\u017ce by\u0107 te\u017c nazwa etykiety. Nie mia\u0142em jednak okazji sprawdzi\u0107 tak d\u0142ugich etykiet i wierszy :-).","title":"Wst\u0119p"},{"location":"wprowadzenie/#kompilacja","text":"Mad-Assembler (MADS) jest aplikacj\u0105 Windows 32 bitow\u0105, napisan\u0105 w Delphi . Wi\u0119kszo\u015b\u0107 asembler\u00f3w napisano w C , wi\u0119c \u017ceby si\u0119 nie powtarza\u0107 u\u017cy\u0142em Delphi 7.0 ;-). Najnowsze \u017ar\u00f3d\u0142a s\u0105 dost\u0119pne na GitHub . Aby je skompilowa\u0107, mo\u017cna u\u017cy\u0107 kompilatora Delphi , je\u015bli mamy zainstalowane Delphi 7.0 lub nowsze. Dzi\u0119ki darmowemu kompilatorowi Free Pascal Compiler (FPC) mo\u017cliwa jest kompilacja MADS dla innych platform systemowych, np. Linux , macOS itp. Pobierz pakiet Free Pascal Compiler (FPC) z witryny Free Pascal i uruchom instalator. Uruchamiamy instalator, wybieramy katalog w kt\u00f3rym zostanie zainstalowany FPC . Wa\u017cne jest aby nie u\u017cywa\u0107 w nazwie katalogu znaku wykrzyknika ! czy innych nie standardowych znak\u00f3w. Je\u015bli nie uda nam si\u0119 skompilowa\u0107 \u017cadnego pliku, najpewniej winna jest nie standardowa nazwa \u015bcie\u017cki. Linia komend uruchamiaj\u0105ca kompilacj\u0119 mo\u017ce wygl\u0105da\u0107 nast\u0119puj\u0105co (wielko\u015b\u0107 liter w nazwach parametr\u00f3w ma znaczenie): fpc -Mdelphi -v mads.pas -Mdelphi pozwala kompilowa\u0107 plik w formacie Delphi -v wy\u015bwietla wszystkie komunikaty b\u0142\u0119d\u00f3w i ostrze\u017ce\u0144 -O3 dokonuje optymalizacji kodu W por\u00f3wnaniu z kompilatorem Delphi , kod wygenerowany przez FPC jest d\u0142u\u017cszy, za to pr\u0119dko\u015b\u0107 dzia\u0142ania skompilowanego nim MADS znacznie wi\u0119ksza, nawet o kilka sekund. Za\u0142\u0105czony plik mads.exe jest kompilowany przy u\u017cyciu FPC .","title":"Kompilacja"},{"location":"wprowadzenie/#mads-xasm","text":"","title":"MADS / XASM"},{"location":"wprowadzenie/#podobienstwa","text":"ta sama sk\u0142adnia te same kody wyj\u015bcia te same makro rozkazy","title":"Podobie\u0144stwa"},{"location":"wprowadzenie/#roznice-i-nowe-mozliwosci","text":"ma\u0142a r\u00f3\u017cnica w ORG , np.: ORG [[expression]]adres[,adres2] MADS nie akceptuje ORG a:adres ORG f:adres XASM nie lubi bia\u0142ych spacji , MADS toleruje je i akceptuje dla wyra\u017ce\u0144 logicznych, arytmetycznych, definicji sta\u0142ych i zmiennych MADS pozwala na umieszczanie wyra\u017ce\u0144 pomi\u0119dzy nawiasami () [] , XASM tylko pomi\u0119dzy [] MADS udost\u0119pnia definicje sta\u0142ych i zmiennych lokalne, globalne, tymczasowe, XASM tylko globalne MADS udost\u0119pnia zapis liczb rzeczywistych poprzez dyrektyw\u0119 .FL .FL real , XASM poprzez pseudo rozkaz DTA R , DTA R(real) MADS oferuje bardziej rozbudowan\u0105 obs\u0142ug\u0119 pseudo rozkazu INS MADS nie akceptuje sk\u0142adni typu lda (203),0 MADS umo\u017cliwia pisanie program\u00f3w dla Sparta DOS X MADS umo\u017cliwia generowanie kodu relokowalnego w swoim w\u0142asnym formacie MADS rozr\u00f3\u017cnia pojedyncze cudzys\u0142owy lda #' ' (kodowanie ATASCII) i podw\u00f3jne cudzys\u0142owy lda #\" ' (kodowanie INTERNAL) dla znak\u00f3w i \u0142a\u0144cuch\u00f3w. XASM traktuje obie formy tak samo (kodowanie ATASCII). Oczywi\u015bcie, dla danych DTA , cudzys\u0142owy nie s\u0105 rozr\u00f3\u017cniane przez MADS . MADS obs\u0142uguje dodatek + do zwi\u0119kszenia i dodatek - do zmniejszenia rejestru indeksowego w indeksowanych trybach adresowania, np: lda $2000,x+ -> lda $2000,x inx MADS obs\u0142uguje dodatek +<offset> do zwi\u0119kszania i dodatek -<offset> do zmniejszania adresu g\u0142\u00f3wnego operandu w trybach adresowania z indeksem bezwzgl\u0119dnym, np: lda $2000,x+2 -> lda $2002,x","title":"R\u00f3\u017cnice i nowe mo\u017cliwo\u015bci"},{"location":"wprowadzenie/#linki","text":"MADS W\u0105tek Atari Age W\u0105tek W\u0105tek Atari Area Kolorowanie XASM * Strona domowa","title":"Linki"}]}